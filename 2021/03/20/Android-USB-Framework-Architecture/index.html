<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="&amp;nbsp;  &amp;nbsp; 基本概念USB是通用串行总线（Universal Serial Bus）的缩写，，目前USB协议版本如下     USB Version BandWidth Power Note     USB1.0 1.5Mbps 5V&#x2F;500mA USB LOW SPEED   USB1.1 12Mbps 5V&#x2F;500mA USB FULL SPEED   USB2.0 480">
<meta property="og:type" content="article">
<meta property="og:title" content="Android_USB_Framework_Architecture">
<meta property="og:url" content="http://example.com/2021/03/20/Android-USB-Framework-Architecture/index.html">
<meta property="og:site_name" content="LexYoung笔记">
<meta property="og:description" content="&amp;nbsp;  &amp;nbsp; 基本概念USB是通用串行总线（Universal Serial Bus）的缩写，，目前USB协议版本如下     USB Version BandWidth Power Note     USB1.0 1.5Mbps 5V&#x2F;500mA USB LOW SPEED   USB1.1 12Mbps 5V&#x2F;500mA USB FULL SPEED   USB2.0 480">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2021/03/20/Android-USB-Framework-Architecture/USB_Topology.PNG">
<meta property="og:image" content="http://example.com/2021/03/20/Android-USB-Framework-Architecture/Type-C_pin.jpg">
<meta property="og:image" content="http://example.com/2021/03/20/Android-USB-Framework-Architecture/Type-C_receptacle_plug.PNG">
<meta property="og:image" content="http://example.com/2021/03/20/Android-USB-Framework-Architecture/USB_Descriptor.jpg">
<meta property="og:image" content="http://example.com/2021/03/20/Android-USB-Framework-Architecture/Android-USB-Framework-Architecture_Host.jpg">
<meta property="og:image" content="http://example.com/2021/03/20/Android-USB-Framework-Architecture/USB_STRUCT.PNG">
<meta property="og:image" content="http://example.com/2021/03/20/Android-USB-Framework-Architecture/USB_HUB_Timing_Diagram.JPG">
<meta property="og:image" content="http://example.com/2021/03/20/Android-USB-Framework-Architecture/USB_FLOW.jpg">
<meta property="og:image" content="http://example.com/2021/03/20/Android-USB-Framework-Architecture/Android_USB_Framework_Architecture_Device.jpg">
<meta property="og:image" content="http://example.com/2021/03/20/Android-USB-Framework-Architecture/UDC_STRUCT.bmp">
<meta property="og:image" content="http://example.com/2021/03/20/Android-USB-Framework-Architecture/USB_Gadget_Framework.jpg">
<meta property="og:image" content="http://example.com/2021/03/20/Android-USB-Framework-Architecture/UDC_Framework.jpg">
<meta property="article:published_time" content="2021-03-20T08:52:31.000Z">
<meta property="article:modified_time" content="2021-06-29T01:54:20.653Z">
<meta property="article:author" content="LexYoung">
<meta property="article:tag" content="usb">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/03/20/Android-USB-Framework-Architecture/USB_Topology.PNG">

<link rel="canonical" href="http://example.com/2021/03/20/Android-USB-Framework-Architecture/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Android_USB_Framework_Architecture | LexYoung笔记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LexYoung笔记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/20/Android-USB-Framework-Architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LexYoung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LexYoung笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android_USB_Framework_Architecture
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-20 16:52:31" itemprop="dateCreated datePublished" datetime="2021-03-20T16:52:31+08:00">2021-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-06-29 09:54:20" itemprop="dateModified" datetime="2021-06-29T09:54:20+08:00">2021-06-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/usb/" itemprop="url" rel="index"><span itemprop="name">usb</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <!-- toc -->
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>USB是通用串行总线（Universal Serial Bus）的缩写，，目前USB协议版本如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>USB Version</th>
<th>BandWidth</th>
<th>Power</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>USB1.0</td>
<td>1.5Mbps</td>
<td>5V/500mA</td>
<td>USB LOW SPEED</td>
</tr>
<tr>
<td>USB1.1</td>
<td>12Mbps</td>
<td>5V/500mA</td>
<td>USB FULL SPEED</td>
</tr>
<tr>
<td>USB2.0</td>
<td>480Mbps</td>
<td>5V/500mA</td>
<td>USB HIGH SPEED</td>
</tr>
<tr>
<td>USB3.0</td>
<td>5Gbps</td>
<td>5V/1A</td>
<td>SuperSpeed USB<br>当USB3.1推出时，USB3.0被追溯命名为 USB 3.1 Gen 1,<br>在2019年USB IF再次更新标准，USB3.0被称为USB 3.2 Gen1</td>
</tr>
<tr>
<td>USB3.1</td>
<td>10Gbps</td>
<td>5V/1A <br>12V/2A <br>20V/5A</td>
<td>SuperSpeed USB 10Gbps<br>当USB3.1推出时，按照新的标准命名为USB 3.1 Gen2，<br>在2019年USB IF再次更新标准，被重命名为USB 3.2 Gen 2</td>
</tr>
<tr>
<td>USB3.2</td>
<td>20Gbps</td>
<td>5V/1A<br>12V/2A<br>20V/5A</td>
<td>SuperSpeed USB 20Gbps<br>根据新标准，被命名为USB 3.2 Gen 2×2</td>
</tr>
<tr>
<td>USB4.0</td>
<td>40Gbps</td>
<td>5V/1A<br>12V/2A<br>20V/5A</td>
<td>只是协议，还没有配套硬件推出</td>
</tr>
</tbody>
</table>
</div>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h3><p>USB的拓扑结构如下，可以看到主要由3种元素组成：主机、Hub和设备。<br><img src="/2021/03/20/Android-USB-Framework-Architecture/USB_Topology.PNG" alt="USB_Topology"></p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="物理接口"><a href="#物理接口" class="headerlink" title="物理接口"></a>物理接口</h3><p>物理接口分为3类，USB1.x &amp;&amp; USB2.0，USB3.x和 Type-C，下面分别介绍3种类别的物理接口</p>
<p>USB1.x &amp;&amp; USB2.0:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>引脚</th>
<th>线缆颜色</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>VBUS</td>
<td>红色</td>
<td>+5V供电</td>
<td>Type-A/B</td>
</tr>
<tr>
<td>D+</td>
<td>白色</td>
<td>差分数据线</td>
<td>Type-A/B</td>
</tr>
<tr>
<td>D-</td>
<td>绿色</td>
<td>差分数据线</td>
<td>Type-A/B</td>
</tr>
<tr>
<td>GND</td>
<td>黑色</td>
<td>地</td>
<td>Type-A/B</td>
</tr>
<tr>
<td>ID</td>
<td>N/A</td>
<td>见如下备注</td>
<td>mini/micro-A/B USB</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">备注：</span><br><span class="line">当设备检测到USB_ID信号为低时，表该设备应作为Host（主机，也称A设备）用。</span><br><span class="line">当设备检测到USB_ID信号为高时，表示该设备作为Slave(外设，也称B设备）用。</span><br><span class="line">实际的USB连接线中，是没有USB_ID这根线的。 都是在接口部分直接拉死的的。</span><br><span class="line">对于Host端，只需将连接线的USB_ID pin和地短接即可，</span><br><span class="line">对于Slave端，USB连接线的USB_ID pin是悬空的。（设备内部上拉）。</span><br></pre></td></tr></table></figure>
<p>USB3.x:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>A型连接器引脚B</th>
<th>B型连接器引脚</th>
<th>线缆颜色</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>VBUS</td>
<td>VBUS</td>
<td>红色</td>
<td>供电</td>
</tr>
<tr>
<td>D+</td>
<td>D+</td>
<td>绿色</td>
<td>USB 2.0数据差分线</td>
</tr>
<tr>
<td>D-</td>
<td>D-</td>
<td>白色</td>
<td>USB 2.0数据差分线</td>
</tr>
<tr>
<td>GND</td>
<td>GND</td>
<td>黑色</td>
<td>电源低</td>
</tr>
<tr>
<td>StdA_SSRX-</td>
<td>StdA_SSTX-</td>
<td>蓝色</td>
<td>高速数据差分对</td>
</tr>
<tr>
<td>StdA_SSR+</td>
<td>StdA_SSTX-</td>
<td>黄色</td>
<td>高速数据差分对</td>
</tr>
<tr>
<td>GND_DRAIN</td>
<td>GND_DRAIN</td>
<td>N/A</td>
<td>信号地</td>
</tr>
<tr>
<td>StdA_SSTX-</td>
<td>StdA_SSRX-</td>
<td>紫色</td>
<td>高速数据差分对</td>
</tr>
<tr>
<td>StdA_SSTX-</td>
<td>StdA_SSR+</td>
<td>橙色</td>
<td>高速数据差分对</td>
</tr>
</tbody>
</table>
</div>
<p>TYPE-C：Type-C的所有引脚定义如下图所示：<br><img src="/2021/03/20/Android-USB-Framework-Architecture/Type-C_pin.jpg" alt="Type-C_pin"></p>
<p>其中Type-C USB的插座和插头并不完全一样，相关定义如下图<br><img src="/2021/03/20/Android-USB-Framework-Architecture/Type-C_receptacle_plug.PNG" alt="Type-C_receptacle_plug"></p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h3><p>USB的4种传输模式如下，这里只是粗略列出来：<br>控制传输：用于usb枚举过程<br>批量传输：用于大容量存储设备<br>等时传输：用于音频，视频设备<br>中断传输：用于鼠标键盘等设备</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h3><p>这里只说明USB的最基础常用的描述符</p>
<ol>
<li><p>标准描述符：是指一组准备设备描述符，他们具有类似的格式</p>
<ul>
<li>设备描述符：设备描述符描述有关USB设备的一般信息。它包括信息全局适用于设备和所有设备的配置。 USB设备只有一个设备描述符。</li>
<li>配置描述符：一个USB设备可以有多种配置，不同的配置使设备工作在不同的状态下。每个配置必须有一个配置描述符， 每个配置都有一个或多个接口，每个接口都有零个或多个端点。</li>
<li>字符串描述符：在USB协议中字符串描述符是可选的。字符串描述符用于保存一些供应商名称、产品序列号等文本信息</li>
<li>接口描述符：接口是端点的集合，负责完成USB的特定功能，例如数据的输入输出。接口描述符用于描述一个接口，包含了接口的特性，如端点个数，所属设备类和子类等。</li>
<li>端点描述符：描述端点的基本属性（地址，大小等）</li>
</ul>
</li>
<li><p>HID描述符：即Human Interface Devices，人机接口设备。这类设备包括鼠标、键盘等，主要用于人与计算机进行交互，传输方式通常采用中断方式。</p>
</li>
</ol>
<p>如下为某设备的基础描述符关系图：<br><img src="/2021/03/20/Android-USB-Framework-Architecture/USB_Descriptor.jpg" alt="USB_Descriptor"></p>
<ul>
<li>该设备有2个配置：配置0和配置1</li>
<li>配置0下面有1个接口：接口0，该接口下有3个端点</li>
<li>配置1下面有2个接口：接口0和接口1</li>
<li>接口0下面有1个端点，接口1下面有2个端点</li>
</ul>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="枚举流程"><a href="#枚举流程" class="headerlink" title="枚举流程"></a>枚举流程</h3><p>枚举就是从设备读取一些信息，知道设备是什么样的设备，使用什么协议，这样Host就可以根据这些信息来加载合适的驱动程序与Device进行通信。<br>枚举流程大致如下，这里只是简单说明一下流程，后面会根据代码进行情景分析。</p>
<ol>
<li>USB设备插入Uost的根hub或者下行端口上的hub端口或者系统启动时设备上电。</li>
<li>Hub端口通过 D+/D- 的电压值来判断是全速/低速设备插入端口。</li>
<li>Host通过Get_Port_Status请求(request)给hub以了解此次状态改变的确切含义。</li>
<li>Hub端口把设备的速度信息反馈给Host。</li>
<li>Host端口通过Set_Port_Feature请求让hub端口同时拉低D+/D-来复位刚插入的USB设备。</li>
<li>如果前面Hub端口通过 D+/D- 判断设备支持全速，Host端口继续检测所连接的USB设备是否支持高速模式。</li>
<li>Host向hub发现Get_Port_Status请求，以查询设备是否复位成功。</li>
<li>Host发送Get_Descriptor获取设备描述符，主要是获取描述符的长度，然后设备再次进行复位操作。</li>
<li>Host分配地址给设备</li>
<li>Host再次发送Get_Descriptor给新的usb设备地址来读取设备描述符，之后Host再通过Get_Descriptor来读取配置描述符，接口描述符，字符描述符。</li>
<li>Host通过获取到的设备信息，整合之后，找到该设备的驱动。</li>
<li>设备驱动选择一个配置。</li>
</ol>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h2 id="Android-USB-Driver"><a href="#Android-USB-Driver" class="headerlink" title="Android USB Driver"></a>Android USB Driver</h2><p>Android USB既可以做host，起控制作用，也可以作为slave，来应答host的控制。<br>Android USB设备，当连接PC时，自身作为Devcie设备，当连接U盘时，自身作为Host设备。<br>下面我们分别从 Host 和 Device 2个方面来分析 Android USB driver。</p>
<h3 id="Android-USB-Host"><a href="#Android-USB-Host" class="headerlink" title="Android USB Host"></a>Android USB Host</h3><p>USB Host整体如下图左侧：<br><img src="/2021/03/20/Android-USB-Framework-Architecture/Android-USB-Framework-Architecture_Host.jpg" alt="Android_USB_Framework_Architecture_Host"></p>
<p>Android USB作为host时，软件架构分为如下3层：</p>
<ul>
<li>USB设备驱动：具体的USB外设设备驱动，针对不同的USB外设，需要加载不同的USB设备驱动，比如说U盘需要加载 mass storage usb设备驱动，鼠标需要加载 mouse usb设备驱动</li>
<li>USB core：Linux usb的核心协议栈，纯软件部分，为USB设备驱动程序提供一个用于访问和控制USB硬件的接口，是USB设备驱动和HCD的桥梁。</li>
<li>HCD：Host controller Driver的缩写，是对主机控制器硬件的一个抽象，USB HCD包含多种USB接口规范：UHCI,OHCI,EHCI。</li>
</ul>
<p>下面我们根据代码流程详细分析Android USB host。</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h4 id="代码路径"><a href="#代码路径" class="headerlink" title="代码路径"></a>代码路径</h4><div class="table-container">
<table>
<thead>
<tr>
<th>模块</th>
<th>路径</th>
</tr>
</thead>
<tbody>
<tr>
<td>core</td>
<td>kernel/msm-4.19/drivers/usb/core/usb.c</td>
</tr>
<tr>
<td>dwc3</td>
<td>kernel/msm-4.19/drivers/usb/dwc3/core.c</td>
</tr>
<tr>
<td>dwc3</td>
<td>kernel/msm-4.19/drivers/usb/dwc3/dwc3-msm.c</td>
</tr>
<tr>
<td>host</td>
<td>ernel/msm-4.19/drivers/usb/host/xhci-plat.c</td>
</tr>
<tr>
<td>ss-phy</td>
<td>kernel/msm-4.19/drivers/usb/phy/phy-msm-ssusb-qmp.c</td>
</tr>
<tr>
<td>hs-phy</td>
<td>kernel/msm-4.19/drivers/usb/phy/phy-msm-snps-hs.c</td>
</tr>
</tbody>
</table>
</div>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h4 id="核心结构体"><a href="#核心结构体" class="headerlink" title="核心结构体"></a>核心结构体</h4><p>在下面代码情景分析中，我们会遇到很多usb相关的结构体，下面列出核心结构体</p>
<ul>
<li>usb_device描述一个USB的device的软件信息，包括usb_device_descriptor</li>
<li>usb_device_descriptor来描述一个USB设备的device信息</li>
<li>urb_host_config描述一个USB设备config的软件信息，包括usb_config_descriptor</li>
<li>usb_config_descriptor来描述一个device的config信息</li>
<li>usb_interface描述一个接口信息</li>
<li>usb_host_interface描述一个interface的设置信息，包括usb_interface_descriptor，我们编写驱动就是针对这一层次的</li>
<li>usb_interface_descriptor来描述一个config的interface信息</li>
<li>usb_host_endpoint描述一个interdace的endpoint信息，包括usb_endpoint_descriptor，这是USB通信的最小单位，我们读写一个设备就是针对一个endpoint</li>
<li>usb_endpoint_descriptor来描述一个interface的endpoint信息</li>
</ul>
<p>它们的关系如图所示：</p>
<p><img src="/2021/03/20/Android-USB-Framework-Architecture/USB_STRUCT.PNG" alt="usb struct"></p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h4 id="dwc3"><a href="#dwc3" class="headerlink" title="dwc3"></a>dwc3</h4><p>从dwc3的角度分析USB整体流程，查看反编译的dts如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ssusb@a600000 &#123;</span><br><span class="line">	compatible = <span class="string">&quot;qcom,dwc-usb3-msm&quot;</span>;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	dwc3@a600000 &#123;</span><br><span class="line">		compatible = <span class="string">&quot;snps,dwc3&quot;</span>;</span><br><span class="line">		...</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure><br>usb dts compatible匹配，导致如下2个probe执行</p>
<ul>
<li><p>a.compatible = “snps,dwc3”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** drivers/usb/dwc3/core.c **/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dwc3_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dwc3</span>		*<span class="title">dwc</span>;</span></span><br><span class="line">	<span class="comment">//分配内存</span></span><br><span class="line">	dwc = devm_kzalloc(dev, <span class="keyword">sizeof</span>(*dwc), GFP_KERNEL);</span><br><span class="line">	dwc-&gt;dev = dev;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//申请中断</span></span><br><span class="line">	irq = platform_get_irq(to_platform_device(dwc-&gt;dev), <span class="number">0</span>);</span><br><span class="line">	devm_request_irq(dev, irq, dwc3_interrupt, IRQF_SHARED, <span class="string">&quot;dwc3&quot;</span>, dwc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化队列</span></span><br><span class="line">	INIT_WORK(&amp;dwc-&gt;bh_work, dwc3_bh_work);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取dts中的属性，</span></span><br><span class="line">	dwc3_get_properties(dwc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//分配各种buffer的内存</span></span><br><span class="line">	dwc3_alloc_event_buffers(dwc, DWC3_EVENT_BUFFERS_SIZE);</span><br><span class="line">	dwc3_alloc_scratch_buffers(dwc);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * dts中dr_mode = otg 或者 peripheral，初始化gadget相关的寄存器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (dwc-&gt;dr_mode == USB_DR_MODE_OTG ||</span><br><span class="line">		dwc-&gt;dr_mode == USB_DR_MODE_PERIPHERAL) &#123;</span><br><span class="line">		ret = dwc3_gadget_init(dwc);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建debugfs节点编译调试</span></span><br><span class="line">	dwc3_debugfs_init(dwc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：这里主要做的一些基础的动作，如分配内存，申请中断，初始化队列，解析dts，初始化相关寄存器，创建debugfs节点等。</p>
</li>
<li><p>b.compatible = “qcom,dwc-usb3-msm”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** drivers/usb/dwc3/dwc3-msm.c **/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dwc3_msm_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dwc3_msm</span> *<span class="title">mdwc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dwc3</span>	*<span class="title">dwc</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//分配内存</span></span><br><span class="line">	mdwc = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(*mdwc), GFP_KERNEL);</span><br><span class="line">	mdwc-&gt;dev = &amp;pdev-&gt;dev;</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;mdwc-&gt;req_complete_list);</span><br><span class="line">	INIT_WORK(&amp;mdwc-&gt;resume_work, dwc3_resume_work);</span><br><span class="line">	INIT_WORK(&amp;mdwc-&gt;restart_usb_work, dwc3_restart_usb_work);</span><br><span class="line">	INIT_WORK(&amp;mdwc-&gt;vbus_draw_work, dwc3_msm_vbus_draw_work);</span><br><span class="line">	INIT_DELAYED_WORK(&amp;mdwc-&gt;sm_work, dwc3_otg_sm_work);</span><br><span class="line">	INIT_DELAYED_WORK(&amp;mdwc-&gt;perf_vote_work, msm_dwc3_perf_vote_work);</span><br><span class="line">	INIT_DELAYED_WORK(&amp;mdwc-&gt;sdp_check, check_for_sdp_connection);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//解析dts并赋值给mdwc</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * static const struct usb_irq usb_irq_info[USB_MAX_IRQ] = &#123;</span></span><br><span class="line"><span class="comment">	 * 		&#123;&quot;hs_phy_irq&quot;, 0&#125;,</span></span><br><span class="line"><span class="comment">	 * 		&#123;&quot;pwr_event_irq&quot;, 0&#125;,</span></span><br><span class="line"><span class="comment">	 * 		&#123;&quot;dp_hs_phy_irq&quot;, 0&#125;,</span></span><br><span class="line"><span class="comment">	 * 		&#123;&quot;dm_hs_phy_irq&quot;, 0&#125;,</span></span><br><span class="line"><span class="comment">	 * 		&#123;&quot;ss_phy_irq&quot;, 0&#125;,</span></span><br><span class="line"><span class="comment">	 * &#125;;</span></span><br><span class="line"><span class="comment">	 * 申请usb_irq_info数组中的中断</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	devm_request_threaded_irq(&amp;pdev-&gt;dev,</span><br><span class="line">			mdwc-&gt;wakeup_irq[i].irq,</span><br><span class="line">			msm_dwc3_pwr_irq,</span><br><span class="line">			msm_dwc3_pwr_irq_thread,</span><br><span class="line">			irq_type,</span><br><span class="line">			mdwc-&gt;wakeup_irq[i].name, mdwc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//继续解析dts赋值给mdwc</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置notify_event = dwc3_msm_notify_event;</span></span><br><span class="line">	dwc3_set_notifier(&amp;dwc3_msm_notify_event);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//又双叒解析dts赋值给mdwc</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (dwc-&gt;dr_mode) &#123;</span><br><span class="line">	<span class="keyword">case</span> USB_DR_MODE_OTG:</span><br><span class="line">		<span class="keyword">if</span> (of_property_read_bool(node,</span><br><span class="line">					<span class="string">&quot;qcom,default-mode-host&quot;</span>)) &#123;</span><br><span class="line">			dev_dbg(mdwc-&gt;dev, <span class="string">&quot;%s: start host mode\n&quot;</span>,</span><br><span class="line">							__func__);</span><br><span class="line">			mdwc-&gt;id_state = DWC3_ID_GROUND;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (of_property_read_bool(node,</span><br><span class="line">					<span class="string">&quot;qcom,default-mode-none&quot;</span>)) &#123;</span><br><span class="line">			dev_dbg(mdwc-&gt;dev, <span class="string">&quot;%s: stay in none mode\n&quot;</span>,</span><br><span class="line">							__func__);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			dev_dbg(mdwc-&gt;dev, <span class="string">&quot;%s: start peripheral mode\n&quot;</span>,</span><br><span class="line">							__func__);</span><br><span class="line">			mdwc-&gt;vbus_active = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> USB_DR_MODE_HOST:</span><br><span class="line">		mdwc-&gt;id_state = DWC3_ID_GROUND;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> USB_DR_MODE_PERIPHERAL:</span><br><span class="line">		<span class="comment">/* fall through */</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		mdwc-&gt;vbus_active = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 根据状态来设置mdwc-&gt;inputs，每个bit的含义如下</span></span><br><span class="line"><span class="comment">	/* Input bits to state machine (mdwc-&gt;inputs) */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * #define ID			0</span></span><br><span class="line"><span class="comment">	 * #define B_SESS_VLD		1</span></span><br><span class="line"><span class="comment">	 * #define B_SUSPEND		2</span></span><br><span class="line"><span class="comment">	 * #define WAIT_FOR_LPM		3</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dwc3_ext_event_notify(mdwc);</span><br><span class="line">		---&gt;根据当前状态设置mdwc-&gt;inputs的ID，B_SESS_VLD和B_SUSPEND bit</span><br><span class="line">		---&gt;queue_delayed_work(mdwc-&gt;sm_usb_wq, &amp;mdwc-&gt;sm_work, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建属性节点</span></span><br><span class="line">	device_create_file(&amp;pdev-&gt;dev, &amp;dev_attr_mode);</span><br><span class="line">	device_create_file(&amp;pdev-&gt;dev, &amp;dev_attr_speed);</span><br><span class="line">	device_create_file(&amp;pdev-&gt;dev, &amp;dev_attr_usb_compliance_mode);</span><br><span class="line">	device_create_file(&amp;pdev-&gt;dev, &amp;dev_attr_bus_vote);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>总结：</p>
<ol>
<li>一系列初始化动作：分配内存，初始化队列，解析dts，申请中断…</li>
<li>根据当前状态设置mdwc-&gt;inputs bit，一共有4个bit：ID，B_SESS_VLD,B_SUSPEND，WAIT_FOR_LPM</li>
<li>调用队列函数 dwc3_otg_sm_work</li>
<li>创建属性节点</li>
</ol>
<p>接下来是 dwc3_otg_sm_work 函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** kernel/msm-4.19/drivers/usb/dwc3/dwc3-msm.c **/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dwc3_otg_sm_work - workqueue function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @w: Pointer to the dwc3 otg workqueue</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> After any change in drd_state, we must reschdule the state machine.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * dwc3状态机，根据 mdwc-&gt;inputs 和 mdwc-&gt;drd_state来确定当前的状态</span></span><br><span class="line"><span class="comment"> * 这里主要是host状态和device状态，对应函数如下</span></span><br><span class="line"><span class="comment"> * Device ---&gt; dwc3_otg_start_peripheral(mdwc, 1);</span></span><br><span class="line"><span class="comment"> * Host ---&gt; dwc3_otg_start_host(mdwc, 1);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dwc3_otg_sm_work</span><span class="params">(struct work_struct *w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dwc3_msm</span> *<span class="title">mdwc</span> = <span class="title">container_of</span>(<span class="title">w</span>, <span class="title">struct</span> <span class="title">dwc3_msm</span>, <span class="title">sm_work</span>.<span class="title">work</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dwc3</span> *<span class="title">dwc</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check OTG state */</span></span><br><span class="line">	<span class="keyword">switch</span> (mdwc-&gt;drd_state) &#123;</span><br><span class="line">	<span class="keyword">case</span> DRD_STATE_UNDEFINED:</span><br><span class="line">		...</span><br><span class="line">		mdwc-&gt;drd_state = DRD_STATE_IDLE;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">/* fall-through */</span></span><br><span class="line">	<span class="keyword">case</span> DRD_STATE_IDLE:</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">//恢复dwc3的工作</span></span><br><span class="line">		queue_delayed_work(mdwc-&gt;dwc3_wq,</span><br><span class="line">				&amp;mdwc-&gt;sdp_check,</span><br><span class="line">		msecs_to_jiffies(SDP_CONNETION_CHECK_TIME));</span><br><span class="line">		---&gt;queue_work(mdwc-&gt;dwc3_wq, &amp;mdwc-&gt;resume_work);</span><br><span class="line">		...</span><br><span class="line">		dwc3_otg_start_peripheral(mdwc, <span class="number">1</span>);</span><br><span class="line">		mdwc-&gt;drd_state = DRD_STATE_PERIPHERAL;</span><br><span class="line">		work = <span class="number">1</span>;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DRD_STATE_PERIPHERAL:</span><br><span class="line">		...</span><br><span class="line">		mdwc-&gt;drd_state = DRD_STATE_IDLE;</span><br><span class="line">		dwc3_otg_start_peripheral(mdwc, <span class="number">0</span>);</span><br><span class="line">		work = <span class="number">1</span>;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DRD_STATE_PERIPHERAL_SUSPEND:</span><br><span class="line">		...</span><br><span class="line">		mdwc-&gt;drd_state = DRD_STATE_IDLE;</span><br><span class="line">		dwc3_otg_start_peripheral(mdwc, <span class="number">0</span>);</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> DRD_STATE_HOST_IDLE:</span><br><span class="line">	</span><br><span class="line">		mdwc-&gt;drd_state = DRD_STATE_HOST;</span><br><span class="line">		dwc3_otg_start_host(mdwc, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> DRD_STATE_HOST:</span><br><span class="line">			dev_dbg(mdwc-&gt;dev, <span class="string">&quot;id || hc_died\n&quot;</span>);</span><br><span class="line">			dwc3_otg_start_host(mdwc, <span class="number">0</span>);</span><br><span class="line">			mdwc-&gt;drd_state = DRD_STATE_IDLE;</span><br><span class="line">			work = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		dev_err(mdwc-&gt;dev, <span class="string">&quot;%s: invalid otg-state\n&quot;</span>, __func__);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (work)</span><br><span class="line">		schedule_delayed_work(&amp;mdwc-&gt;sm_work, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>总结：dw3状态机，当mdwc-&gt;drd_state 发生改变，调用此队列，主要作用是根据 mdwc-&gt;drd_state 和 mdwc-&gt;inputs 来确认状态并调用对应的动作，这里最主要是根据host还是devices分别调用如下函数</p>
<ul>
<li>Host —-&gt; dwc3_otg_start_host</li>
<li>Device —-&gt; dwc3_otg_start_peripheral</li>
</ul>
<p>这里只介绍作为Host来分析代码，作Device的流程后面专门会分析<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** kernel/msm-4.19/drivers/usb/dwc3/dwc3-msm.c **/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dwc3_otg_start_host</span><span class="params">(struct dwc3_msm *mdwc, <span class="keyword">int</span> on)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dwc3</span> *<span class="title">dwc</span> = <span class="title">platform_get_drvdata</span>(<span class="title">mdwc</span>-&gt;<span class="title">dwc3</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (on) &#123;</span><br><span class="line">		dev_dbg(mdwc-&gt;dev, <span class="string">&quot;%s: turn on host\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * CONFIG_USB_MSM_SSPHY_QMP=y</span></span><br><span class="line"><span class="comment">		 * ---&gt;Enable this to support the SuperSpeed USB transceiver on MSM chips.</span></span><br><span class="line"><span class="comment">		 * CONFIG_MSM_HSUSB_PHY=y</span></span><br><span class="line"><span class="comment">		 * ---&gt;Enable this to support the HSUSB PHY on MSM chips.</span></span><br><span class="line"><span class="comment">		 * 调用SuperSpeed PHY和 high-speed PHY对应的驱动来修改连接状态</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		usb_phy_notify_connect(mdwc-&gt;ss_phy, USB_SPEED_SUPER);</span><br><span class="line">		usb_phy_notify_connect(mdwc-&gt;hs_phy, USB_SPEED_HIGH);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//注册host_nb通知事件链</span></span><br><span class="line">		mdwc-&gt;host_nb.notifier_call = dwc3_msm_host_notifier;</span><br><span class="line">		usb_register_notify(&amp;mdwc-&gt;host_nb);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//注册usbdev_nb通知事件链</span></span><br><span class="line">		mdwc-&gt;usbdev_nb.notifier_call = msm_dwc3_usbdev_notify;</span><br><span class="line">		usb_register_atomic_notify(&amp;mdwc-&gt;usbdev_nb);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">/************************************************</span></span><br><span class="line"><span class="comment">        从 xhci-plat的角度，Path如下:</span></span><br><span class="line"><span class="comment">        kernel/msm-4.9/drivers/usb/host/xhci-plat.c</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        Source:</span></span><br><span class="line"><span class="comment">        static struct platform_driver usb_xhci_driver = &#123;</span></span><br><span class="line"><span class="comment">            .probe	= xhci_plat_probe,</span></span><br><span class="line"><span class="comment">            .remove	= xhci_plat_remove,</span></span><br><span class="line"><span class="comment">            .driver	= &#123;</span></span><br><span class="line"><span class="comment">                .name = &quot;xhci-hcd&quot;,</span></span><br><span class="line"><span class="comment">                .pm = DEV_PM_OPS,</span></span><br><span class="line"><span class="comment">                .of_match_table = of_match_ptr(usb_xhci_of_match),</span></span><br><span class="line"><span class="comment">                .acpi_match_table = ACPI_PTR(usb_xhci_acpi_match),</span></span><br><span class="line"><span class="comment">            &#125;,</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        static int __init xhci_plat_init(void)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            xhci_init_driver(&amp;xhci_plat_hc_driver, &amp;xhci_plat_overrides);</span></span><br><span class="line"><span class="comment">            return platform_driver_register(&amp;usb_xhci_driver);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">		************************************************/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 这里调用platform device add 和上面的drvier 的name匹配，导致调用 xhci_plat_probe 函数</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		dwc3_host_init(dwc);</span><br><span class="line">		---&gt;platform_device_alloc(<span class="string">&quot;xhci-hcd&quot;</span>, PLATFORM_DEVID_AUTO);</span><br><span class="line">		---&gt;platform_device_add(xhci);</span><br><span class="line">	</span><br><span class="line">		mdwc-&gt;in_host_mode = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		msm_dwc3_perf_vote_update(mdwc, <span class="literal">true</span>);</span><br><span class="line">		schedule_delayed_work(&amp;mdwc-&gt;perf_vote_work,</span><br><span class="line">				msecs_to_jiffies(<span class="number">1000</span> * PM_QOS_SAMPLE_SEC));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//stop the host controller driver.</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>总结：</p>
<ol>
<li>通过 platform_device_add 来注册 “xhci-hcd” 设备。</li>
<li>在xhci-plat.c中有注册 “xhci-hcd” 驱动，这样导致对应的 xhci_plat_probe被调用。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xhci_plat_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">hc_driver</span>	*<span class="title">driver</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xhci_hcd</span>		*<span class="title">xhci</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_hcd</span>		*<span class="title">hcd</span>;</span></span><br><span class="line"></span><br><span class="line">	driver = &amp;xhci_plat_hc_driver;</span><br><span class="line"></span><br><span class="line">	irq = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	hcd = __usb_create_hcd(driver, sysdev, &amp;pdev-&gt;dev,</span><br><span class="line">			       dev_name(&amp;pdev-&gt;dev), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* convert between an HCD pointer and the corresponding EHCI_HCD */</span></span><br><span class="line">	hcd_to_xhci(hcd);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 获取并调用相关phy的初始化函数 */</span></span><br><span class="line">	hcd-&gt;usb_phy = devm_usb_get_phy_by_phandle(phydev, <span class="string">&quot;usb-phy&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	usb_phy_init(hcd-&gt;usb_phy);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 对HCD进行初始化和注册 */</span></span><br><span class="line">	usb_add_hcd(hcd, irq, IRQF_SHARED);</span><br><span class="line">		<span class="comment">/* 注册 a root hub */</span></span><br><span class="line">	---&gt; register_root_hub(hcd)</span><br><span class="line">			<span class="comment">/* 执行usb core 内部的初始化设置，构建新usb devices */</span></span><br><span class="line">		---&gt; usb_new_device (usb_dev)</span><br><span class="line">			---&gt; usb_enumerate_device(udev)</span><br><span class="line">				<span class="comment">/* </span></span><br><span class="line"><span class="comment">				 * 在hub.c中有注册 &quot;hub&quot; driver:usb_register(&amp;hub_driver)</span></span><br><span class="line"><span class="comment">				 * 2者匹配导致 hub_probe 被调用 </span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">			---&gt; device_add(&amp;udev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建device attr file */</span></span><br><span class="line">	device_create_file(&amp;pdev-&gt;dev, &amp;dev_attr_config_imod);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：这里核心函数为 usb_add_hcd，主要是对HCD进行初始化和注册，最终会把 “hub” 通过device_add添加到设备队列中。而另外在 usb/core/hub.c 中，有通过usb_register(&amp;hub_driver)来注册 “hub” 驱动，从而导致 hub_probe 被调用。</p>
<p>这里简单时序图如下:<br><img src="/2021/03/20/Android-USB-Framework-Architecture/USB_HUB_Timing_Diagram.JPG" alt="USB root  hub flow"></p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h4 id="usb-core"><a href="#usb-core" class="headerlink" title="usb core"></a>usb core</h4><p>在介绍 hub_probe 之前，我们从usb core的角度从上到下分析一下代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** kernel/msm-4.19/drivers/usb/core/usb.c **/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">usb_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	usb_init_pool_max();<span class="comment">//初始化pool_max数组</span></span><br><span class="line"></span><br><span class="line">	usb_debugfs_init();<span class="comment">//初始化usb debugfs</span></span><br><span class="line"></span><br><span class="line">	usb_acpi_register();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注册usb 总线，生成/sys/bus/usb文件目录</span></span><br><span class="line">	<span class="comment">//当我们注册一个总线的时候，他会初始化两个链表，一个用来链接总线上所有的device，一个用来链接总线上所有的driver</span></span><br><span class="line">	bus_register(&amp;usb_bus_type);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化通知链，回调函数为usb_bus_nb</span></span><br><span class="line">	bus_register_notifier(&amp;usb_bus_type, &amp;usb_bus_nb);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注册 usb 字符设备，主设备号180</span></span><br><span class="line">	usb_major_init();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注册usbfs驱动,添加到上面的usb总线上</span></span><br><span class="line">	usb_register(&amp;usbfs_driver);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注册 usb 字符设备，主设备号189</span></span><br><span class="line">	usb_devio_init();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注册usb hub驱动，重点分析该函数</span></span><br><span class="line">	usb_hub_init();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//注册usb_generic_driver驱动</span></span><br><span class="line">	usb_register_device_driver(&amp;usb_generic_driver, THIS_MODULE);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usb总线结构体</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">usb_bus_type</span> = &#123;</span></span><br><span class="line">	.name =		<span class="string">&quot;usb&quot;</span>,</span><br><span class="line">	.match =	usb_device_match,</span><br><span class="line">	.uevent =	usb_uevent,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">usb通知链回调函数结构体</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> <span class="title">usb_bus_nb</span> = &#123;</span></span><br><span class="line">	.notifier_call = usb_bus_notify,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">注册字符设备，主设备号为<span class="number">180</span>对应的结构体</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">usb_fops</span> = &#123;</span></span><br><span class="line">	.owner =	THIS_MODULE,</span><br><span class="line">	.open =		usb_open,</span><br><span class="line">	.llseek =	noop_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">usbfs 驱动相关结构体</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">usbfs_driver</span> = &#123;</span></span><br><span class="line">	.name =		<span class="string">&quot;usbfs&quot;</span>,</span><br><span class="line">	.probe =	driver_probe,</span><br><span class="line">	.disconnect =	driver_disconnect,</span><br><span class="line">	.suspend =	driver_suspend,</span><br><span class="line">	.resume =	driver_resume,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">注册字符设备，主设备号为<span class="number">189</span>对应的结构体</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">usbdev_file_operations</span> = &#123;</span></span><br><span class="line">	.owner =	  THIS_MODULE,</span><br><span class="line">	.llseek =	  usbdev_lseek,</span><br><span class="line">	.read =		  usbdev_read,</span><br><span class="line">	.poll =		  usbdev_poll,</span><br><span class="line">	.unlocked_ioctl = usbdev_ioctl,</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">	.compat_ioctl =   usbdev_compat_ioctl,</span><br><span class="line">#endif</span><br><span class="line">	.open =		  usbdev_open,</span><br><span class="line">	.release =	  usbdev_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">usb_generic_driver结构体</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device_driver</span> <span class="title">usb_generic_driver</span> = &#123;</span></span><br><span class="line">	.name =	<span class="string">&quot;usb&quot;</span>,</span><br><span class="line">	.probe = generic_probe,</span><br><span class="line">	.disconnect = generic_disconnect,</span><br><span class="line">#ifdef	CONFIG_PM</span><br><span class="line">	.suspend = generic_suspend,</span><br><span class="line">	.resume = generic_resume,</span><br><span class="line">#endif</span><br><span class="line">	.supports_autosuspend = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在usb_init函数中调用 usb_hub_init 函数，我们重点分析 usb_hub_init 该函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">usb hub 驱动相关结构体</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">hub_driver</span> = &#123;</span></span><br><span class="line">	.name =		<span class="string">&quot;hub&quot;</span>,</span><br><span class="line">	.probe =	hub_probe,</span><br><span class="line">	.disconnect =	hub_disconnect,</span><br><span class="line">	.suspend =	hub_suspend,</span><br><span class="line">	.resume =	hub_resume,</span><br><span class="line">	.reset_resume =	hub_reset_resume,</span><br><span class="line">	.pre_reset =	hub_pre_reset,</span><br><span class="line">	.post_reset =	hub_post_reset,</span><br><span class="line">	.unlocked_ioctl = hub_ioctl,</span><br><span class="line">	.id_table =	hub_id_table,</span><br><span class="line">	.supports_autosuspend =	<span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usb_hub_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//注册hub_driver usb驱动</span></span><br><span class="line">	usb_register(&amp;hub_driver) </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//不使用系统workqueue，创建 hub_wq workqueue</span></span><br><span class="line">	hub_wq = alloc_workqueue(<span class="string">&quot;usb_hub_wq&quot;</span>, WQ_FREEZABLE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>总结:</p>
<ol>
<li>注册hub_driver usb驱动</li>
<li>新建 usb_hub_wq workqueue</li>
</ol>
<p>在usb2.0 spec上,规定了hub的设备class和接口class都为0x9.也就是代码中定义的USB_CLASS_HUB.<br>因为root hub内置在usb控制器中,所以当开机设备检测到root hub会根据idVendor找到hub_id_table，从而添加device.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_id</span> <span class="title">hub_id_table</span>[] = &#123;</span></span><br><span class="line">    &#123; .match_flags = USB_DEVICE_ID_MATCH_VENDOR</span><br><span class="line">			| USB_DEVICE_ID_MATCH_INT_CLASS,</span><br><span class="line">      .idVendor = USB_VENDOR_GENESYS_LOGIC,</span><br><span class="line">      .bInterfaceClass = USB_CLASS_HUB,</span><br><span class="line">      .driver_info = HUB_QUIRK_CHECK_PORT_AUTOSUSPEND&#125;,</span><br><span class="line">    &#123; .match_flags = USB_DEVICE_ID_MATCH_DEV_CLASS,</span><br><span class="line">      .bDeviceClass = USB_CLASS_HUB&#125;,</span><br><span class="line">    &#123; .match_flags = USB_DEVICE_ID_MATCH_INT_CLASS,</span><br><span class="line">      .bInterfaceClass = USB_CLASS_HUB&#125;,</span><br><span class="line">    &#123; &#125;						<span class="comment">/* Terminating entry */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>从 usb core 的角度，注册hub_driver usb驱动</li>
<li>从 dw3 的角度，添加了hub device设备。</li>
</ul>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h4 id="root-hub"><a href="#root-hub" class="headerlink" title="root hub"></a>root hub</h4><p>首先说明一下整个root hub的前置流程：</p>
<p>1.在usb core子系统初始化的时候会注册一个hub的驱动（hub_driver）和一个USB设备驱动（usb_generic_driver），</p>
<p>2.当root hub作为device注册到总线后首先会匹配到usb_generic_driver驱动，这时会调用usb_generic_driver中的probe函数，也就是generic_probe()函数，</p>
<p>3.在generic_probe()函数中会配置root hub，然后再分配USB接口设备，将USB接口设备注册到总线，此时才会匹配到hub_driver驱动，</p>
<p>4.然后调用hub_driver中的probe函数，也就是hub_probe()函数，在hub_probe()函数中会为hub的这个接口下的中断端点设置urb，并且会设置一个回调函数hub_irq()。</p>
<p>首先分析 hub_probe 函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hub_probe</span><span class="params">(struct usb_interface *intf, <span class="keyword">const</span> struct usb_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//初始化led指示灯work</span></span><br><span class="line">	INIT_DELAYED_WORK(&amp;hub-&gt;leds, led_work);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	INIT_DELAYED_WORK(&amp;hub-&gt;init_work, <span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化hub-&gt;events</span></span><br><span class="line">	INIT_WORK(&amp;hub-&gt;events, hub_event);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置hub</span></span><br><span class="line">	hub_configure(hub, endpoint)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>接下来是hub_configure函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hub_configure</span><span class="params">(struct usb_hub *hub,</span></span></span><br><span class="line"><span class="function"><span class="params">	struct usb_endpoint_descriptor *endpoint)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//取得hub描述符</span></span><br><span class="line">	get_hub_descriptor(hdev, hub-&gt;descriptor);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取描述hub特性的信息</span></span><br><span class="line">	wHubCharacteristics = le16_to_cpu(hub-&gt;descriptor-&gt;wHubCharacteristics);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* FIXME for USB 3.0, skip for now */</span></span><br><span class="line">	<span class="comment">//是否是一个复合设备</span></span><br><span class="line">	<span class="keyword">if</span> ((wHubCharacteristics &amp; HUB_CHAR_COMPOUND) &amp;&amp;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//电源开关模式</span></span><br><span class="line">	<span class="keyword">switch</span> (wHubCharacteristics &amp; HUB_CHAR_LPSM) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	  <span class="comment">//过电流保护模式</span></span><br><span class="line">	<span class="keyword">switch</span> (wHubCharacteristics &amp; HUB_CHAR_OCPM) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	INIT_LIST_HEAD(&amp;hub-&gt;tt.clear_list);</span><br><span class="line">	INIT_WORK(&amp;hub-&gt;tt.clear_work, hub_tt_work);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//根据设备描述符中bDeviceProtocol字段信息设置hub-&gt;tt</span></span><br><span class="line">	<span class="keyword">switch</span> (hdev-&gt;descriptor.bDeviceProtocol) &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Note 8 FS bit times == (8 bits / 12000000 bps) ~= 666ns */</span></span><br><span class="line">	<span class="comment">//设置usb-&gt;tt.think_time</span></span><br><span class="line">	<span class="keyword">switch</span> (wHubCharacteristics &amp; HUB_CHAR_TTTT) &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断是否支持指示</span></span><br><span class="line">	<span class="keyword">if</span> (wHubCharacteristics &amp; HUB_CHAR_PORTIND) &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获得hub的状态</span></span><br><span class="line">	usb_get_status(hdev, USB_RECIP_DEVICE, <span class="number">0</span>, &amp;hubstatus);</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//对hub的电源管理</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	hub_hub_status(hub, &amp;hubstatus, &amp;hubchange);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//分配一个urb</span></span><br><span class="line">	hub-&gt;urb = usb_alloc_urb(<span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//利用usb_fill_int_urb来初始化这个urb结构，包括hub的中断服务程序hub_irq的，查询的周期等</span></span><br><span class="line">	usb_fill_int_urb(hub-&gt;urb, hdev, pipe, *hub-&gt;buffer, maxp, hub_irq,</span><br><span class="line">		hub, endpoint-&gt;bInterval);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//激活hub</span></span><br><span class="line">	hub_activate(hub, HUB_INIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>总结：<br>1.获取hub相关信息及状态<br>2.利用函数usb_alloc_urb函数来分配一个urb<br>3.利用usb_fill_int_urb来初始化这个urb结构，包括hub的中断服务程序hub_irq的，查询的周期，每当有设备连接到USB接口时，USB总线在查询hub状态信息的时候会触发hub的中断服务程 hub_irq</p>
<p>我们接下分析该函数 hub_irq<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hub_irq</span><span class="params">(struct urb *urb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> status = urb-&gt;status;</span><br><span class="line">	<span class="keyword">switch</span> (status) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* let hub_wq handle things */</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:			<span class="comment">// 端口的状态发生了变化</span></span><br><span class="line">		bits = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; urb-&gt;actual_length; ++i)</span><br><span class="line">			bits |= ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) ((*hub-&gt;buffer)[i]))</span><br><span class="line">					&lt;&lt; (i*<span class="number">8</span>);</span><br><span class="line">		hub-&gt;event_bits[<span class="number">0</span>] = bits;<span class="comment">//保存状态改变的信息</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hub-&gt;nerrors = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Something happened, let hub_wq figure it out */</span></span><br><span class="line">	<span class="comment">//唤醒hub工作队列</span></span><br><span class="line">	kick_hub_wq(hub);</span><br><span class="line">	----&gt;queue_work(hub_wq, &amp;hub-&gt;events)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面开始分析hub_wq工作队列&amp;hub-&gt;events对应的函数hub_event<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hub_event</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* deal with port status changes */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= hdev-&gt;maxchild; i++) &#123;</span><br><span class="line">	</span><br><span class="line">			port_event(hub, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* deal with hub status changes */</span></span><br><span class="line">	<span class="comment">//处理一些hub的状态改变，如power变化或者过流.</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>总结：<br>hub_irq主要调用关系如下，主要核心函数为port_event<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hub_irq</span><br><span class="line">----&gt;kick_hub_wq(hub)</span><br><span class="line">	----&gt;queue_work(hub_wq, &amp;hub-&gt;events)</span><br><span class="line">		----&gt;hub_event</span><br><span class="line">			----&gt;port_event(hub, i)</span><br></pre></td></tr></table></figure></p>
<p>接下来分析port_event函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">port_event</span><span class="params">(struct usb_hub *hub, <span class="keyword">int</span> port1)</span></span></span><br><span class="line"><span class="function">		__<span class="title">must_hold</span><span class="params">(&amp;port_dev-&gt;status_lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//获取hub状态变化</span></span><br><span class="line">	hub_port_status(hub, port1, &amp;portstatus, &amp;portchange)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对相应的状态进行简单处理</span></span><br><span class="line">	<span class="keyword">if</span> (portchange &amp; USB_PORT_STAT_C_CONNECTION) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (portchange &amp; USB_PORT_STAT_C_ENABLE) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (portchange &amp; USB_PORT_STAT_C_OVERCURRENT) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (portchange &amp; USB_PORT_STAT_C_RESET) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((portchange &amp; USB_PORT_STAT_C_BH_RESET)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (portchange &amp; USB_PORT_STAT_C_LINK_STATE) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (portchange &amp; USB_PORT_STAT_C_CONFIG_ERROR) &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (connect_change)</span><br><span class="line">		hub_port_connect_change(hub, port1, portstatus, portchange);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> hub_port_connect_change(struct usb_hub *hub, <span class="keyword">int</span> port1,</span><br><span class="line">					u16 portstatus, u16 portchange)</span><br><span class="line">		__must_hold(&amp;port_dev-&gt;status_lock)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	hub_port_connect(hub, port1, portstatus, portchange);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> hub_port_connect(struct usb_hub *hub, <span class="keyword">int</span> port1, u16 portstatus,</span><br><span class="line">		u16 portchange)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//为探测到的usb设备（包括普通hub，u盘等）分配并初始化udev</span></span><br><span class="line">	usb_alloc_dev(hdev, hdev-&gt;bus, port1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对这个usb_dev结构进行一系的初始化,在这个函数中会处理:Get_Description,Set_address.等操作</span></span><br><span class="line">	hub_port_init(hub, udev, port1, i);</span><br><span class="line">	----&gt;hub_set_address<span class="comment">//把地址告诉usb设备</span></span><br><span class="line">	----&gt;usb_get_device_descriptor<span class="comment">//获取usb设备描述符</span></span><br><span class="line">	----&gt;usb_get_device_descriptor<span class="comment">//再获取一次usb设备描述符</span></span><br><span class="line">	</span><br><span class="line">	usb_new_device(udev);</span><br><span class="line">	---&gt;usb_enumerate_device(udev);<span class="comment">//读取所有的描述符并解析</span></span><br><span class="line">	---&gt;announce_device(udev);<span class="comment">/* Tell the world! */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * announce_device dmesg对应的相关日志如下:</span></span><br><span class="line"><span class="comment">	 * [  313.706377] usb 2-1: udev 2, busnum 2, minor = 129</span></span><br><span class="line"><span class="comment">	 * [  313.706391] usb 2-1: New USB device found, idVendor=0951, idProduct=1666, bcdDevice= 0.01</span></span><br><span class="line"><span class="comment">	 * [  313.706399] usb 2-1: New USB device strings: Mfr=1, Product=2, SerialNumber=3</span></span><br><span class="line"><span class="comment">	 * [  313.706407] usb 2-1: Product: DataTraveler 3.0</span></span><br><span class="line"><span class="comment">	 * [  313.706415] usb 2-1: Manufacturer: Kingston</span></span><br><span class="line"><span class="comment">	 * [  313.706431] usb 2-1: SerialNumber: 60A44C42539CF310971C3C75</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//把设备放入总线的dev链表，从总线的driver链表中取出driver一一比较,usb_interface和usb_driver的id_table比较,如果匹配上了，则调用对应driver的probe函数。</span></span><br><span class="line">	----&gt; device_add(&amp;udev-&gt;dev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>总结：<br>1.获取hub状态变化，对相应的状态进行简单处理<br>2.为探测到的usb设备（包括普通hub，u盘等）分配并初始化udev<br>3.对这个usb_dev结构进行一系的初始化,在这个函数中会处理:Get_Description,Set_address.等操作<br>4.读取并解析设备描述符，并且把设备放到总结的dev链表上<br>5.将usb设备注册到系统里，这个动作将触发驱动的匹配，由于这是个usb设备，所以万能usb驱动 usb_generic_driver 会匹配上，从而generic_probe会得到执行.关于usb_generic_driver的probe函数稍后分析。</p>
<p>先来看一下usb_device_match函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">usb_device_match</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* devices and interfaces are handled separately */</span></span><br><span class="line">	<span class="keyword">if</span> (is_usb_device(dev)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* interface drivers never match devices */</span></span><br><span class="line">		<span class="keyword">if</span> (!is_usb_device_driver(drv))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* <span class="doctag">TODO:</span> Add real matching code */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_usb_interface(dev)) &#123;</span><br><span class="line">		struct usb_interface *intf;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> *<span class="title">usb_drv</span>;</span></span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* device drivers never match interfaces */</span></span><br><span class="line">		<span class="keyword">if</span> (is_usb_device_driver(drv))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		intf = to_usb_interface(dev);</span><br><span class="line">		usb_drv = to_usb_driver(drv);</span><br><span class="line"></span><br><span class="line">		id = usb_match_id(intf, usb_drv-&gt;id_table);</span><br><span class="line">		<span class="keyword">if</span> (id)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		id = usb_match_dynamic_id(intf, usb_drv);</span><br><span class="line">		<span class="keyword">if</span> (id)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>总结：<br>该函数的流程一条给USB设备走，一条给USB接口走。<br>1.当设备插入，枚举完成后，调用该匹配函数走设备分支，匹配usb万能驱动usb_generic_driver,在其中选择，设置配置，构造一个新的interface设备。<br>2.添加interface设备到总线，调用该匹配函数，走interface分支，在其中根据枚举中获取的信息构造的usb_device_id结构体的内容与interface驱动中的.id_table匹配，成功后调用具体的interface驱动的probe函数.</p>
<p>root hub驱动总结：<br>a.主要函数调用关系：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hub_probe</span><br><span class="line">----&gt;hub_configure</span><br><span class="line">	----&gt;hub_irq</span><br><span class="line">		----&gt;hub_event</span><br><span class="line">			----&gt;port_event</span><br><span class="line">				----&gt;hub_port_connect_change</span><br><span class="line">					----&gt;hub_port_connect</span><br></pre></td></tr></table></figure>
<p>b.root hub初始化流程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1.</span>在usb子系统初始化的时候会注册一个hub的驱动（hub_driver）和一个USB设备驱动（usb_generic_driver），</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>当root hub的作为device注册到总线后首先会匹配到usb_generic_driver驱动，这时会调用usb_generic_driver中的probe函数，也就是 generic_probe()函数，</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>在generic_probe()函数中会配置root hub，然后再分配USB接口设备，将USB接口设备注册到总线，此时才会匹配到hub_driver驱动，</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>然后调用hub_driver中的probe函数，也就是hub_probe()函数，在hub_probe()函数中会为hub的这个接口下的中断端点设置urb，并且会设置一个回调函数hub_irq()。</span><br></pre></td></tr></table></figure></p>
<p>c.普通usb插入流程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">当有usb设备插入时，主机控制器检测到hub端口状态的变化，会执行hub_irq函数，然后按照上面的函数调用顺序一路往下执行，实现usb设备的识别过程：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>给新设备分配地址并将该地址告诉usb设备即设置usb地址</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>.获取设备描述符</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>读取所有的描述符并解析,向总线上添加usb设备,调用usb_bus_type.mach()，走 device 分支,万能usb驱动 usb_generic_driver 会匹配上,然后调用 generic_probe 函数</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>generic_probe中选择并设置配置，并利用描述符初始化一个新的interface设备，最后device_add添加接口设备，调用usb_bus_type.mach()，走interface分支，这个时候应该就根据id_table和自己写的设备驱动进行匹配操作了），然后调用对应的usb接口驱动的probe函数</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h4 id="usb-generic-driver"><a href="#usb-generic-driver" class="headerlink" title="usb generic driver"></a>usb generic driver</h4><p>当开机时检测到root hub或者后面插入usb设备时，检测到usb设备后，首先调用 usb_device_match 走device分支，导致generic_probe被调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">generic_probe</span><span class="params">(struct usb_device *udev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Choose and set the configuration.  This registers the interfaces</span></span><br><span class="line"><span class="comment">	 * with the driver core and lets interface drivers bind to them.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 选择配置 */</span></span><br><span class="line">	usb_choose_configuration(udev);</span><br><span class="line">	<span class="comment">/* 核心函数，设置配置 */</span></span><br><span class="line">	usb_set_configuration(udev, c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USB device state == configured ... usable */</span></span><br><span class="line">    usb_notify_add_device(udev);</span><br><span class="line">    	<span class="comment">//调用如下事件通知链来通知相关驱动，回调函数为 dwc3_msm_host_notifier.</span></span><br><span class="line">    ---&gt;blocking_notifier_call_chain(&amp;usb_notifier_list, USB_DEVICE_ADD, udev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usb_set_configuration</span><span class="params">(struct usb_device *dev, <span class="keyword">int</span> configuration)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_host_config</span> *<span class="title">cp</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_interface</span> **<span class="title">new_interfaces</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_hcd</span> *<span class="title">hcd</span> = <span class="title">bus_to_hcd</span>(<span class="title">dev</span>-&gt;<span class="title">bus</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 申请指针数组的内存 */</span></span><br><span class="line">	new_interfaces = kmalloc_array(nintf, <span class="keyword">sizeof</span>(*new_interfaces),</span><br><span class="line">							GFP_NOIO);</span><br><span class="line">	<span class="comment">/* 申请每一项new_interfaces[n]的内存 */</span></span><br><span class="line">	new_interfaces[n] = kzalloc(<span class="keyword">sizeof</span>(struct usb_interface), </span><br><span class="line">							GFP_NOIO);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Wake up the device so we can send it the Set-Config request */</span></span><br><span class="line">	ret = usb_autoresume_device(dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if it&#x27;s already configured, clear out old state first.</span></span><br><span class="line"><span class="comment">	 * getting rid of old interfaces means unbinding their drivers.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;state != USB_STATE_ADDRESS)</span><br><span class="line">		usb_disable_device(dev, <span class="number">1</span>);	<span class="comment">/* Skip ep0 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure we have bandwidth (and available HCD resources) for this configuration. */</span></span><br><span class="line">	ret = usb_hcd_alloc_bandwidth(dev, cp, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Initialize the new interface structures and the</span></span><br><span class="line"><span class="comment">	 * hc/hcd/usbcore interface/endpoint state.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nintf; ++i) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">usb_interface_cache</span> *<span class="title">intfc</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">usb_interface</span> *<span class="title">intf</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">usb_host_interface</span> *<span class="title">alt</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 获得这个接口为0号设置,接口的默认设置总是0号设置 */</span></span><br><span class="line">		alt = usb_altnum_to_altsetting(intf, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Enable all the endpoints for an interface */</span></span><br><span class="line">		usb_enable_interface(dev, intf, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * usb_bus_type 结构体变量如下，后续会通过device_add添加intface导致</span></span><br><span class="line"><span class="comment">		 * match函数调用，继而走interface这条路.</span></span><br><span class="line"><span class="comment">		 * struct bus_type usb_bus_type = &#123;</span></span><br><span class="line"><span class="comment">		 * .name =		&quot;usb&quot;,</span></span><br><span class="line"><span class="comment">		 * .match =	usb_device_match,</span></span><br><span class="line"><span class="comment">		 * .uevent =	usb_uevent,</span></span><br><span class="line"><span class="comment">		 * .need_parent_lock =	true,</span></span><br><span class="line"><span class="comment">		 * &#125;;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		intf-&gt;dev.driver = <span class="literal">NULL</span>;</span><br><span class="line">		intf-&gt;dev.bus = &amp;usb_bus_type;</span><br><span class="line">		intf-&gt;dev.type = &amp;usb_if_device_type;</span><br><span class="line">		intf-&gt;dev.groups = usb_interface_groups;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Please refer to usb_alloc_dev() to see why we set</span></span><br><span class="line"><span class="comment">		 * dma_mask and dma_pfn_offset.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">/* init device structure. */</span></span><br><span class="line">		device_initialize(&amp;intf-&gt;dev);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* increments the reference count of the usb device structure */</span></span><br><span class="line">		usb_get_dev(dev);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 发送配置请求 */</span></span><br><span class="line">	usb_control_msg(dev, usb_sndctrlpipe(dev, <span class="number">0</span>),</span><br><span class="line">			      USB_REQ_SET_CONFIGURATION, <span class="number">0</span>, configuration, <span class="number">0</span>,</span><br><span class="line">			      <span class="literal">NULL</span>, <span class="number">0</span>, USB_CTRL_SET_TIMEOUT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置设备的状态为configured */</span></span><br><span class="line">	usb_set_device_state(dev, USB_STATE_CONFIGURED);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Now that all the interfaces are set up, register them</span></span><br><span class="line"><span class="comment">	 * to trigger binding of drivers to interfaces.  probe()</span></span><br><span class="line"><span class="comment">	 * routines may install different altsettings and may</span></span><br><span class="line"><span class="comment">	 * claim() any interfaces not yet bound.  Many class drivers</span></span><br><span class="line"><span class="comment">	 * need that: CDC, audio, video, etc.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	 <span class="comment">/*</span></span><br><span class="line"><span class="comment">	  * 将接口所对应的设备添加到系统，此动作将引发接口设备和接口驱动匹配，</span></span><br><span class="line"><span class="comment">	  * 从而引发接口设备驱动对应的probe函数</span></span><br><span class="line"><span class="comment">	  */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nintf; ++i) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">usb_interface</span> *<span class="title">intf</span> = <span class="title">cp</span>-&gt;<span class="title">interface</span>[<span class="title">i</span>];</span></span><br><span class="line">		<span class="comment">/* interface匹配，导致usb_device_match再次被调用，走interface这一路 */</span></span><br><span class="line">		ret = device_add(&amp;intf-&gt;dev);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Interface driver 和device匹配，从而usb_device_match再次被调用，走interface这一路<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">usb_device_match</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* devices and interfaces are handled separately */</span></span><br><span class="line">	<span class="keyword">if</span> (is_usb_device(dev)) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_usb_interface(dev)) &#123;</span><br><span class="line">		struct usb_interface *intf;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> *<span class="title">usb_drv</span>;</span></span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* device drivers never match interfaces */</span></span><br><span class="line">		<span class="keyword">if</span> (is_usb_device_driver(drv))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">/* 首先找到对应的usb_interface 和 usb_driver结构体 */</span></span><br><span class="line">		intf = to_usb_interface(dev);</span><br><span class="line">		usb_drv = to_usb_driver(drv);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* find first usb_device_id matching device or interface */</span></span><br><span class="line">        <span class="comment">/* 这里是查找在usb驱动通过 MODULE_DEVICE_TABLE 来注册的 usb_device_id*/</span></span><br><span class="line">		id = usb_match_id(intf, usb_drv-&gt;id_table);</span><br><span class="line">		---&gt;usb_match_one_id(interface, id)<span class="comment">/* 匹配核心函数 */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 如果在 usb_device_id 中没有找到，则在动态id链表dynids里查找*/</span></span><br><span class="line">		id = usb_match_dynamic_id(intf, usb_drv);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usb_match_one_id</span><span class="params">(struct usb_interface *interface,</span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="keyword">const</span> struct usb_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_host_interface</span> *<span class="title">intf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 获取对应的usb_host_interface和usb_device结构体 */</span></span><br><span class="line">	intf = interface-&gt;cur_altsetting;</span><br><span class="line">	dev = interface_to_usbdev(interface);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 查看设备描述符中的如下数据是否与 usb_device_id 中的数据匹配：</span></span><br><span class="line"><span class="comment">	 * idVendor，idProduct，bcdDevice，bDeviceClass，bDeviceSubClass，bDeviceProtocol</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	usb_match_device(dev, id);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 查看接口描述符中的如下数据是否与usb_device_id 中的数据匹配：</span></span><br><span class="line"><span class="comment">	 * bInterfaceClass，bInterfaceSubClass，bInterfaceProtocol，bInterfaceNumber</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	usb_match_one_id_intf(dev, intf, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当匹配到对应的 usb_device_id 时，最终导致接口的probe函数被调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">usb_probe_interface</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> *<span class="title">driver</span> = <span class="title">to_usb_driver</span>(<span class="title">dev</span>-&gt;<span class="title">driver</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_interface</span> *<span class="title">intf</span> = <span class="title">to_usb_interface</span>(<span class="title">dev</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">udev</span> = <span class="title">interface_to_usbdev</span>(<span class="title">intf</span>);</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 再次确认接口与驱动的匹配情况 */</span></span><br><span class="line">	usb_match_dynamic_id(intf, driver);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 设置状态 */</span></span><br><span class="line">	intf-&gt;condition = USB_INTERFACE_BINDING;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 设置当前接口 */</span></span><br><span class="line">	usb_set_interface(udev, intf-&gt;altsetting[<span class="number">0</span>].desc.bInterfaceNumber, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* 调用具体驱动的probe函数 */</span></span><br><span class="line">	driver-&gt;probe(intf, id);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里终于调到最终的具体驱动的probe函数了。</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h4 id="usb-skeleton-driver"><a href="#usb-skeleton-driver" class="headerlink" title="usb-skeleton  driver"></a>usb-skeleton  driver</h4><p>“./drivers/usb/usb-skeleton.c”是内核提供给usb设备驱动开发者的大容量存储usb设备的模板程序，我们简单分析该驱动的probe函数即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">skel_probe</span><span class="params">(struct usb_interface *interface,</span></span></span><br><span class="line"><span class="function"><span class="params">		      <span class="keyword">const</span> struct usb_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_skel</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_endpoint_descriptor</span> *<span class="title">bulk_in</span>, *<span class="title">bulk_out</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* allocate memory for our device state and initialize it */</span></span><br><span class="line">	dev = kzalloc(<span class="keyword">sizeof</span>(*dev), GFP_KERNEL);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 获取usb device 和 usb interface结构体 */</span></span><br><span class="line">	dev-&gt;udev = usb_get_dev(interface_to_usbdev(interface));</span><br><span class="line">	dev-&gt;interface = usb_get_intf(interface);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* set up the endpoint information */</span></span><br><span class="line">	<span class="comment">/* use only the first bulk-in and bulk-out endpoints */</span></span><br><span class="line">	retval = usb_find_common_endpoints(interface-&gt;cur_altsetting,</span><br><span class="line">			&amp;bulk_in, &amp;bulk_out, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 获取 bulk_in 端点的相关信息并赋值给dev相关结构体 */</span></span><br><span class="line">	dev-&gt;bulk_in_size = usb_endpoint_maxp(bulk_in);</span><br><span class="line">	dev-&gt;bulk_in_endpointAddr = bulk_in-&gt;bEndpointAddress;</span><br><span class="line">	dev-&gt;bulk_in_buffer = kmalloc(dev-&gt;bulk_in_size, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 给bulk_in申请分配一个urb*/</span></span><br><span class="line">	dev-&gt;bulk_in_urb = usb_alloc_urb(<span class="number">0</span>, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 获取 bulk_out 端点的相关信息*/</span></span><br><span class="line">	dev-&gt;bulk_out_endpointAddr = bulk_out-&gt;bEndpointAddress;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* save our data pointer in this interface device */</span></span><br><span class="line">	usb_set_intfdata(interface, dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we can register the device now, as it is ready */</span></span><br><span class="line">	retval = usb_register_dev(interface, &amp;skel_class);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>首先利用探测函数 usb_find_common_endpoints 来搜索到当前接口的第一个 bulk_in 和 buld_out 端点。</li>
<li>申请usb请求块urb，urb的处理全流程如下<ul>
<li>使用usb_alloc_urb来创建urb。</li>
<li>填充urb（中断端点：usb_fill_int_urb，批量端点：usb_fill_bulk_urb，控制端点：usb_fill_control_urb）。</li>
<li>在USB设备驱动中的 read/write 操作中，使用usb_submit_urb()把urb提交给USB core。</li>
<li>USB core 把urb传递给 USB Host controller。</li>
<li>USB Host controller 对 urb进行处理，进行一次到USB设备的数据传递。</li>
<li>当urb传递完成后，调用urb的回调函数，将urb控制权重新交给USB设备驱动程序。</li>
</ul>
</li>
<li>注册usb设备，后续在 read/write 函数中利用urb来传递数据。</li>
</ol>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<p>以上就是USB HOST的基础流程，大体框图如下：<br><img src="/2021/03/20/Android-USB-Framework-Architecture/USB_FLOW.jpg" alt="USB_FLOW"></p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="USB-Device"><a href="#USB-Device" class="headerlink" title="USB Device"></a>USB Device</h3><h4 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h4><p>USB设备控制器（UDC）驱动指的是，当Android USB设备最为device时，插入其他USB主机控制器时，自身作为从设备而运行在底层硬件控制器的驱动。例如，当Android手机连接PC最为MTP功能时，Android 设备作为USB设备控制器的功能，这时运行在底层的是UDC驱动，在UDC驱动之上需要另外一个驱动，作为上层应用的接口，这个驱动为File Storage驱动，称为Function驱动。</p>
<p>简略框图参见如下右侧：<br><img src="/2021/03/20/Android-USB-Framework-Architecture/Android_USB_Framework_Architecture_Device.jpg" alt="Android_USB_Framework_Architecture_Device"></p>
<p>Android USB作为device时，引入gadget概念。Android USB Gadget软件架构分为3层：(Composite Framework和USB Gadget Interface为Gadget设备层)</p>
<ul>
<li><p>USB 功能驱动层:  最主要的结构是struct usb_composite_driver，这个结构在这层定义，并且实现结构中的各个函数。</p>
</li>
<li><p>Composite Framework 层:  最主要的数据结构是 struct usb_composite_dev 与 usb_gadget_driver。前一个代表一个USB复合设备，而后一个是Gadget驱动，与UDC层交互。</p>
</li>
<li><p>USB Gadget Interface层: 功能层的功能接口(interface)，主要对应USB协议，提供统一的APIGadget Function驱动，同时和UDC进行交互，和硬件无关。</p>
</li>
<li><p>UDC层:  最主要的数据结构是struct usb_gadget，通常包含在其他结构体中。这个结构体代表了一个USB设备控制器的所有关于USB通信的信息。该层和平台硬件相关。</p>
</li>
</ul>
<p>USB Host是从 HCD —-&gt; USB Core —-&gt; USB设备驱动 自下而上的进行代码分析，我们这里对USB Device进行源码分析时，选择  USB功能驱动层 和 Gaget 设备层 —-&gt; UDC的方向进行分析。（以Mass storage为例进行源码分析）</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h4 id="代码路径-1"><a href="#代码路径-1" class="headerlink" title="代码路径"></a>代码路径</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>msm-4.19/drivers/usb/gadget/function/f_mass_storage.c</td>
</tr>
<tr>
<td></td>
<td>kernel/msm-4.19/drivers/usb/gadget/legacy/mass_storage.c</td>
</tr>
<tr>
<td></td>
<td>kernel/msm-4.19/drivers/usb/gadget/composite.c</td>
</tr>
<tr>
<td></td>
<td>kernel/msm-4.19/drivers/usb/gadget/udc/core.c</td>
</tr>
</tbody>
</table>
</div>
<h4 id="核心结构体-1"><a href="#核心结构体-1" class="headerlink" title="核心结构体"></a>核心结构体</h4><ol>
<li><p>mass storage 结构体</p>
<ul>
<li>struct fsg_dev 代表mass storage 设备</li>
<li>fsg_common 代码mass storage设备中共同结构体</li>
</ul>
</li>
<li><p>核心结构体</p>
<ul>
<li>struct usb_composite_dev  代表一个复合的usb gadget设备，一般嵌入到具体的设备自定义结构体中，这里嵌入到 fsg_common中</li>
<li>usb_composite_driver 代表复合设备绑定的驱动</li>
<li>struct usb_udc 代表一个usb device controller</li>
<li>struct usb_gadget 代表一个usb从设备</li>
<li>struct usb_gadget_driver 代表 usb 从设备对应的驱动。</li>
<li>usb_function_driver 代表 usb function功能对应的驱动</li>
<li>usb_function_instance 代表 usb function功能对应的实例</li>
<li>usb_configuration 代表一个gadget设备的配置</li>
<li>usb_function 代表配置中的一个function</li>
</ul>
</li>
</ol>
<p>核心结构体对应的关系如下：<br><img src="/2021/03/20/Android-USB-Framework-Architecture/UDC_STRUCT.bmp" alt="usb device controller struct"></p>
<h4 id="USB-功能驱动层-amp-Gaget-设备层"><a href="#USB-功能驱动层-amp-Gaget-设备层" class="headerlink" title="USB 功能驱动层 &amp; Gaget 设备层"></a>USB 功能驱动层 &amp; Gaget 设备层</h4><ul>
<li><p>function 入口函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** msm-4.19/drivers/usb/gadget/function/f_mass_storage.c **/</span></span><br><span class="line"></span><br><span class="line">DECLARE_USB_FUNCTION_INIT(mass_storage, fsg_alloc_inst, fsg_alloc);</span><br><span class="line">宏定义为：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_USB_FUNCTION_INIT(_name, _inst_alloc, _func_alloc)</span></span><br></pre></td></tr></table></figure>
<p>展开该宏定义:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_function_driver</span> <span class="title">mass_storageusb_func</span> = &#123;</span></span><br><span class="line">	.name = __stringify(mass_storage),</span><br><span class="line">	.mod  = THIS_MODULE,</span><br><span class="line">	.alloc_inst = _inst_alloc,</span><br><span class="line">	.alloc_func = _func_alloc,</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_ALIAS(<span class="string">&quot;usbfunc:&quot;</span>__stringify(mass_storage));</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">mass_storagemod_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> usb_function_register(&amp;mass_storageusb_func);</span><br><span class="line">	<span class="comment">//添加 mass_storageusb_func 到 func_list中</span></span><br><span class="line">	---&gt;list_add_tail(&amp;newf-&gt;<span class="built_in">list</span>, &amp;func_list);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">mass_storagemod_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	usb_function_unregister(&amp;mass_storageusb_func);</span><br><span class="line">&#125;</span><br><span class="line">module_init(mass_storagemod_init);</span><br><span class="line">module_exit(mass_storagemod_exit);</span><br></pre></td></tr></table></figure>
<p>从如上展开的宏定义可以看出，该宏主要作用为调用 usb_function_register 来注册 mass_storageusb_func function。<br>可以看出，这里主要是添加上层的各个usb_function_driver 到 func_list 中。</p>
</li>
<li><p>legacy 入口函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** kernel/msm-4.19/drivers/usb/gadget/legacy/mass_storage.c **/</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_composite_driver</span> <span class="title">msg_driver</span> = &#123;</span></span><br><span class="line">	.name		= <span class="string">&quot;g_mass_storage&quot;</span>,</span><br><span class="line">	.dev		= &amp;msg_device_desc,</span><br><span class="line">	.max_speed	= USB_SPEED_SUPER_PLUS,</span><br><span class="line">	.needs_serial	= <span class="number">1</span>,</span><br><span class="line">	.strings	= dev_strings,</span><br><span class="line">	.bind		= msg_bind,</span><br><span class="line">	.unbind		= msg_unbind,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">msg_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> usb_composite_probe(&amp;msg_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是利用 usb_composite_probe注册一个 name 为 g_mass_storage 的复合驱动，我们接下来重点分析具体操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * usb_composite_probe() - register a composite driver</span></span><br><span class="line"><span class="comment"> * @driver: the driver to register</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Context: single threaded during gadget setup</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is used to register drivers using the composite driver</span></span><br><span class="line"><span class="comment"> * framework.  The return value is zero, or a negative errno value.</span></span><br><span class="line"><span class="comment"> * Those values normally come from the driver&#x27;s @bind method, which does</span></span><br><span class="line"><span class="comment"> * all the work of setting up the driver to match the hardware.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On successful return, the gadget is ready to respond to requests from</span></span><br><span class="line"><span class="comment"> * the host, unless one of its components invokes usb_gadget_disconnect()</span></span><br><span class="line"><span class="comment"> * while it was binding.  That would usually be done in order to wait for</span></span><br><span class="line"><span class="comment"> * some userspace participation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/** kernel/msm-4.19/drivers/usb/gadget/composite.c **/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usb_composite_probe</span><span class="params">(struct usb_composite_driver *driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_gadget_driver</span> *<span class="title">gadget_driver</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * 把模板赋值给该usb_composite_driver的gadget_driver成员变量   </span></span><br><span class="line"><span class="comment">	 * 然后填充 gadget_driver 变量，最后通过 usb_gadget_probe_driver 注册该结构体</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	driver-&gt;gadget_driver = composite_driver_template;</span><br><span class="line">	gadget_driver = &amp;driver-&gt;gadget_driver;</span><br><span class="line"></span><br><span class="line">	gadget_driver-&gt;function =  (<span class="keyword">char</span> *) driver-&gt;name;</span><br><span class="line">	gadget_driver-&gt;driver.name = driver-&gt;name;</span><br><span class="line">	gadget_driver-&gt;max_speed = driver-&gt;max_speed;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> usb_gadget_probe_driver(gadget_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** kernel/msm-4.19/drivers/usb/gadget/udc/core.c **/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usb_gadget_probe_driver</span><span class="params">(struct usb_gadget_driver *driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_udc</span>		*<span class="title">udc</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="comment">/* 这里涉及到udc_list，其实就是框图中的UDC(这里为DW3 usb device controller)，后面在UDC章节分析*/</span></span><br><span class="line">	list_for_each_entry(udc, &amp;udc_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="comment">/* For now we take the first one */</span></span><br><span class="line">		<span class="keyword">if</span> (!udc-&gt;driver)</span><br><span class="line">			<span class="keyword">goto</span> found;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 如果在上面没有找到UDC，添加 usb_gadget_driver-&gt;pending 到 gadget_driver_pending_list 中 */</span></span><br><span class="line">	<span class="keyword">if</span> (!driver-&gt;match_existing_only) &#123;</span><br><span class="line">		list_add_tail(&amp;driver-&gt;pending, &amp;gadget_driver_pending_list);</span><br><span class="line">		pr_info(<span class="string">&quot;udc-core: couldn&#x27;t find an available UDC - added [%s] to list of pending drivers\n&quot;</span>,</span><br><span class="line">			driver-&gt;function);</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	 udc_bind_to_driver(udc, driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
</li>
</ul>
<ol>
<li>首先构造 usb_gadget_driver 结构体.</li>
<li>遍历udc_list，寻找udc 设备，高通平台对应dwc3 usb device  controller .</li>
<li>如果没有找到UDC，把 该 usb_gadget_driver 私有数据 pending 添加到 gadget_driver_pending_list 中</li>
<li>利用 udc_bind_to_driver 函数把 usb_gadget_driver（即msg_driver-&gt;gadget_driver） 与对应的 usb_udc（即dw3 usb device controller） 进行绑定。</li>
</ol>
<p>接下来对 udc_bind_to_driver 进行分析<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** kernel/msm-4.19/drivers/usb/gadget/udc/core.c **/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">udc_bind_to_driver</span><span class="params">(struct usb_udc *udc, struct usb_gadget_driver *driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 注册UDC driver g_mass_storage*/</span></span><br><span class="line">	dev_dbg(&amp;udc-&gt;dev, <span class="string">&quot;registering UDC driver [%s]\n&quot;</span>,</span><br><span class="line">			driver-&gt;function);</span><br><span class="line">	<span class="comment">/* 关联 usb_udc 和 usb_gadget_driver */</span></span><br><span class="line">	udc-&gt;driver = driver;</span><br><span class="line">	udc-&gt;dev.driver = &amp;driver-&gt;driver;</span><br><span class="line">	udc-&gt;gadget-&gt;dev.driver = &amp;driver-&gt;driver;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 当前驱动支持的最大速度 */</span></span><br><span class="line">	usb_gadget_udc_set_speed(udc, driver-&gt;max_speed);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 前面构造 usb_gadget_driver 时，</span></span><br><span class="line"><span class="comment">	 * 把 composite_driver_template 结构体赋值给 usb_gadget_driver</span></span><br><span class="line"><span class="comment">	 * 所以这里对应的bind为 composite_bind</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	driver-&gt;bind(udc-&gt;gadget, driver);</span><br><span class="line">		---&gt; composite_bind</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * 通知UDC开始启动</span></span><br><span class="line"><span class="comment">	 * 最终调用kernel/msm-4.19/drivers/usb/dwc3/gadget.c</span></span><br><span class="line"><span class="comment">	 * .udc_start		= dwc3_gadget_start,</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	usb_gadget_udc_start(udc);</span><br><span class="line">	---&gt; udc-&gt;gadget-&gt;ops-&gt;udc_start(udc-&gt;gadget, udc-&gt;driver);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * software-controlled connect to USB host</span></span><br><span class="line"><span class="comment">	 *  主要动作为使能 D+/D- 上拉，host接受到该信息后会开始进行枚举动作</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	usb_udc_connect_control(udc);</span><br><span class="line">		---&gt; usb_gadget_connect(udc-&gt;gadget);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 发送uevent事件 */</span></span><br><span class="line">	kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_CHANGE);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>总结：</p>
<ol>
<li>把 usb_udc 和 usb_gadget_driver 通过成员变量关联起来</li>
<li>设置驱动支持的最大的速度</li>
<li>第一次调用模板 composite_driver_template 的成员变量 bind —-&gt; composite_bind</li>
<li>使能 D+/D- 上拉，host接受到该信息后会开始进行枚举动作</li>
<li>发生 usb change uevent 事件</li>
</ol>
<p>接下来分析上面的核心函数 composite_bind</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** kernel/msm-4.19/drivers/usb/gadget/composite.c **/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">composite_bind</span><span class="params">(struct usb_gadget *gadget,</span></span></span><br><span class="line"><span class="function"><span class="params">		struct usb_gadget_driver *gdriver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_composite_dev</span>	*<span class="title">cdev</span>;</span></span><br><span class="line">	<span class="comment">/* 获取到 msg_driver 结构体*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_composite_driver</span>	*<span class="title">composite</span> = <span class="title">to_cdriver</span>(<span class="title">gdriver</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*初始化 confis 和gstrings 2个list*/</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;cdev-&gt;configs);</span><br><span class="line">	INIT_LIST_HEAD(&amp;cdev-&gt;gstrings);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置 usb_composite_dev	*cdev ，做一些准备动作*/</span></span><br><span class="line">	composite_dev_prepare(composite, cdev);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* composite gadget needs to assign strings for whole device (like</span></span><br><span class="line"><span class="comment">	 * serial number), register function drivers, potentially update</span></span><br><span class="line"><span class="comment">	 * power state and consumption, etc</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里调取 usb_composite_driver msg_driver中的bind函数.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	composite-&gt;bind(cdev);</span><br><span class="line">	---&gt; .bind		= msg_bind,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新设备描述符 */</span></span><br><span class="line">	update_unchanged_dev_desc(&amp;cdev-&gt;desc, composite-&gt;dev);</span><br><span class="line"></span><br><span class="line">	INFO(cdev, <span class="string">&quot;%s ready\n&quot;</span>, composite-&gt;name);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板bind函数，主要作用为调用上层对应的 usb_composite_driver 结构体的bind —-&gt; msg_bind，这里又回到 legacy 入口函数时，注册的 msg_driver的bind成员变量 —-&gt; msg_bind。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** kernel/msm-4.19/drivers/usb/gadget/legacy/mass_storage.c **/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">msg_bind</span><span class="params">(struct usb_composite_dev *cdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fsg_opts</span> *<span class="title">opts</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fsg_config</span> <span class="title">config</span>;</span></span><br><span class="line">	<span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">	fi_msg = usb_get_function_instance(<span class="string">&quot;mass_storage&quot;</span>);</span><br><span class="line">	<span class="comment">/* 请求安装 mass_storge kernel module ko */</span></span><br><span class="line">	---&gt; request_module(<span class="string">&quot;usbfunc:%s&quot;</span>, name);</span><br><span class="line">	---&gt; try_get_usb_function_instance(name);</span><br><span class="line">		<span class="comment">/* 调用 mass_storageusb_func.alloc_inst 来分配实例，</span></span><br><span class="line"><span class="comment">		/* 这里主要和mass storage相关，不具体分析*/</span></span><br><span class="line">		---&gt; fsg_alloc_inst</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 配置一些 mass storage的一些基础参数 */</span></span><br><span class="line">	fsg_config_from_params(&amp;config, &amp;mod_data, fsg_num_buffers);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 获取到 fsg_opts */</span></span><br><span class="line">	opts = fsg_opts_from_func_inst(fi_msg);</span><br><span class="line"></span><br><span class="line">	opts-&gt;no_configfs = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置一些mass storage专用的配置 */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 判断是否为OTG，如果是，对OTG设备描述符进行一些操作 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 为 dev 添加绑定一个 config */</span></span><br><span class="line">	usb_add_config(cdev, &amp;msg_config_driver, msg_do_config);</span><br><span class="line">	---&gt; usb_add_config_only(cdev, config);</span><br><span class="line">    ---&gt; bind(config);</span><br><span class="line">		---&gt; msg_do_config</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>获取 mass_storage function实例</li>
<li>设置一些mass storage的配置</li>
<li>判断是否为OTG设备，进行一些操作</li>
<li>为 dev 添加绑定一个 config，最终调用 msg_do_config 来实现</li>
</ol>
<p>接下来分析 msg_do_config<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">msg_do_config</span><span class="params">(struct usb_configuration *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * 根据name，遍历func_list中name为 mass_storage 的 function</span></span><br><span class="line"><span class="comment">	 * 在kernel/msm-4.19/drivers/usb/gadget/function/f_mass_storage.c中</span></span><br><span class="line"><span class="comment">	 * 我们有通过宏 DECLARE_USB_FUNCTION_INIT 来注册一个name为mass_storage的usb_function_driver，</span></span><br><span class="line"><span class="comment">	 * 即添加 mass_storageusb_func 到 func_list中</span></span><br><span class="line"><span class="comment">	 **/</span></span><br><span class="line">	f_msg = usb_get_function(fi_msg);</span><br><span class="line">	---&gt; fi_msg-&gt;fd-&gt;alloc_func(fi_msg);</span><br><span class="line">		<span class="comment">/* 构建fsg_dev *fsg </span></span><br><span class="line"><span class="comment">		 * fsg-&gt;function.name	= FSG_DRIVER_DESC;</span></span><br><span class="line"><span class="comment">		 * fsg-&gt;function.bind	= fsg_bind;</span></span><br><span class="line"><span class="comment">		 * fsg-&gt;function.unbind	= fsg_unbind;</span></span><br><span class="line"><span class="comment">		 * fsg-&gt;function.setup	= fsg_setup;</span></span><br><span class="line"><span class="comment">		 * fsg-&gt;function.set_alt	= fsg_set_alt;</span></span><br><span class="line"><span class="comment">		 * fsg-&gt;function.disable	= fsg_disable;</span></span><br><span class="line"><span class="comment">		 * fsg-&gt;function.free_func	= fsg_free;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		---&gt;fsg_alloc</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 为 config 添加一个function ---&gt; mass_storageusb_func */</span></span><br><span class="line">	usb_add_function(c, f_msg);</span><br><span class="line">	---&gt; f_msg-&gt;bind(config, function);</span><br><span class="line">		---&gt;fsg_bind</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>总结：</p>
<ol>
<li>遍历 func_list 中 name 为 mass_storage 的 function</li>
<li>构造一个fsg_dev，对其成员变量 function 进行赋值操作</li>
<li>为该 usb config 添加绑定如上 function，最终调用 fsg_bind 进行绑定操作。</li>
</ol>
<p>接下来看 fsg_bind 函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fsg_bind</span><span class="params">(struct usb_configuration *c, struct usb_function *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fsg_dev</span>		*<span class="title">fsg</span> = <span class="title">fsg_from_func</span>(<span class="title">f</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fsg_common</span>	*<span class="title">common</span> = <span class="title">fsg</span>-&gt;<span class="title">common</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_gadget</span>	*<span class="title">gadget</span> = <span class="title">c</span>-&gt;<span class="title">cdev</span>-&gt;<span class="title">gadget</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_ep</span>		*<span class="title">ep</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fsg_opts</span>		*<span class="title">opts</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Don&#x27;t allow to bind if we don&#x27;t have at least one LUN */</span></span><br><span class="line">	ret = _fsg_common_get_max_lun(common);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建 &quot;file-storage&quot; thread，并启动，这里主要和mass storage相关，不具体分析*/</span></span><br><span class="line">    common-&gt;thread_task =kthread_create(fsg_main_thread, common, <span class="string">&quot;file-storage&quot;</span>);</span><br><span class="line">    wake_up_process(common-&gt;thread_task);</span><br><span class="line">msg_bind</span><br><span class="line">	<span class="comment">/* New interface */</span></span><br><span class="line">	i = usb_interface_id(c, f);</span><br><span class="line"></span><br><span class="line">	fsg_intf_desc.bInterfaceNumber = i;</span><br><span class="line">	fsg-&gt;interface_number = i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Find all the endpoints we will use */</span></span><br><span class="line">	ep = usb_ep_autoconfig(gadget, &amp;fsg_fs_bulk_in_desc);</span><br><span class="line">	fsg-&gt;bulk_in = ep;</span><br><span class="line"></span><br><span class="line">	ep = usb_ep_autoconfig(gadget, &amp;fsg_fs_bulk_out_desc);</span><br><span class="line">	fsg-&gt;bulk_out = ep;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 根据不同的usb速度分配usb interface 和 usb endpoint描述符 */</span></span><br><span class="line">	usb_assign_descriptors(f, fsg_fs_function, fsg_hs_function,</span><br><span class="line">			fsg_ss_function, fsg_ss_function);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>mass storage最终的bind函数主要做了如下事情 ：</p>
<ol>
<li>创建并运行 file-storage 子进程</li>
<li>构建interface和endpoint，并分配他们的描述符</li>
</ol>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<p>总结：<br>USB 功能驱动层 &amp; Gaget 设备层的关系比较紧密，存在很多回调函数，下图只是列出了简单的调用关系图:<br><img src="/2021/03/20/Android-USB-Framework-Architecture/USB_Gadget_Framework.jpg" alt="USB Gadget Framework"></p>
<p>另外从上面的代码流程可以看出，mass storage一共经历了4次 bind 函数，最终实现mass storage功能。</p>
<ul>
<li><p>struct usb_gadget_driver composite_driver_template 对应的 composite_bind，所有 gadget 驱动都走这个公共函数。</p>
</li>
<li><p>struct usb_composite_driver msg_driver 对应的 msg_bind，这里回调到 上层 legacy/mass_storage.c 的mass storage的驱动。</p>
</li>
<li><p>usb_add_config 中，回调 msg_do_config，来给 dev 绑定一个 configuration</p>
</li>
<li><p>usb_add_function中，回调到 function/f_mass_storage.c 中 struct usb_function_driver mass_storageusb_func-&gt;ubs_function-&gt;bind 函数</p>
</li>
</ul>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h4 id="UDC"><a href="#UDC" class="headerlink" title="UDC"></a>UDC</h4><p>在Android USB作为Host的代码流程 dwc3_probe 函数中：<br>如果dts中dr_mode = otg 或者 peripheral，调用 dwc3_gadget_init 来初始化gadget相关的寄存器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dwc3_gadget_init - Initializes gadget related registers</span></span><br><span class="line"><span class="comment"> * @dwc: pointer to our controller context structure</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 0 on success otherwise negative errno.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dwc3_gadget_init</span><span class="params">(struct dwc3 *dwc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dwc-&gt;gadget.ops			= &amp;dwc3_gadget_ops;</span><br><span class="line">	dwc-&gt;gadget.max_speed		= USB_SPEED_SUPER;</span><br><span class="line">	dwc-&gt;gadget.speed		= USB_SPEED_UNKNOWN;</span><br><span class="line">	dwc-&gt;gadget.name		= <span class="string">&quot;dwc3-gadget&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化 OUT 和 IN 端点 */</span></span><br><span class="line">	dwc3_gadget_init_endpoints(dwc);</span><br><span class="line">	---&gt; dwc3_gadget_init_hw_endpoints(dwc, dwc-&gt;num_out_eps, <span class="number">0</span>);</span><br><span class="line">	---&gt; dwc3_gadget_init_hw_endpoints(dwc, dwc-&gt;num_in_eps, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 在udc class driver list 中增加新的 gadget:&quot;dwc3-gadget&quot; */</span></span><br><span class="line">	usb_add_gadget_udc((struct device *)dwc-&gt;dev, &amp;dwc-&gt;gadget);</span><br><span class="line">	---&gt; usb_add_gadget_udc_release(parent, gadget, <span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着分析 usb_add_gadget_udc_release 函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * usb_add_gadget_udc_release - adds a new gadget to the udc class driver list</span></span><br><span class="line"><span class="comment"> * @parent: the parent device to this udc. Usually the controller driver&#x27;s</span></span><br><span class="line"><span class="comment"> * device.</span></span><br><span class="line"><span class="comment"> * @gadget: the gadget to be added to the list.</span></span><br><span class="line"><span class="comment"> * @release: a gadget release function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns zero on success, negative errno otherwise.</span></span><br><span class="line"><span class="comment"> * Calls the gadget release function in the latter case.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usb_add_gadget_udc_release</span><span class="params">(struct device *parent, struct usb_gadget *gadget,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">void</span> (*release)(struct device *dev))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_udc</span>		*<span class="title">udc</span>;</span></span><br><span class="line"></span><br><span class="line">	dev_set_name(&amp;gadget-&gt;dev, <span class="string">&quot;gadget&quot;</span>);</span><br><span class="line">	INIT_WORK(&amp;gadget-&gt;work, usb_gadget_state_work);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化 gadget-&gt;dev 和 udc-&gt;dev 结构体 */</span></span><br><span class="line">	device_initialize(&amp;gadget-&gt;dev);</span><br><span class="line">	device_initialize(&amp;udc-&gt;dev);</span><br><span class="line">	</span><br><span class="line">	udc-&gt;dev.release = usb_udc_release;</span><br><span class="line">	udc-&gt;dev.class = udc_class;</span><br><span class="line">	udc-&gt;dev.groups = usb_udc_attr_groups;</span><br><span class="line">	udc-&gt;dev.parent = parent;</span><br><span class="line">	ret = dev_set_name(&amp;udc-&gt;dev, <span class="string">&quot;%s&quot;</span>, kobject_name(&amp;parent-&gt;kobj));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 把 gadget-&gt;dev 添加到gadget设备中 */</span></span><br><span class="line">	ret = device_add(&amp;gadget-&gt;dev);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* udc 和 gadget 相互建立连接 */</span></span><br><span class="line">	udc-&gt;gadget = gadget;</span><br><span class="line">	gadget-&gt;udc = udc;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 把udc，即dwc3 usb device controller 添加到 udc_list 中 */</span></span><br><span class="line">    list_add_tail(&amp;udc-&gt;<span class="built_in">list</span>, &amp;udc_list);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 把 udev-&gt;dev 添加到udc设备中 */</span></span><br><span class="line">	device_add(&amp;udc-&gt;dev);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* pick up one of pending gadget drivers */</span></span><br><span class="line">	check_pending_gadget_drivers(udc);</span><br><span class="line">	---&gt; 遍历 gadget_driver_pending_list ，根据 name 来给 udc 绑定对应的 driver</span><br><span class="line">	---&gt; udc_bind_to_driver(udc, driver);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>这里和从Gadget Driver层往下分析时调用 udc_bind_to_driver 绑定 usb_gadget_driver（即msg_driver-&gt;gadget_driver） 与对应的 usb_udc（即dw3 usb device controller） 时一致，最终把UDC和对应的驱动绑定，从而使上层gadget driver可以使用。</p>
<p>大致框图如下：</p>
<p><img src="/2021/03/20/Android-USB-Framework-Architecture/UDC_Framework.jpg" alt="UDC Framework Architecture"></p>
<h4 id="Configfs"><a href="#Configfs" class="headerlink" title="Configfs"></a>Configfs</h4><p>详情介绍可以参考 kernel 官方文档，这里只是简单介绍一下。</p>
<ul>
<li>Documentation/filesystems/configfs/configfs.txt</li>
<li>Documentation/usb/gadget_configfs.txt</li>
</ul>
<p>和 usb gadget 相关的configfs主要源码实现路径：</p>
<ul>
<li>kernel/msm-4.19/drivers/usb/gadget/configfs.c</li>
</ul>
<p>首先看下 configfs 中 和 gadget 相关的设备内容， adb 进入设备 /config/usb_gadget/g1 路径<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">xxx:/config/usb_gadget/g1 <span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">./strings</span><br><span class="line">./strings/<span class="number">0x409</span></span><br><span class="line">./strings/<span class="number">0x409</span>/serialnumber <span class="comment">/*串号，使用emmc时，该值为emmc id号经过hash运算后生成的唯一值*/</span></span><br><span class="line">./strings/<span class="number">0x409</span>/product</span><br><span class="line">./strings/<span class="number">0x409</span>/manufacturer</span><br><span class="line">./configs</span><br><span class="line">./configs/c<span class="number">.1</span></span><br><span class="line">./configs/c<span class="number">.1</span>/ncm.usb0 -&gt; ../../../../usb_gadget/g1/functions/ncm.usb0</span><br><span class="line">./configs/c<span class="number">.1</span>/strings</span><br><span class="line">./configs/c<span class="number">.1</span>/strings/<span class="number">0x409</span></span><br><span class="line"><span class="comment">/* ------ 在rc文件中，写入对应的功能，即可以把相应function添加到该configuration中 ------ */</span></span><br><span class="line">./configs/c<span class="number">.1</span>/strings/<span class="number">0x409</span>/configuration </span><br><span class="line">./configs/c<span class="number">.1</span>/bmAttributes</span><br><span class="line">./configs/c<span class="number">.1</span>/MaxPower</span><br><span class="line">./functions</span><br><span class="line">./functions/ncm.usb0</span><br><span class="line">./functions/ncm.usb0/ifname</span><br><span class="line">./functions/ncm.usb0/qmult</span><br><span class="line">./functions/ncm.usb0/host_addr</span><br><span class="line">./functions/ncm.usb0/dev_addr</span><br><span class="line">./UDC <span class="comment">/*USB device controller 名字，这里为 a600000.dwc3*/</span></span><br><span class="line">./bcdUSB <span class="comment">/* 该设备遵循的USB版本号，以BCD码表示，USB1.1为0x0101，USB2.0为0x0200 */</span></span><br><span class="line">./bcdDevice <span class="comment">/*用于表示USB设备的版本号*/</span></span><br><span class="line">./idProduct <span class="comment">/* USB product ID */</span></span><br><span class="line">./idVendor <span class="comment">/* USB vendor ID */</span></span><br><span class="line">./bMaxPacketSize0 <span class="comment">/* 用于表示在USB设备中，端点0所支持最大数据包的长度，它以字节为单位 */</span></span><br><span class="line">./bDeviceProtocol <span class="comment">/* 用于表示USB设备类所采用的设备类协议，其值和bDeviceClass和bDeviceSubClass有关 */</span></span><br><span class="line">./bDeviceSubClass <span class="comment">/* 该设备所属的标准设备子类 */</span></span><br><span class="line">./bDeviceClass <span class="comment">/* 该设备所属的标准设备类 */</span></span><br></pre></td></tr></table></figure></p>
<p>在 init.msm.usb.configfs.rc 中，当 sys.usb.config 匹配为mass_storege,adb时，执行脚本如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">on property:sys.usb.ffs.ready=<span class="number">1</span> &amp;&amp; property:sys.usb.config=mass_storage,adb &amp;&amp; property:sys.usb.configfs=<span class="number">1</span></span><br><span class="line">    write /config/usb_gadget/g1/configs/b<span class="number">.1</span>/strings/<span class="number">0x409</span>/configuration <span class="string">&quot;adb_msc&quot;</span></span><br><span class="line">	...</span><br><span class="line">    write /config/usb_gadget/g1/idVendor <span class="number">0x05C6</span></span><br><span class="line">    write /config/usb_gadget/g1/idProduct <span class="number">0x9015</span></span><br><span class="line">    symlink /config/usb_gadget/g1/functions/ffs.adb /config/usb_gadget/g1/configs/b<span class="number">.1</span>/f1</span><br><span class="line">    symlink /config/usb_gadget/g1/functions/mass_storage<span class="number">.0</span> /config/usb_gadget/g1/configs/b<span class="number">.1</span>/f2</span><br><span class="line">    write /config/usb_gadget/g1/UDC $&#123;sys.usb.controller&#125;</span><br><span class="line">    setprop sys.usb.state $&#123;sys.usb.config&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，该脚本主要做了如下事情：</p>
<ul>
<li>把选择的 function 组合 写入到 /config/usb_gadget/g1/configs/b.1/strings/0x409/configuration 中</li>
<li>重写 idVendor 和 idProduct</li>
<li>把2个 function 做 link操作，映射到/config/usb_gadget/g1/configs/b.1/f1和f2</li>
<li>把usb device controller的名字写入到 /config/usb_gadget/g1/UDC</li>
<li>最后设置 sys.usb.state 为当前状态</li>
</ul>
<p>到此，我们通过设置 sys.usb.config 等属性值，就可以切换Android USB设备作为Device的功能选择。</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<p>注：此 USB 文档主要讲述了 Android USB 设备作为 Host 和Device的整体代码流程分析，其中省略掉了 OTG 部分的分析。此外，Android USB 还有如下特性没有分析，后面找机会分别介绍，这里记录一下：</p>
<ul>
<li>OTG</li>
<li>Type C</li>
<li>USB Charging &amp; PD</li>
<li>DP</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/usb/" rel="tag"># usb</a>
          </div>
          <script type="text/javascript">
            var tagsall=document.getElementsByClassName("post-tags")
            for (var i = tagsall.length - 1; i >= 0; i--){
                var tags=tagsall[i].getElementsByTagName("a");
                for (var j = tags.length - 1; j >= 0; j--) {
                    var r=Math.floor(Math.random()*75+130);
                    var g=Math.floor(Math.random()*75+100);
                    var b=Math.floor(Math.random()*75+80);
                    tags[j].style.background = "rgb("+r+","+g+","+b+")";
                }
            }                        
            </script>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/05/Thermal_Core_Framework_Architecture/" rel="prev" title="Thermal Core 框架">
      <i class="fa fa-chevron-left"></i> Thermal Core 框架
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">拓扑结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.2.</span> <span class="nav-text">物理接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.</span> <span class="nav-text">传输模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">1.4.</span> <span class="nav-text">描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E6%B5%81%E7%A8%8B"><span class="nav-number">1.5.</span> <span class="nav-text">枚举流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-USB-Driver"><span class="nav-number">2.</span> <span class="nav-text">Android USB Driver</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Android-USB-Host"><span class="nav-number">2.1.</span> <span class="nav-text">Android USB Host</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%B7%AF%E5%BE%84"><span class="nav-number">2.1.1.</span> <span class="nav-text">代码路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">2.1.2.</span> <span class="nav-text">核心结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dwc3"><span class="nav-number">2.1.3.</span> <span class="nav-text">dwc3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#usb-core"><span class="nav-number">2.1.4.</span> <span class="nav-text">usb core</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#root-hub"><span class="nav-number">2.1.5.</span> <span class="nav-text">root hub</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#usb-generic-driver"><span class="nav-number">2.1.6.</span> <span class="nav-text">usb generic driver</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#usb-skeleton-driver"><span class="nav-number">2.1.7.</span> <span class="nav-text">usb-skeleton  driver</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#USB-Device"><span class="nav-number">2.2.</span> <span class="nav-text">USB Device</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6"><span class="nav-number">2.2.1.</span> <span class="nav-text">基本框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%B7%AF%E5%BE%84-1"><span class="nav-number">2.2.2.</span> <span class="nav-text">代码路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84%E4%BD%93-1"><span class="nav-number">2.2.3.</span> <span class="nav-text">核心结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#USB-%E5%8A%9F%E8%83%BD%E9%A9%B1%E5%8A%A8%E5%B1%82-amp-Gaget-%E8%AE%BE%E5%A4%87%E5%B1%82"><span class="nav-number">2.2.4.</span> <span class="nav-text">USB 功能驱动层 &amp; Gaget 设备层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDC"><span class="nav-number">2.2.5.</span> <span class="nav-text">UDC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Configfs"><span class="nav-number">2.2.6.</span> <span class="nav-text">Configfs</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">LexYoung</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LexYoung</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
