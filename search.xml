<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Qcom platform battery capacity algorithm</title>
    <url>/2020/09/24/Qcom-platform-battery-capacity-algorithm/</url>
    <content><![CDATA[<!-- toc -->
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Acronym</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>BMS</td>
<td>battery monitoring system</td>
</tr>
<tr>
<td>RC</td>
<td>remaing capacity.<br>当前状态下的剩余电量，充满电时RC=FCC</td>
</tr>
<tr>
<td>UUC</td>
<td>unusable capacity.<br>由于电池电阻导致的电池压降等原因而无法使用的电量</td>
</tr>
<tr>
<td>UC</td>
<td>usable capacity.<br>UC=FCC-UUC</td>
</tr>
<tr>
<td>RUC</td>
<td>Remaining Usable Capacity。RUC=RC-UUC</td>
</tr>
<tr>
<td>SoC</td>
<td>State of Charge.<br>剩余电量与总电量的比值，SoC = RUC/UC = (RC-UUC)/(FCC-UUC)</td>
</tr>
<tr>
<td>OCV</td>
<td>Open Circuit Voltage.<br>近乎于0电流情况下的稳定电压，电池带负载工作后，需要5~30min恢复OCV。</td>
</tr>
<tr>
<td>ACC</td>
<td>Apparent Charge Capacity.<br>FCC of the battery modified by increased battery resistance due to temperature and loaded system cutoff voltage</td>
</tr>
</tbody>
</table>
</div>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<p>目前接触到的高通有关电池电量算法一共有4种：</p>
<ol>
<li>Voltage Mode Battery Monitor System</li>
<li>Battery Monitor System</li>
<li>Qualcomm Battery Gauge</li>
<li>Fuel Gauge</li>
</ol>
<p>其中前3种为软件算法，最后一种为硬件算法，接下来我们分别介绍。</p>
<a id="more"></a>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h2 id="Voltage-Mode-Battery-Monitor-System"><a href="#Voltage-Mode-Battery-Monitor-System" class="headerlink" title="Voltage Mode Battery Monitor System"></a>Voltage Mode Battery Monitor System</h2><h3 id="VM-BMS-硬件框架"><a href="#VM-BMS-硬件框架" class="headerlink" title="VM-BMS 硬件框架"></a>VM-BMS 硬件框架</h3><p>VM-BMS主体框架图如下：<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/Voltage_Mode_BMS_Block_Diagram.PNG" alt="Voltage_Mode_BMS_Block_Diagram"></p>
<p>VM-BMS使用电池电压来计算产生SOC值，其中涉及到ADC的测量和Vbatt的测量</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="VM-BMS状态机"><a href="#VM-BMS状态机" class="headerlink" title="VM-BMS状态机"></a>VM-BMS状态机</h3><p>VM-BMS在运行过程中，主要处于下面状态:<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/VM-BMS_Modes_of_Operation.PNG" alt="VM-BMS_states"></p>
<p>S1 - Normal state</p>
<ul>
<li>系统处于唤醒且不在CV charging模式  </li>
<li>BMS按照配置的速率读取Vbat  </li>
<li>BMS读取Vbat的采样，然后存储在FIFO中(默认长度为5)</li>
<li>Software processes SoC using latest accumulated value</li>
</ul>
<p>S2 - CV state</p>
<ul>
<li>系统处于CV charging模式</li>
<li>BMS按照配置的速率读取Vbat，速率比S1快</li>
<li>BMS读取Vbat的采样，然后存储在FIFO中(默认长度为5)</li>
<li>Software processes SoC using latest Vbat value</li>
</ul>
<p>S3 - OCV state</p>
<ul>
<li>系统处于sleep/standby状态，如果有充电器连接，需要处于end of chager状态</li>
<li>BMS按照配置的速率读取Vbat  </li>
<li>如果连续读取的Vbat值落在公差范围内，更新OCV的值</li>
<li>OCV-SOC对照表被用着去计算SOC的值</li>
<li>Software processes SoC using latest OCV value  </li>
</ul>
<p>S7 - PON OSV state</p>
<ul>
<li>系统开机状态</li>
<li>如果关机SoC有效,那么关机SoC的值将作为BMS算法的开始点，否则使用第一个有效的VADC</li>
<li>OVC能被直接转换为相应的启动SoC值</li>
</ul>
<p>注：<br>在当前的软件设计中，只要系统处于唤醒，BMS强制进入S2，只要系统处于suspends，BMS强制进入S3</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="VM-BMS-算法"><a href="#VM-BMS-算法" class="headerlink" title="VM-BMS 算法"></a>VM-BMS 算法</h3><p>1.VM-BMS 通过 GOOD_OCV 和 FIFO中的数据来计算出 Ibat 和 OCV</p>
<p>GOOD_OCV 值的获取如下：</p>
<ul>
<li>PON_OCV if cold boot</li>
<li>Shut down SoC if fast reboot</li>
<li>Updated OCV if system enters S3 state and an OCV update occurs</li>
</ul>
<p>2.通过 OCV 和 temperature 查找对应的数据表获取Internal_Soc</p>
<script type="math/tex; mode=display">
Internal_Soc = LUT(OCV,temperature)</script><p>3.报告给用户的SoC</p>
<ul>
<li><p>充电时:  </p>
<script type="math/tex; mode=display">
Reported SoC = Internal SoC</script></li>
<li><p>放电时:  </p>
<script type="math/tex; mode=display">
Reported SoC = Internal SoC - (1-(ACC/FCC))</script><p>FCC：可从满电池中获取的总电量.<br>ACC：由于温度和system cut-off voltage的因素，实际设备可从满电池中获取的总电量</p>
</li>
</ul>
<p>我们先看充电时的算法示例，即如何获取到Internal SoC<br>已知 OCV = 4180mV，temperature = 28℃，<br>求解Internal SoC</p>
<p>OCV-temperature-SOC 表如下：</p>
<p><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/Sample_OCV-temperature-SOC_lookup_table-1.PNG" alt="Sample OCV-temperature-SOC lookup table-1"></p>
<p>从已知可得28℃在25℃和40℃之间</p>
<ul>
<li>设left_col = COL[3]</li>
<li>设right_col = COL[4]</li>
</ul>
<p><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/Sample_OCV-temperature-SOC_lookup_table-2.PNG" alt="Sample OCV-temperature-SOC lookup table-2"></p>
<p>如上图，在 left_col 中，4180mV在 SOC-85 和 SOC-90 对应的电压值之间，通过下面公式获取25°时，4180mV对应的SOC值</p>
<script type="math/tex; mode=display">
SOC_{interpolate\_left}=(90-85)* \frac {4180-4156} {4210-4156} + 85 = 87.2</script><p>同理，在 right_col 中，4180mV在 SOC-85 和 SOC-90 对应的电压值之间，通过下面公式获取40°时，4180mV对应的SOC值</p>
<script type="math/tex; mode=display">
SOC_{interpolate\_left}=(90-85)* \frac {4180-4154} {4210-41564} + 85 = 87.3</script><p>现在我们知道25℃和40℃时，4180mV对应的SOC值，通过下面的公式我们可以获取28℃时，4180mV对应的SOC值，即Internal SoC</p>
<script type="math/tex; mode=display">
SOC\{n\}=(87.3-87.2)* \frac {28-25} {40-25} + 87.2 = 87.22</script><p>接下来我们来看放电时 VM-BMS 的算法，在放电时，需要引入ACC的概念(需要考虑到 system cut-off voltage)</p>
<p>ACC = FCC - UCC = LUT(cut-off_voltage,temperature,Ibat)</p>
<p>current-temperatu-ACC对照表如下：</p>
<p><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/ACC_lookup_table-1.PNG" alt="ACC_lookup_table"></p>
<p>可以看出，当放电电流增大时，ACC变小.</p>
<p>已知 OCV = 4180mV，temperature = 10℃，放电电流=800mA<br>求解Reported SoC<br>首先按照上面的方法，查找LUT(OCV,temperature)，计算出Internal SoC.</p>
<p>然后查找ACC-temperature-SOC对照表，如下：</p>
<p><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/ACC_lookup_table-2.PNG" alt="ACC_lookup_table-2"></p>
<p>由已知条件temperature = 10℃，在0℃和25℃之间，<br>放电电流=800mA，在500mA~1000mA之间，做如下图：</p>
<p><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/ACC_lookup_table-3.PNG" alt="ACC_lookup_table-3"></p>
<p>通过如下算式，我们可以计算出temperature = 10℃，放电电流=800mA时，ACC的值</p>
<script type="math/tex; mode=display">
ACC@0deg = =(764-1246)* \frac {800-500} {1000-500} + 1246 = 956.8</script><script type="math/tex; mode=display">
ACC@25deg = =(1337-1414)* \frac {800-500} {1000-500} + 1414 = 1367.8</script><script type="math/tex; mode=display">
ACC@10deg = =(1367.8-956.8)* \frac {10-0} {25-0} + 956.8 = 1121.2</script><p>最后通过放电时的公式计算出Reported SoC.</p>
<script type="math/tex; mode=display">
Reported SoC = Internal SoC - (1-(ACC/FCC))</script><p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="VM-BMS-软件"><a href="#VM-BMS-软件" class="headerlink" title="VM-BMS 软件"></a>VM-BMS 软件</h3><h4 id="VM-BMS-代码路径："><a href="#VM-BMS-代码路径：" class="headerlink" title="VM-BMS 代码路径："></a>VM-BMS 代码路径：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kernel/msm<span class="number">-3.18</span>/drivers/power/qpnp-vm-bms.c</span><br><span class="line">kernel/msm<span class="number">-3.18</span>/drivers/power/batterydata-lib.c</span><br><span class="line">kernel/msm<span class="number">-3.18</span>/drivers/power/batterydata-interface.c</span><br><span class="line">kernel/msm<span class="number">-3.18</span>/drivers/of/of_batterydata.c</span><br></pre></td></tr></table></figure>
<h4 id="VM-BMS-软件框图："><a href="#VM-BMS-软件框图：" class="headerlink" title="VM-BMS 软件框图："></a>VM-BMS 软件框图：</h4><p><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/VM-BMS_Software_Architecture.PNG" alt="VM-BMS_Software_Architecture"></p>
<p>注：用户空间算法以二进制形式提供给客户</p>
<h4 id="VM-BMS-代码分析"><a href="#VM-BMS-代码分析" class="headerlink" title="VM-BMS 代码分析"></a>VM-BMS 代码分析</h4><p>1.首先分析qpnp-vm-bms.c的probe函数，大致调用关系如下：<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/qpnp_vm_bms_probe-flow-chart.PNG" alt="qpnp_vm_bms_probe-flow-chart"></p>
<p>其中涉及到的主要函数即作用如下表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>bms_get_adc</td>
<td>获取 VADC 和 ADC_TM clients</td>
</tr>
<tr>
<td>qpnp_pon_is_warm_reset</td>
<td>判断设备是否为warm reset启动</td>
</tr>
<tr>
<td>parse_spmi_dt_propertie</td>
<td>解析spmi相关节点</td>
</tr>
<tr>
<td>parse_bms_dt_properties</td>
<td>解析bms相关节点</td>
</tr>
<tr>
<td>set_battery_data</td>
<td>读取battery id电压，计算出电阻值，通过匹配最接近的电阻值来获取指定battery data（dts），赋给bms_battery_data结构体</td>
</tr>
<tr>
<td>config_battery_data</td>
<td>给batterydata-interface.c中的battery_data结构体赋值</td>
</tr>
<tr>
<td>bms_init_defaults</td>
<td>初始化bms相关变量</td>
</tr>
<tr>
<td>bms_load_hw_defaults</td>
<td>通过dts属性配置硬件寄存器</td>
</tr>
<tr>
<td>setup_vbat_monitoring</td>
<td>为电池低压检测</td>
</tr>
<tr>
<td>bms_request_irqs</td>
<td>Sets up VBAT ADC_TM channel for low vbat monitor</td>
</tr>
<tr>
<td>battery_insertion_check</td>
<td>Restarts BMS hardware to start BMS calculation</td>
</tr>
<tr>
<td>battery_status_check</td>
<td>检测充电状态</td>
</tr>
<tr>
<td>register_bms_char_device</td>
<td>注册bms字符设备</td>
</tr>
<tr>
<td>calculate_initial_soc</td>
<td>设备启动后，计算第一次的SOC值</td>
</tr>
<tr>
<td>calculate_initial_aging_comp</td>
<td>读取charge_cycles和charge_increase数据</td>
</tr>
<tr>
<td>monitor_soc_work</td>
<td>计算soc值</td>
</tr>
<tr>
<td>voltage_soc_timeout_work</td>
<td>超过指定时间，如果bms字符设备没有被open，设置相关flag，后续使用电压来计算SOC，而并非bms算法</td>
</tr>
</tbody>
</table>
</div>
<p>2.接下来我们介绍其中的核心函数monitor_soc_work，主要流程如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">monitor_soc_work</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;chip-&gt;last_soc_mutex);<span class="comment">//上锁</span></span><br><span class="line"></span><br><span class="line">    battery_voltage_check(chip);<span class="comment">//检测充电的状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chip-&gt;dt.cfg_use_voltage_soc) &#123;</span><br><span class="line">        <span class="comment">//使用voltage base on SOC,计算soc值</span></span><br><span class="line">        calculate_soc_from_voltage(chip);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        get_batt_therm(chip, &amp;batt_temp);<span class="comment">//获取电池温度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//查表获取新的soc值</span></span><br><span class="line">        new_soc = lookup_soc_ocv(chip, chip-&gt;last_ocv_uv,batt_temp);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//简单校准soc值</span></span><br><span class="line">        new_soc = clamp_soc_based_on_voltage(chip, new_soc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过查表计算出来的chip-&gt;calculated_soc值有变化</span></span><br><span class="line">        <span class="keyword">if</span> (chip-&gt;calculated_soc != new_soc) &#123;</span><br><span class="line">            chip-&gt;calculated_soc = new_soc;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (chip-&gt;calculated_soc == <span class="number">100</span>)</span><br><span class="line">                <span class="comment">/* update last_soc immediately */</span></span><br><span class="line">                report_vm_bms_soc(chip);</span><br><span class="line"></span><br><span class="line">            power_supply_changed(&amp;chip-&gt;bms_psy);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//上报的soc值还没有更新到与chip-&gt;calculated_soc同步</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chip-&gt;last_soc != chip-&gt;calculated_soc) &#123;</span><br><span class="line">            pr_debug(<span class="string">&quot;update bms_psy\n&quot;</span>);</span><br><span class="line">            power_supply_changed(&amp;chip-&gt;bms_psy);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            report_vm_bms_soc(chip);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* low SOC configuration */</span></span><br><span class="line">    low_soc_check(chip);<span class="comment">// 低电量，重新设置fifo长度</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * schedule the work only if last_soc has not caught up with</span></span><br><span class="line"><span class="comment">	 * the calculated soc or if we are using voltage based soc</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//当上报的soc值和计算出来的soc值不匹配时，延时调用该队列</span></span><br><span class="line">	<span class="keyword">if</span> ((chip-&gt;last_soc != chip-&gt;calculated_soc) ||</span><br><span class="line">					chip-&gt;dt.cfg_use_voltage_soc)</span><br><span class="line">		schedule_delayed_work(&amp;chip-&gt;monitor_soc_work,</span><br><span class="line">			msecs_to_jiffies(get_calculation_delay_ms(chip)));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (chip-&gt;reported_soc_in_use &amp;&amp; chip-&gt;charger_removed_since_full</span><br><span class="line">				&amp;&amp; !chip-&gt;charger_reinserted) &#123;</span><br><span class="line">		<span class="comment">/* record the elapsed time after last reported_soc change */</span></span><br><span class="line">		chip-&gt;reported_soc_change_sec += chip-&gt;delta_time_s;</span><br><span class="line">		pr_debug(<span class="string">&quot;reported_soc_change_sec=%d\n&quot;</span>,</span><br><span class="line">					chip-&gt;reported_soc_change_sec);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* above the catch up time, calculate new reported_soc */</span></span><br><span class="line">		<span class="keyword">if</span> (chip-&gt;reported_soc_change_sec &gt; UI_SOC_CATCHUP_TIME) &#123;</span><br><span class="line">			calculate_reported_soc(chip);</span><br><span class="line">			chip-&gt;reported_soc_change_sec = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;chip-&gt;last_soc_mutex);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要作用是检测并计算soc值，主要流程图如下：</p>
<p><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/monitor_soc_work.PNG" alt="monitor_soc_work"></p>
<p>3.monitor_soc_work其中还涉及到的核心函数report_vm_bms_soc，主要流程如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">report_vm_bms_soc</span><span class="params">(struct qpnp_bms_chip *chip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	soc = chip-&gt;calculated_soc;</span><br><span class="line">	charging = is_battery_charging(chip);<span class="comment">//判断充电状态</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算充电时间</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (chip-&gt;last_soc != -EINVAL) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * last_soc &lt; soc  ... if we have not been charging at all</span></span><br><span class="line"><span class="comment">		 * since the last time this was called, report previous SoC.</span></span><br><span class="line"><span class="comment">		 * Otherwise, scale and catch up.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        get_batt_therm(chip, &amp;batt_temp);<span class="comment">//获取电池温度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果last_soc小于calculated_soc：</span></span><br><span class="line">        <span class="comment">//1.非充电状态，上报之前的SOC值</span></span><br><span class="line">        <span class="comment">//2.充电状态，不立即报告高值，而是根据充电时间加权平均值将值从prev_soc缓慢地缩放到新的soc</span></span><br><span class="line">		<span class="keyword">if</span> (chip-&gt;last_soc &lt; soc &amp;&amp; !charging)</span><br><span class="line">			soc = chip-&gt;last_soc;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (chip-&gt;last_soc &lt; soc &amp;&amp; soc != <span class="number">100</span>)</span><br><span class="line">			soc = scale_soc_while_chg(chip, charge_time_sec,chip-&gt;catch_up_time_sec,soc, chip-&gt;chg_start_soc);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果电池电压接近cut-off voltage，或者电池温度处于低温，</span></span><br><span class="line">        <span class="comment">//这2中情况允许出现SOC值大的变化，即soc_change值较大</span></span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在resume情况下，如果ocv发生变化，会进行赋值chip-&gt;last_soc_unbound = true</span></span><br><span class="line">        <span class="comment">//这种情况下soc_change可以为较大值，否则只能为1.</span></span><br><span class="line">		<span class="keyword">if</span> (chip-&gt;last_soc_unbound) &#123;</span><br><span class="line">			chip-&gt;last_soc_unbound = <span class="literal">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * if soc have not been unbound by resume,</span></span><br><span class="line"><span class="comment">			 * only change reported SoC by 1.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			soc_change = min(<span class="number">1</span>, soc_change);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据上面的条件计算出soc_change值，在此基础上修改soc值，防止发生不必要的跳变</span></span><br><span class="line">		<span class="keyword">if</span> (soc &lt; chip-&gt;last_soc &amp;&amp; soc != <span class="number">0</span>)</span><br><span class="line">			soc = chip-&gt;last_soc - soc_change;</span><br><span class="line">		<span class="keyword">if</span> (soc &gt; chip-&gt;last_soc &amp;&amp; soc != <span class="number">100</span>)</span><br><span class="line">			soc = chip-&gt;last_soc + soc_change;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	soc = bound_soc(soc);<span class="comment">//防止soc小于0或者大于100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在如下情况检测、更新end of charger</span></span><br><span class="line">    <span class="comment">//1.soc发生变化 2.soc值为100</span></span><br><span class="line">	<span class="keyword">if</span> ((soc != chip-&gt;last_soc) || (soc == <span class="number">100</span>)) &#123;</span><br><span class="line">		chip-&gt;last_soc = soc;</span><br><span class="line">		check_eoc_condition(chip);<span class="comment">//检测停止充电条件</span></span><br><span class="line">		<span class="keyword">if</span> ((chip-&gt;dt.cfg_soc_resume_limit &gt; <span class="number">0</span>) &amp;&amp; !charging)</span><br><span class="line">			check_recharge_condition(chip);<span class="comment">//检测recharge条件</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把ocv和soc的值存储在寄存器中</span></span><br><span class="line">	backup_ocv_soc(chip, chip-&gt;last_ocv_uv, chip-&gt;last_soc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> chip-&gt;last_soc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要作用<br>1.在chip-&gt;calculated_soc的基础上，计算出chip-&gt;last_soc.(防止跳变)<br>2.检测停充和复充条件<br>3.存储chip-&gt;last_soc和chip-&gt;last_ocv_uv到寄存器中</p>
<p>主要流程图如下：<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/report_vm_bms_soc.PNG" alt="report_vm_bms_soc"></p>
<p>4.接下来看下驱动提供的property interface，当monitor_soc_work调用power_supply_changed时，发生uevent事件给用户空间 vm-bms.c(非开源)，用户空间通过get_property获取电池相关参数，计算出last_ocv_uv，然后通过set_property来设置OCV，启动monitor_soc_work工作队列，代码流程如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//---------kernel/msm-3.18/drivers/power/qpnp-linear-charger.c---------</span></span><br><span class="line">chip-&gt;bms_psy-&gt;get_property(chip-&gt;bms_psy,POWER_SUPPLY_PROP_CAPACITY, &amp;ret);</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------kernel/msm-3.18/drivers/power/qpnp-vm-bms.c---------                </span></span><br><span class="line">----&gt;get_prop_bms_capacity(chip);</span><br><span class="line">    ----&gt;report_state_of_charge(chip);</span><br><span class="line">        ----&gt;report_voltage_based_soc(chip);<span class="comment">//基于voltage计算soc</span></span><br><span class="line">        ----&gt;report_vm_bms_soc(chip);<span class="comment">//基于bms计算soc</span></span><br></pre></td></tr></table></figure>
<p>流程图如下：<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/property_interface.PNG" alt="property_interface"></p>
<p>5.涉及到的表格</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">DTS节点</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">qcom,fcc-temp-lut</td>
<td>不同温度下，FCC(Full-charge capacity)的值.</td>
</tr>
<tr>
<td style="text-align:left">qcom,pc-temp-ocv-lut</td>
<td>不同温度下，通过OVC的值映射到对应的SOC值.</td>
</tr>
<tr>
<td style="text-align:left">qcom,rbatt-sf-lut</td>
<td>不同温度下，通过SOC值映射到对应的内阻值，主要考虑对OCV的修正，new_ocv=ocv+rbatt(内阻)*current（当前电流）.</td>
</tr>
<tr>
<td style="text-align:left">qcom,ibat-acc-lut</td>
<td>不同温度下，通过当前的电流值映射到ACC的值.</td>
</tr>
</tbody>
</table>
</div>
<p><strong>总结：</strong><br>1.vm-bms 运行 monitor_soc_work 工作队列来执行主要的工作：通过last_ocv_uv，查表得到SOC，经过修正得到上报的SOC值.<br>2.当驱动调用power_supply_changed，表示power supply class有property发生变化，发送uevent事件，上层获取事件后，调用getprop来获取相关参数：内阻，电流等，在用户空间 vm-bms.c(非开源)估算出last_ocv_uv，然后调用setprop，传入参数：POWER_SUPPLY_PROP_VOLTAGE_OCV,重新调用monitor_soc_work 工作队列. </p>
<p>注：PM8909/PM8916支持VM-BMS</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h2 id="Battery-Monitor-System"><a href="#Battery-Monitor-System" class="headerlink" title="Battery Monitor System"></a>Battery Monitor System</h2><p>VM-BMS主要基于OCV的值来进行计算出SOC值，BMS在VM-BMS的基础上，主要引入了库仑计，利用经过电池的电流的累计，计算出电荷量，即综合raw OCV 和 Coulomb count (CC) data计算出SOC值。<br>因为与VM-BMS比较类似，并且目前手上没有PM8921/PM8941的代码，所以这里简单介绍下BMS。</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="BMS-硬件框架"><a href="#BMS-硬件框架" class="headerlink" title="BMS 硬件框架"></a>BMS 硬件框架</h3><p><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/BMS_Block_Diagram.PNG" alt="BMS_Block_Diagram"></p>
<ul>
<li>通过Vbatt计算出OCV</li>
<li>通过Vsensor-B和Rsensor计算出电流，CCADC采样电流计算出经过电池的电荷量</li>
</ul>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="BMS状态机"><a href="#BMS状态机" class="headerlink" title="BMS状态机"></a>BMS状态机</h3><p><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/BMS_State_Machine_Details.PNG" alt="BMS_State_Machine_Details"></p>
<ul>
<li>S1 降低测试频率，减少功耗</li>
<li>S2 增大测试频率，提高精度</li>
<li>S3 对Vbatt和Vsensor大量采样，更新 last good OCV，同时对库仑计数(CC)清零</li>
</ul>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="BMS-算法"><a href="#BMS-算法" class="headerlink" title="BMS 算法"></a>BMS 算法</h3><p>1.库仑计数(CC)跟踪OCV更新之间的电量损失<br>2.当OCV 更新时，库仑计数(CC)复位清零。<br>3.利用OCV值查表获取对应soc值<br>4.最终的SOC值 = (最新的OCV值对应的电量 - 库仑计数(CC)对应的电量 - 不可用电量)/(满电量-不可用电量)</p>
<p>公式如下：</p>
<script type="math/tex; mode=display">
SOC=\frac {Lookup(OCV) * FCC - \frac {CC} {R_sense}UCC} {FCC - UUC}</script><p>其中UUC也是根据Rbatt，Vcut-off 查表获取。<br>可以看出，和 vm-bms 对比，主要增加了利用库仑计数（CC）来优化OCV未更新时SOC的计算</p>
<h3 id="BMS-软件"><a href="#BMS-软件" class="headerlink" title="BMS 软件"></a>BMS 软件</h3><h4 id="BMS-软件框图"><a href="#BMS-软件框图" class="headerlink" title="BMS 软件框图"></a>BMS 软件框图</h4><p><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/PM8921_BMS_Linux_Android_Software_Architecture.PNG" alt="PM8921_BMS_Linux_Android_Software_Architecture"></p>
<p>基本和vm-bms一致。</p>
<h4 id="BMS-代码分析"><a href="#BMS-代码分析" class="headerlink" title="BMS 代码分析"></a>BMS 代码分析</h4><p>主要代码流程如下，流程图省略。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qpnp_bms_probe</span><span class="params">(struct spmi_device *spmi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//和vm-bms流程基本一致,这里只列出其中不一致的核心代码</span></span><br><span class="line"></span><br><span class="line">    INIT_DELAYED_WORK(&amp;chip-&gt;calculate_soc_delayed_work,calculate_soc_work);</span><br><span class="line">	INIT_WORK(&amp;chip-&gt;recalc_work, recalculate_work);</span><br><span class="line"></span><br><span class="line">    calculate_soc_work(&amp;(chip-&gt;calculate_soc_delayed_work.work));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calculate_soc_work</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	recalculate_soc(chip);</span><br><span class="line">	schedule_delayed_work(&amp;chip-&gt;calculate_soc_delayed_work,...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recalculate_work</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	recalculate_soc(chip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从上面的代码可以看出，calculate_soc_delayed_work 工作队列一直循环延时调用 recalculate_soc 函数。<br>而 recalc_work 工作队列调用一次 recalculate_soc 函数，所以重点在 recalculate_soc 函数，我们接下来重点分析 recalculate_soc 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">recalculate_soc</span><span class="params">(struct qpnp_bms_chip *chip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取电池温度</span></span><br><span class="line">	pnp_vadc_read(chip-&gt;vadc_dev, LR_MUX1_BATT_THERM,&amp;result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取电池温度值</span></span><br><span class="line">	batt_temp = (<span class="keyword">int</span>)result.physical;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取库伦计数(CC) 和 last good ocv</span></span><br><span class="line">    read_soc_params_raw(chip, &amp;raw, batt_temp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算出各种参数，利用参数计算出soc值，根据soc值计算出上报的soc值。</span></span><br><span class="line">	soc = calculate_state_of_charge(chip,&amp;raw, batt_temp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> soc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate_state_of_charge</span><span class="params">(struct qpnp_bms_chip *chip,</span></span></span><br><span class="line"><span class="function"><span class="params">					struct raw_soc_params *raw,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">int</span> batt_temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//计算充电时间，FCC，剩余电量，库仑计数(CC),Rbat,Iavg等参数</span></span><br><span class="line">	calculate_soc_params(chip, raw, &amp;params, batt_temp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用上面计算的参数和公式 RC-UUC/FCC-UUC 计算出soc值</span></span><br><span class="line">	soc = calculate_raw_soc(chip, raw, &amp;params, batt_temp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开机第一次计算，利用 shutdown_soc 来修改soc值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* always clamp soc due to BMS hw/sw immaturities */</span></span><br><span class="line">	new_calculated_soc = clamp_soc_based_on_voltage(chip,</span><br><span class="line">					new_calculated_soc);</span><br><span class="line"></span><br><span class="line">	new_calculated_soc = bound_soc(new_calculated_soc);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果与上次计算soc的值的时间相差超过规定时间，表明系统一定进入了长时间休眠状态，Soc状态设置为unbound</span></span><br><span class="line">	chip-&gt;last_soc_unbound = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算出的soc值发生变化，上报给上层</span></span><br><span class="line">	<span class="keyword">if</span> (new_calculated_soc != previous_soc &amp;&amp; chip-&gt;bms_psy_registered) &#123;</span><br><span class="line">		power_supply_changed(&amp;chip-&gt;bms_psy);</span><br><span class="line">		pr_debug(<span class="string">&quot;power supply changed\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Call report state of charge anyways to periodically update</span></span><br><span class="line"><span class="comment">		 * reported SoC. This prevents reported SoC from being stuck</span></span><br><span class="line"><span class="comment">		 * when calculated soc doesn&#x27;t change.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		report_state_of_charge(chip);</span><br><span class="line">		<span class="comment">//根据voltage上报soc值</span></span><br><span class="line">		----&gt;report_voltage_based_soc(chip);</span><br><span class="line">		<span class="keyword">or</span></span><br><span class="line">		<span class="comment">//根据 chip-&gt;calculated_soc 计算出上报的soc值：chip-&gt;last_soc，同时存储SOC和Iavg的值到寄存器</span></span><br><span class="line">		----&gt;report_cc_based_soc(chip);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong><br>1.获取库伦计数(CC)，充电时间，FCC，剩余电量，库仑计数(CC),Rbat,Iavg等参数<br>2.利用上面参数计算soc值，在vm-bms中，用户空间(非开源)利用这些参数计算出OCV，然后利用OCV查表计算出osc值<br>3.根据上面的soc值，计算出上报的soc值</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h2 id="Qualcomm-battery-gauge"><a href="#Qualcomm-battery-gauge" class="headerlink" title="Qualcomm battery gauge"></a>Qualcomm battery gauge</h2><h3 id="QG-硬件框架"><a href="#QG-硬件框架" class="headerlink" title="QG 硬件框架"></a>QG 硬件框架</h3><p>硬件大致框图如下:<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/Qualcomm_Battery_Gauge_Hardware_Block_Diagram.PNG" alt="Qualcomm_Battery_Gauge_Hardware_Block_Diagram"></p>
<p>PMI632 Qualcomm battery gauge 硬件的核心由累加器组成，该累加器会定期采样，累加并将Vbatt和Ibatt值保存到PMIC寄存器中，以读取和处理SoC,并使用相同的硬件对电池内阻（ESR）进行估计。</p>
<h3 id="QG-SOC概念"><a href="#QG-SOC概念" class="headerlink" title="QG SOC概念"></a>QG SOC概念</h3><h4 id="1-RAW-SOC"><a href="#1-RAW-SOC" class="headerlink" title="1.RAW SOC"></a>1.RAW SOC</h4><p>RAW SOC是库仑计估算的SOC(CC_SOC)和Vlotage mode估算的SOC(V_SOC)加权评估出来的结果，大致流程如下：<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/RAW_SOC.PNG" alt="RAW_SOC"></p>
<h4 id="2-BATTERY-SOC"><a href="#2-BATTERY-SOC" class="headerlink" title="2.BATTERY SOC"></a>2.BATTERY SOC</h4><p>BATTERY SOC是根据RAW SOC计算出来，同时根据电池的电压，电流和状态进行校正，大致流程如下：<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/BATTERY_SOC.PNG" alt="BATTERY_SOC"></p>
<h4 id="3-SYSTEM-SOC"><a href="#3-SYSTEM-SOC" class="headerlink" title="3.SYSTEM SOC"></a>3.SYSTEM SOC</h4><ul>
<li>SOC point 0%：上报0%的SOC的点将根据截止电压（qcom,vbatt-cutoff-mv）进行收敛，通过设置截止电压，可以使任何期望的电压对应0%的SOC值。</li>
<li>SOC point 100%:上报100%的SOC的点将根据充电电流来决定，截止电流为2种，一种为系统截止电流，即达到该电流时，上报100% SOC，一种是物理充电截止电流，达到该电流时，设备停止充电。<br>系统截止电流对应的dts：qcom,qg-iterm-ma<br>物理充电截止电流对应的dts：qcom,chg-term-current-ma<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/SYSTEM_SOC.PNG" alt="SYSTEM_SOC"></li>
</ul>
<h4 id="4-Monotonic-SOC"><a href="#4-Monotonic-SOC" class="headerlink" title="4.Monotonic SOC"></a>4.Monotonic SOC</h4><p>在截止电压附近，有2种情况，可能导致SOC不单调变化</p>
<ul>
<li>电池内部电阻发生变化</li>
<li>电池负载发生变化</li>
</ul>
<p>为了确保SOC的单调性变化，QG算法确定如下逻辑：</p>
<ul>
<li>当放电或者supplemental模式时，SOC单调递减</li>
<li>当充电时，SOC单调递增</li>
</ul>
<h4 id="5-PON-SOC"><a href="#5-PON-SOC" class="headerlink" title="5.PON SOC"></a>5.PON SOC</h4><p>Ponwer on SOC的值可以通过Shutdown SOC的值获取，但是需要满足几个条件：温度变化，时间长度，SOC变化都在一定设置范围内。如果其中一项不满足，系统将使用PON OCV估算出来的值。</p>
<ul>
<li>qcom,ignore-shutdown-soc-secs = <360>; /<em> phone-off time to ignore shutdown soc </em>/</360></li>
<li>qcom,shutdown-temp-diff = <60>; /<em> battery temp delta to ignore shutdown soc</em>/</60></li>
<li>qcom,shutdown-soc-threshold = <10>; /<em>soc delta between shutdown and pon soc for ignoring shutdown soc </em>/</10></li>
</ul>
<h4 id="6-SOC-FLOW"><a href="#6-SOC-FLOW" class="headerlink" title="6.SOC FLOW"></a>6.SOC FLOW</h4><p>各个SOC的流程框图如下：<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/SOC_FLOW.PNG" alt="SOC_FLOW"><br>具体涉及到的数据流程：<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/SOC_FLOW2.PNG" alt="SOC_FLOW2"></p>
<p>基于以上4中SOC，QG算法计算出最终的SOC上报给系统。</p>
<h3 id="QG-算法核心"><a href="#QG-算法核心" class="headerlink" title="QG 算法核心"></a>QG 算法核心</h3><p>QG算法的核心思想如下：</p>
<ol>
<li>从GOOD_OCV或者FIFO Vbatt中计算出OCV</li>
</ol>
<ul>
<li>GOOD_OVC可以考虑为如下值，<ul>
<li>PON_OVC（设备冷启动）</li>
<li>Shutdown Soc（设备快速重启）</li>
<li>记录的OVC（睡眠状态）</li>
</ul>
</li>
</ul>
<ol>
<li>根据battery profile，利用OCV查表计算出V_SOC<br> V_SOC = LUT(OVC, temperature)</li>
<li>基于FIFO Ibatt数据，得出CC_Soc</li>
</ol>
<h3 id="QG-软件"><a href="#QG-软件" class="headerlink" title="QG  软件"></a>QG  软件</h3><h4 id="QG-代码路径"><a href="#QG-代码路径" class="headerlink" title="QG 代码路径"></a>QG 代码路径</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>路径</th>
</tr>
</thead>
<tbody>
<tr>
<td>路径A</td>
<td>kernel/msm-4.14/drivers/power/supply/qcom/qpnp-qg.c</td>
</tr>
<tr>
<td>路径B</td>
<td>kernel/msm-4.14/drivers/power/supply/qcom/qp-soc.c</td>
</tr>
</tbody>
</table>
</div>
<h4 id="QG-软件框图"><a href="#QG-软件框图" class="headerlink" title="QG  软件框图"></a>QG  软件框图</h4><p>软件框图如下：<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/Qualcomm_Battery_Gauge_software_architecture.PNG" alt="Qualcomm_Battery_Gauge_software_architecture"></p>
<p>该软件框图涉及到2部分：内核空间和用户空间</p>
<ul>
<li>用户空间<ul>
<li>硬件配置</li>
<li>初始化SOC计算 </li>
<li>保存Shutdown OCV状态</li>
<li>电池在位检测</li>
<li>设置battery profile</li>
<li>中断处理</li>
<li>读取FIFO和累加器中的数据</li>
<li>根据OVC（用户空间计算）和电池温度查表计算出SOC</li>
<li>最终得出Monotonic Soc</li>
</ul>
</li>
<li>用户空间<ul>
<li>利用内核中的硬件数据（FIFO和累加器）计算出OCV</li>
<li>通过算法计算出V_SoC, CC_SoC, R_SoC, Bat_SoC, and Sys_SoC </li>
<li>更新OCV，Sys_SoC到内核空间</li>
<li>用户空间的算法为二进制文件，对客户保密</li>
</ul>
</li>
</ul>
<h4 id="QG-代码分析"><a href="#QG-代码分析" class="headerlink" title="QG 代码分析"></a>QG 代码分析</h4><p>首先分析probe函数<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qpnp_qg_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在qg驱动中，会注册一个字符设备&quot;qg&quot;，</span></span><br><span class="line"><span class="comment">	 * 当用户空间对qg进行write操作时，</span></span><br><span class="line"><span class="comment">	 * 用户空间的数据会写入到内核的qg_user_data结构体中</span></span><br><span class="line"><span class="comment">	 * 然后调用udata_work队列，更新内核中的数据，计算各个soc的值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	INIT_WORK(&amp;chip-&gt;udata_work, process_udata_work);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 当battery，parallel，usb，dc属性发生power supply chaned时</span></span><br><span class="line"><span class="comment">	 * 会调用回调函数 qg_notifier_cb</span></span><br><span class="line"><span class="comment">	 * 在此回调函数中会调用 qg_status_change_work 队列</span></span><br><span class="line"><span class="comment">	 * 该函数主要更新一些battery的状态属性</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	INIT_WORK(&amp;chip-&gt;qg_status_change_work, qg_status_change_work);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 1.初始化alarm定时器，超时后调用qpnp_msoc_timer函数</span></span><br><span class="line"><span class="comment">     * 2.初始化scale_soc_work工作队列</span></span><br><span class="line"><span class="comment">     * 3.qpnp_msoc_timer会调度scale_soc_work工作队列</span></span><br><span class="line"><span class="comment">     * qg_soc_init函数的目的：定时调用scale_soc_work工作队列来计算soc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	qg_soc_init(chip);</span><br><span class="line">	----&gt;alarm_init(&amp;chip-&gt;alarm_timer, ALARM_BOOTTIME,qpnp_msoc_timer);</span><br><span class="line">	----&gt;WORK(&amp;chip-&gt;scale_soc_work, scale_soc_work);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 主要作用是决定PON SOC：</span></span><br><span class="line"><span class="comment">	 * 温度变化，时间长度，SOC变化都在一定设置范围内，使用Shutdown SOC</span></span><br><span class="line"><span class="comment">	 * 如果其中一项不满足，系统将使用PON OCV估算出来的值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	qg_determine_pon_soc(chip);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*power_supply_changed</span></span><br><span class="line"><span class="comment">	 * 1.注册qg power supply设备</span></span><br><span class="line"><span class="comment">	 * 2.注册power_supply_notifier事件通知链，当调用power_supply_changed时</span></span><br><span class="line"><span class="comment">	 * 会调用回调函数 qg_notifier_cb</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	qg_init_psy(chip);</span><br><span class="line">	----&gt;devm_power_supply_register(chip-&gt;dev,&amp;qg_psy_desc, &amp;qg_psy_cfg);</span><br><span class="line">	----&gt;chip-&gt;nb.notifier_call = qg_notifier_cb;</span><br><span class="line">	----&gt;power_supply_reg_notifier(&amp;chip-&gt;nb);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注：</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">power_supply_desc</span> <span class="title">qg_psy_desc</span> = &#123;</span></span><br><span class="line">	.name = <span class="string">&quot;bms&quot;</span>,</span><br><span class="line">	.type = POWER_SUPPLY_TYPE_BMS,</span><br><span class="line">	.properties = qg_psy_props,</span><br><span class="line">	.num_properties = ARRAY_SIZE(qg_psy_props),</span><br><span class="line">	.get_property = qg_psy_get_property,</span><br><span class="line">	.set_property = qg_psy_set_property,</span><br><span class="line">	.property_is_writeable = qg_property_is_writeable,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>有3种情况，qg子系统计算更新soc值</p>
<ol>
<li>当其他power子系统调用power_supply_changed时</li>
<li>当用户空间的二进制算法操作qg字符设备时</li>
<li>上次设置的 alarm_timer 定时器超时时</li>
</ol>
<p>下面我们来分别说明这3个情况</p>
<p>1.当其他power子系统调用power_supply_changed时,会调用回调函数qg_notifier_cb</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qg_notifier_cb</span><span class="params">(struct notifier_block *nb,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">unsigned</span> <span class="keyword">long</span> event, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((<span class="built_in">strcmp</span>(psy-&gt;desc-&gt;name, <span class="string">&quot;battery&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		|| (<span class="built_in">strcmp</span>(psy-&gt;desc-&gt;name, <span class="string">&quot;parallel&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		|| (<span class="built_in">strcmp</span>(psy-&gt;desc-&gt;name, <span class="string">&quot;usb&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		|| (<span class="built_in">strcmp</span>(psy-&gt;desc-&gt;name, <span class="string">&quot;dc&quot;</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">		schedule_work(&amp;chip-&gt;qg_status_change_work);</span><br><span class="line">		<span class="comment">//检测usb，dc插拔，调用 qg_scale_soc 更新SOC</span></span><br><span class="line">		----&gt;qg_input_status_update(chip)</span><br><span class="line">		<span class="comment">//检测battery是否full状态，并看情况调用 qg_scale_soc 更新SOC</span></span><br><span class="line">		----&gt;qg_charge_full_update(chip)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.当用户空间的二进制算法操作对qg字符设备进行write操作时，会调用udata_work工作队列<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">qg_device_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//把用户空间的算法计算出来的数据写入内核</span></span><br><span class="line">	copy_from_user(&amp;chip-&gt;udata, buf, data_size)</span><br><span class="line">	</span><br><span class="line">	vote(chip-&gt;awake_votable, UDATA_READY_VOTER, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调度udata_work工作队列</span></span><br><span class="line">	schedule_work(&amp;chip-&gt;udata_work);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_udata_work</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">qpnp_qg</span> *<span class="title">chip</span> = <span class="title">container_of</span>(<span class="title">work</span>,</span></span><br><span class="line"><span class="class">			<span class="title">struct</span> <span class="title">qpnp_qg</span>, <span class="title">udata_work</span>);</span></span><br><span class="line">	<span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 判断用户空间写入到内核的数据是否有效，并把soc相关值值赋给qpnp_qg结构体</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (chip-&gt;udata.param[QG_CC_SOC].valid)</span><br><span class="line">		chip-&gt;cc_soc = chip-&gt;udata.param[QG_CC_SOC].data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (chip-&gt;udata.param[QG_BATT_SOC].valid)</span><br><span class="line">		chip-&gt;batt_soc = chip-&gt;udata.param[QG_BATT_SOC].data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (chip-&gt;udata.param[QG_FULL_SOC].valid)</span><br><span class="line">		chip-&gt;full_soc = chip-&gt;udata.param[QG_FULL_SOC].data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (chip-&gt;udata.param[QG_SOC].valid ||</span><br><span class="line">			chip-&gt;udata.param[QG_SYS_SOC].valid) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (chip-&gt;udata.param[QG_SYS_SOC].valid) &#123;</span><br><span class="line">			chip-&gt;sys_soc = chip-&gt;udata.param[QG_SYS_SOC].data;</span><br><span class="line">			chip-&gt;catch_up_soc = qg_adjust_sys_soc(chip);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			chip-&gt;catch_up_soc = chip-&gt;udata.param[QG_SOC].data;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 调用qg_scale_soc强制更新soc</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		qg_scale_soc(chip, chip-&gt;force_soc);</span><br><span class="line">		chip-&gt;force_soc = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * update soc parameters to SDAM</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		chip-&gt;sdam_data[SDAM_SOC] = chip-&gt;msoc;</span><br><span class="line">		chip-&gt;sdam_data[SDAM_OCV_UV] =</span><br><span class="line">				chip-&gt;udata.param[QG_OCV_UV].data;</span><br><span class="line">		chip-&gt;sdam_data[SDAM_RBAT_MOHM] =</span><br><span class="line">				chip-&gt;udata.param[QG_RBAT_MOHM].data;</span><br><span class="line">		chip-&gt;sdam_data[SDAM_VALID] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		rc = qg_store_soc_params(chip);</span><br><span class="line">		<span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line">			pr_err(<span class="string">&quot;Failed to update SDAM params, rc=%d\n&quot;</span>, rc);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 判断用户空间写入到内核的数据是否有效，并把esr相关值值赋给qpnp_qg结构体</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (chip-&gt;udata.param[QG_ESR].valid)</span><br><span class="line">		chip-&gt;esr_last = chip-&gt;udata.param[QG_ESR].data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (chip-&gt;esr_actual != -EINVAL &amp;&amp; chip-&gt;udata.param[QG_ESR].valid)&#123;</span><br><span class="line">		chip-&gt;esr_nominal = chip-&gt;udata.param[QG_ESR].data;</span><br><span class="line">		<span class="keyword">if</span> (chip-&gt;qg_psy)</span><br><span class="line">			power_supply_changed(chip-&gt;qg_psy);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * update ser parameters to SDAM</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!chip-&gt;dt.esr_disable)</span><br><span class="line">		qg_store_esr_params(chip);</span><br><span class="line"></span><br><span class="line">	vote(chip-&gt;awake_votable, UDATA_READY_VOTER, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以上2种情况，最终都是调用 qg_scale_soc 来计算更新，下面具体分析该函数<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qg_scale_soc</span><span class="params">(struct qpnp_qg *chip, <span class="keyword">bool</span> force_soc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在用户空间写gq字符设备时，调用 qg_scale_soc 来强制更新soc</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (force_soc) &#123;</span><br><span class="line">		chip-&gt;msoc = chip-&gt;catch_up_soc;</span><br><span class="line">		rc = qg_write_monotonic_soc(chip, chip-&gt;msoc);</span><br><span class="line">		<span class="keyword">goto</span> done_psy;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 判断是否需要更新soc，如果否，则取消alarm_timer定时器来并跳过更新soc。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!is_scaling_required(chip)) &#123;</span><br><span class="line">		scale_soc_stop(chip);</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 1.判断并更新chip-&gt;msoc</span></span><br><span class="line"><span class="comment">	 * 2.根据新的MSOC更新SOC寄存器的值</span></span><br><span class="line"><span class="comment">	 * 3.根据新的MSOC更新SDAM的值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	update_msoc(chip);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 判断是否需要更新soc，如果是，获取下次更新时间间隔，并设置定时器</span></span><br><span class="line"><span class="comment">	 * 如果否，取消alarm_timer定时器。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (is_scaling_required(chip)) &#123;</span><br><span class="line">		get_next_update_time(chip);</span><br><span class="line">		alarm_start_relative(&amp;chip-&gt;alarm_timer,</span><br><span class="line">					ms_to_ktime(chip-&gt;next_wakeup_ms));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		scale_soc_stop(chip);</span><br><span class="line">		<span class="keyword">goto</span> done_psy;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">done_psy:</span><br><span class="line">	power_supply_changed(chip-&gt;qg_psy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.alarm_timer 定时器超时<br>在 qg_scale_soc 函数中，如果还需要更新soc，会设置并启动alarm_timer定时器,超时时调用qpnp_msoc_timer函数，在qpnp_msoc_timer函数中，调度scale_soc_work工作队列，scale_soc_work队列函数与qg_scale_soc函数作用于基本一致，只是少了强制更新逻辑。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * alarm_timer定时器超时函数，调度scale_soc_work工作队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">enum</span> alarmtimer_restart</span><br><span class="line">	qpnp_msoc_timer(struct alarm *alarm, <span class="keyword">ktime_t</span> now)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">qpnp_qg</span> *<span class="title">chip</span> = <span class="title">container_of</span>(<span class="title">alarm</span>,</span></span><br><span class="line"><span class="class">				<span class="title">struct</span> <span class="title">qpnp_qg</span>, <span class="title">alarm_timer</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* timer callback runs in atomic context, cannot use voter */</span></span><br><span class="line">	pm_stay_awake(chip-&gt;dev);</span><br><span class="line">	schedule_work(&amp;chip-&gt;scale_soc_work);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ALARMTIMER_NORESTART;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 与qg_scale_soc函数作用于基本一致，只是少了强制更新逻辑</span></span><br><span class="line"><span class="comment"> * （主要用在空户空间对kernel更新qg相关参数时）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scale_soc_work</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">qpnp_qg</span> *<span class="title">chip</span> = <span class="title">container_of</span>(<span class="title">work</span>,</span></span><br><span class="line"><span class="class">			<span class="title">struct</span> <span class="title">qpnp_qg</span>, <span class="title">scale_soc_work</span>);</span></span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;chip-&gt;soc_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!is_scaling_required(chip)) &#123;</span><br><span class="line">		scale_soc_stop(chip);</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	update_msoc(chip);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (is_scaling_required(chip)) &#123;</span><br><span class="line">		alarm_start_relative(&amp;chip-&gt;alarm_timer,</span><br><span class="line">				ms_to_ktime(chip-&gt;next_wakeup_ms));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		scale_soc_stop(chip);</span><br><span class="line">		<span class="keyword">goto</span> done_psy;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">done_psy:</span><br><span class="line">	power_supply_changed(chip-&gt;qg_psy);</span><br><span class="line">done:</span><br><span class="line">	pm_relax(chip-&gt;dev);</span><br><span class="line">	mutex_unlock(&amp;chip-&gt;soc_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>总结：</strong></p>
<ol>
<li><p>当其他power子系统调用 power_supply_changed 时，根据情况会计算soc，简单流程如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">power_supply_changed</span><br><span class="line">---&gt;qg_notifier_cb</span><br><span class="line">	----&gt;schedule_work(&amp;chip-&gt;qg_status_change_work);</span><br><span class="line">		----&gt;qg_input_status_update(chip);</span><br><span class="line">			----&gt;qg_scale_soc(chip, <span class="literal">false</span>);</span><br><span class="line">		----&gt;qg_charge_full_update(chip);</span><br><span class="line">			 ----&gt;qg_scale_soc(chip, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>当用户空间的二进制算法操作qg字符设备时，简单流程如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">qg_device_write</span><br><span class="line">	<span class="comment">//把用户空间的数据复制给内核相关结构体，并重新计算soc</span></span><br><span class="line">----&gt;schedule_work(&amp;chip-&gt;udata_work);</span><br><span class="line">	----&gt;qg_scale_soc(chip, chip-&gt;force_soc);</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面2种情况主动调用qg_scale_soc来计算soc时，根据实际情况情况判断是否需要启动定时器alarm_timer来定时更新soc，简单流程如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">alarm_start_relative(&amp;chip-&gt;alarm_timer,</span><br><span class="line">				ms_to_ktime(chip-&gt;next_wakeup_ms));</span><br><span class="line">----&gt;qpnp_msoc_timer</span><br><span class="line">		<span class="comment">//scale_soc_work函数和qg_scale_soc作用一致，用来更新soc值</span></span><br><span class="line">	----&gt;schedule_work(&amp;chip-&gt;scale_soc_work);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>从上面的流程可以看到，cc_soc,batt_soc,full_soc,sys_soc,catch_up_soc等值都是从用户空间传递给内核的，内核只是根据这些值计算，判断出msoc作为系统上报的soc.</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h2 id="Fuel-Gauge"><a href="#Fuel-Gauge" class="headerlink" title="Fuel Gauge"></a>Fuel Gauge</h2><p>FG模块是一种算法的硬件实现，该算法通过检测电流和电压来评估计算电池的电量。</p>
<h3 id="FG-架构"><a href="#FG-架构" class="headerlink" title="FG 架构"></a>FG 架构</h3><p><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/Fuel Gauge Architecture.PNG" alt="Fuel Gauge Architecture"></p>
<p>FG架构如上图：</p>
<ol>
<li>CS_PLUS和CS_MINUS用来检测FG电流</li>
<li>BATT_PLUS和BATT_MINUS用来检测电池电压</li>
<li>BATT_ID检测battery ID引脚电阻，BATT_THERM检测电池温度， 两者一起检测Battery Missing状态</li>
</ol>
<h3 id="FG-算法"><a href="#FG-算法" class="headerlink" title="FG 算法"></a>FG 算法</h3><p>Fuel Gauge 在原理上与 Battery Gauge 是一样的。<br>只是QG算法在 AP 上运行，更便于调整和优化算法。<br>FG 是固化在 PMIC 里面的 Firmware 不能改动，只能微调部分寄存器设置。</p>
<p>FG算法也涉及到QG算法中的CC_SoC，Battery SoC，System SoC,  Monotonic SoC，大致框图如下:<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/FG_SOC_FLOW.PNG" alt="FG_SOC_FLOW.PNG"></p>
<ol>
<li>CC_SoC ： coulomb-counted value </li>
<li>Battery SoC：Battery SoC是CC_SoC和voltage mode校正算法的结合，大致流程如下图：<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/FG_Battery_SoC.PNG" alt="FG_Battery_SoC"></li>
</ol>
<p>其中涉及到的Battery model：<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/Battery_Model.PNG" alt="Battery_Model"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">* OCV：Open Circuit Voltage (开漏电路电压)，即电路没有电流，并且电池为使用或者长时间闲置（C1完全放电）</span><br><span class="line">* ESR：Equivalent Series Resistance（等效串联电阻），影响电池瞬时功率，它的值与温度和电池状态（充/放电）相关。</span><br><span class="line">* T1 Time Constant：它说明了先前电池使用后电池SoC的变化。它的值通常在几分钟的范围内，R1随温度，电池温度和电池SoC级别而变化，对Rslow-C1建模有助于解决滞后行为并改善电池SoC的估计。</span><br></pre></td></tr></table></figure>
<ol>
<li>System SoC：与QG算法一致。</li>
<li>Monotonic SoC：与QG算法一致。<br>详情可以参考《80-vt310-123_c_pmi8994_fuel_gauge_hw_sw_control.pdf》</li>
</ol>
<h3 id="FG-软件"><a href="#FG-软件" class="headerlink" title="FG 软件"></a>FG 软件</h3><h4 id="FG-代码路径"><a href="#FG-代码路径" class="headerlink" title="FG 代码路径"></a>FG 代码路径</h4><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>路径</th>
</tr>
</thead>
<tbody>
<tr>
<td>Driver source code</td>
<td>kernel/drivers/power/qpnp-fg.c.</td>
</tr>
<tr>
<td>Device tree configuration</td>
<td>kernel/arch/arm/boot/dts/qcom/msm-pmi8994.dtsi</td>
</tr>
<tr>
<td>Document</td>
<td>kernel/Documentation/devicetree/bindings/power/qpnp-fg.txt</td>
</tr>
</tbody>
</table>
</div>
<h4 id="FG-代码分析"><a href="#FG-代码分析" class="headerlink" title="FG 代码分析"></a>FG 代码分析</h4><p>整个流程基本和QG算法一致，只是QG算法中各种SoC的值是从用户空间写入到内核中的，而FG算法大部分值是通过硬件计算后写入到寄存器中的。</p>
<p>所以代码分析省略。</p>
<p><strong>总结：</strong><br>Fuel Gauge 算法获取到最终上报的SoC的步骤分为4步：</p>
<ol>
<li>利用电流测量估算出CC_SoC(coulomb-counted SoC)</li>
<li>利用battery model和profile data，使用CC_SoC和电压模式校正，估算出Battery SoC</li>
<li>利用System Cut-Off Voltage和Charge Floating Voltage对Battery SoC掐头去尾（并未所有能量对系统可用），过滤为System SoC</li>
<li>利用放电SoC减少，充电SoC增加的单调性原则，过滤为Monotonic Soc，这个是上报给用户的最终SoC</li>
</ol>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<p><strong>高通电量计算总结：</strong></p>
<ol>
<li>vm-bms：用户空间获取电池内阻，电流，电压等等参数来计算出OCV，然后把该值传递给内核，内核通过查表得到SOC，经过修正得到上报的SOC值。</li>
<li>bms：VM-BMS主要基于OCV的值来进行计算出SOC值，BMS在VM-BMS的基础上，主要引入了库仑计，利用经过电池的电流的累计，计算出电荷量，即综合raw OCV 和 Coulomb count (CC) data计算出SOC值。</li>
<li>Qcom Battery Gauge：用户空间读取内核数据 chip-&gt;kdata,然后经过用户空间高通内部算法，计算出各个soc值（cc_soc,batt_soc,full_soc,sys_soc,catch_up_soc），最后把这些数据写入到内核数据 chip-&gt;udata，内核只是根据这些值计算，判断出msoc作为系统上报的soc.</li>
<li>Fuel Gauge：原理上与 Battery Gauge 是一样的，只是QG算法在 AP 上运行，更便于调整和优化算法，FG 是固化在 PMIC 里面的 Firmware 不能改动，只能微调部分寄存器设置。</li>
</ol>
]]></content>
      <categories>
        <category>Charging</category>
      </categories>
      <tags>
        <tag>Charing</tag>
        <tag>Battery</tag>
      </tags>
  </entry>
  <entry>
    <title>Thermal Core 框架</title>
    <url>/2021/01/05/Thermal_Core_Framework_Architecture/</url>
    <content><![CDATA[<!-- toc -->
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<p>关于温控，高通+Android平台目前主要提供了3个层面的机制来保护设备</p>
<ul>
<li>硬件相关控制（LMH）</li>
<li>Linux内核控制（Thermal Core）</li>
<li>User Space控制（ThermalEngine守护进程）</li>
</ul>
<p>此章节主要介绍Thermal Core的相关内容。<br><a id="more"></a><br>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<p>Thermal Core是用来替代之前的legacy framework kernel thermal monitor (KTM)，目前Thermal Core的关键功能如下</p>
<ul>
<li>Core isolation (hotplugging)</li>
<li>GPU Tj management</li>
<li>Low temperature management, that is, VDD restriction</li>
<li>OEM Tskin management (optional)</li>
</ul>
<p>主要框架图如下：<br><img src="/2021/01/05/Thermal_Core_Framework_Architecture/Thermal_Core_Framework_Architecture.PNG" alt="Thermal Core Framework Arch"></p>
<p>从框图中可以看到，整个Thermal Core框架包括4大主要部分：</p>
<ul>
<li>Thermal Zone Device：主要用来获取温度，并设置不同的温度触发点。</li>
<li>Thermal Governor：提供多种算法来控制温度：Step Wise、User Space等。</li>
<li>Thermal Cooling Device：降温设备的抽象，目前Cooling设备可以是CPU、devfreq、clock等。</li>
<li>Thermal Core：作为Thermal框架的中枢，提供核心函数，同时提供用户空间sysfs节点。</li>
</ul>
<p>Thermal Core的工作流程是通过Thermal Zone Device来获取温度并设置不同的温度触发点，经过配置的Thermal Governor来执行不同的策略，最终通过Thermal Cooling Device来控制温度到一个安全且适合的范围内。</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h2 id="Thermal-Zone-Device"><a href="#Thermal-Zone-Device" class="headerlink" title="Thermal Zone Device"></a>Thermal Zone Device</h2><p>内核代码使用thermal_zone_device 来抽象Thermal Zone Device，Thermal Zone Device主要作用为获取各个sensor对应的温度，并设置各个sensor的温度触发点.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thermal_zone_device</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">char</span> type[THERMAL_NAME_LENGTH];<span class="comment">//sensor名字</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">device</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> <span class="title">trips_attribute_group</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thermal_attr</span> *<span class="title">trip_temp_attrs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thermal_attr</span> *<span class="title">trip_type_attrs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thermal_attr</span> *<span class="title">trip_hyst_attrs</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *devdata;</span><br><span class="line">	<span class="keyword">int</span> trips;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> trips_disabled;	<span class="comment">/* bitmap for disabled trips */</span></span><br><span class="line">	<span class="keyword">int</span> passive_delay;</span><br><span class="line">	<span class="keyword">int</span> polling_delay;<span class="comment">//轮询读取sensor的时间间隔，0表示取消轮询工作队列</span></span><br><span class="line">	<span class="keyword">int</span> temperature;<span class="comment">//当前温度</span></span><br><span class="line">	<span class="keyword">int</span> last_temperature;<span class="comment">//上次读取的温度</span></span><br><span class="line">	<span class="keyword">int</span> emul_temperature;</span><br><span class="line">	<span class="keyword">int</span> passive;</span><br><span class="line">	<span class="keyword">int</span> prev_low_trip;</span><br><span class="line">	<span class="keyword">int</span> prev_high_trip;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> forced_passive;</span><br><span class="line">	<span class="keyword">atomic_t</span> need_update;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thermal_zone_device_ops</span> *<span class="title">ops</span>;</span><span class="comment">//thermal zone device操作函数集</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thermal_zone_params</span> *<span class="title">tzp</span>;</span><span class="comment">//thermal zone devicee参数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thermal_governor</span> *<span class="title">governor</span>;</span><span class="comment">//算法相关</span></span><br><span class="line">	<span class="keyword">void</span> *governor_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">thermal_instances</span>;</span><span class="comment">//挂载所有thermal策略示例的链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ida</span> <span class="title">ida</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span><span class="comment">//挂载thermal zone device的链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> <span class="title">poll_queue</span>;</span><span class="comment">//轮询工作队列</span></span><br><span class="line">	<span class="keyword">enum</span> thermal_notify_event notify_event;<span class="comment">//uevent事件类型，通过userspace算法类型传递给用户空间</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thermal_zone_device_ops</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> (*bind) (struct thermal_zone_device *,struct thermal_cooling_device *);</span><br><span class="line">	<span class="keyword">int</span> (*unbind) (struct thermal_zone_device *,struct thermal_cooling_device *);</span><br><span class="line">	<span class="keyword">int</span> (*get_temp) (struct thermal_zone_device *, <span class="keyword">int</span> *);</span><br><span class="line">	<span class="keyword">int</span> (*set_trips) (struct thermal_zone_device *, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*get_mode) (struct thermal_zone_device *,<span class="keyword">enum</span> thermal_device_mode *);</span><br><span class="line">	<span class="keyword">int</span> (*set_mode) (struct thermal_zone_device *,<span class="keyword">enum</span> thermal_device_mode);</span><br><span class="line">	<span class="keyword">int</span> (*get_trip_type) (struct thermal_zone_device *, <span class="keyword">int</span>,<span class="keyword">enum</span> thermal_trip_type *);</span><br><span class="line">	<span class="keyword">int</span> (*get_trip_temp) (struct thermal_zone_device *, <span class="keyword">int</span>, <span class="keyword">int</span> *);</span><br><span class="line">	<span class="keyword">int</span> (*set_trip_temp) (struct thermal_zone_device *, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*get_trip_hyst) (struct thermal_zone_device *, <span class="keyword">int</span>, <span class="keyword">int</span> *);</span><br><span class="line">	<span class="keyword">int</span> (*set_trip_hyst) (struct thermal_zone_device *, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*get_crit_temp) (struct thermal_zone_device *, <span class="keyword">int</span> *);</span><br><span class="line">	<span class="keyword">int</span> (*set_emul_temp) (struct thermal_zone_device *, <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*get_trend) (struct thermal_zone_device *, <span class="keyword">int</span>,<span class="keyword">enum</span> thermal_trend *);</span><br><span class="line">	<span class="keyword">int</span> (*notify) (struct thermal_zone_device *, <span class="keyword">int</span>,<span class="keyword">enum</span> thermal_trip_type);</span><br><span class="line">	<span class="keyword">bool</span> (*is_wakeable)(struct thermal_zone_device *);</span><br><span class="line">	<span class="keyword">int</span> (*set_polling_delay)(struct thermal_zone_device *, <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*set_passive_delay)(struct thermal_zone_device *, <span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h2 id="Thermal-Core"><a href="#Thermal-Core" class="headerlink" title="Thermal Core"></a>Thermal Core</h2><p>Thermal Core作为整个框架的中枢，我们先来分析一下thermal_core.c的入口函数。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* kernel/msm-4.14/drivers/thermal/thermal_core.c */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">thermal_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//注册各种算法类型</span></span><br><span class="line">	thermal_register_governors();</span><br><span class="line">    ----&gt;thermal_gov_step_wise_register();</span><br><span class="line">    ----&gt;thermal_gov_fair_share_register();</span><br><span class="line">    ----&gt;thermal_gov_bang_bang_register();</span><br><span class="line">    ----&gt;thermal_gov_user_space_register();</span><br><span class="line">    ----&gt;thermal_gov_low_limits_register();</span><br><span class="line">    ----&gt;thermal_gov_power_allocator_register();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成/sys/class/thermal目录</span></span><br><span class="line">    class_register(&amp;thermal_class);</span><br><span class="line">    <span class="comment">//解析dts，生成thermal zone device,核心函数，下面重点分析</span></span><br><span class="line">    of_parse_thermal_zones();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注册pm回调函数</span></span><br><span class="line">    register_pm_notifier(&amp;thermal_pm_nb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>thermal_init作为设备加载函数，主要作用：</p>
<ul>
<li>注册各种类型的governor机制</li>
<li>生成/sys/class/thermal目录</li>
<li>解析 DTS 中的 Thermal-zones 节点，用于生成/sys/class/thermal/thermal_zone[0-*]节点.</li>
</ul>
<p>一个thermal zone device的DTS示例：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* kernel/msm-4.14/arch/arm64/boot/dts/qcom/trinket-thermal.dtsi */</span></span><br><span class="line"><span class="comment">/* kernel/msm-4.14/arch/arm64/boot/dts/qcom/trinket-thermal-overlay.dtsi */</span></span><br><span class="line">&amp;thermal_zones &#123;</span><br><span class="line">    <span class="comment">/* thermal device zone 的名字 */</span></span><br><span class="line">	cpuss<span class="number">-1</span>-step &#123;</span><br><span class="line">		polling-delay-passive = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">		polling-delay = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">		thermal-governor = <span class="string">&quot;step_wise&quot;</span>;</span><br><span class="line">		thermal-sensors = &lt;&amp;tsens0 <span class="number">7</span>&gt;;</span><br><span class="line">		wake-capable-sensor;</span><br><span class="line">        <span class="comment">/* 设置有哪些温度触发点 */</span></span><br><span class="line">		trips &#123;</span><br><span class="line">			cpu5_7_config: cpu<span class="number">-5</span><span class="number">-7</span>-config &#123;</span><br><span class="line">				temperature = &lt;<span class="number">110000</span>&gt;;</span><br><span class="line">				hysteresis = &lt;<span class="number">10000</span>&gt;;</span><br><span class="line">				type = <span class="string">&quot;passive&quot;</span>;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">        <span class="comment">/* 把cooling devices与温度触发点绑定 */</span></span><br><span class="line">		cooling-maps &#123;</span><br><span class="line">			cpu5_cdev &#123;</span><br><span class="line">				trip = &lt;&amp;cpu5_7_config&gt;;</span><br><span class="line">				cooling-device =</span><br><span class="line">					&lt;&amp;CPU5 THERMAL_MAX_LIMIT</span><br><span class="line">						THERMAL_MAX_LIMIT&gt;;</span><br><span class="line">			&#125;;</span><br><span class="line">			cpu7_cdev &#123;</span><br><span class="line">				trip = &lt;&amp;cpu5_7_config&gt;;</span><br><span class="line">				cooling-device =</span><br><span class="line">					&lt;&amp;CPU7 THERMAL_MAX_LIMIT</span><br><span class="line">						THERMAL_MAX_LIMIT&gt;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>接下来以上面的DTS为例，分析 of_parse_thermal_zones 函数<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">of_parse_thermal_zones</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>, *<span class="title">child</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> __<span class="title">thermal_zone</span> *<span class="title">tz</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thermal_zone_device_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 解析dts thermal-zones节点中所有数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	np = of_find_node_by_name(<span class="literal">NULL</span>, <span class="string">&quot;thermal-zones&quot;</span>);</span><br><span class="line"></span><br><span class="line">	for_each_available_child_of_node(np, child) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">thermal_zone_device</span> *<span class="title">zone</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">thermal_zone_params</span> *<span class="title">tzp</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 解析dts thermal-zones的child的节点cpuss-1-step</span></span><br><span class="line"><span class="comment">         * 这里主要解析polling-delay-passive,polling-delay,trips和cooling-maps属性</span></span><br><span class="line"><span class="comment">         * 最后会把解析的结构通过__thermal_zone结构体return出来。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		tz = thermal_of_build_thermal_zone(child);</span><br><span class="line">        ---&gt;thermal_of_build_thermal_zone</span><br><span class="line">        ---&gt;for_each_child_of_node(child, gchild) &#123;</span><br><span class="line">                    thermal_of_populate_trip(gchild, &amp;tz-&gt;trips[i++]);</span><br><span class="line">                    </span><br><span class="line">        ---&gt;child = of_get_child_by_name(np, <span class="string">&quot;cooling-maps&quot;</span>);</span><br><span class="line">        ---&gt;for_each_child_of_node(child, gchild) &#123;</span><br><span class="line">                    thermal_of_populate_bind_params(gchild, &amp;tz-&gt;tbps[i++],</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 初始化tzp结构体，并使用DTS的属性进行填充，主要包括&quot;thermal-governor&quot;属性等</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		tzp = kzalloc(<span class="keyword">sizeof</span>(*tzp), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 使用上面从DTS解析的数据，注册一个thermal zone devices</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		zone = thermal_zone_device_register(child-&gt;name, tz-&gt;ntrips,</span><br><span class="line">						    mask, tz,</span><br><span class="line">						    ops, tzp,</span><br><span class="line">						    tz-&gt;passive_delay,</span><br><span class="line">						    tz-&gt;polling_delay);</span><br><span class="line">		tz-&gt;tzd = zone;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来重点分析注册tehrmal zone devices的函数 thermal_zone_device_register。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">thermal_zone_device_register(<span class="keyword">const</span> <span class="keyword">char</span> *type, <span class="keyword">int</span> trips, <span class="keyword">int</span> mask,</span><br><span class="line">			     <span class="keyword">void</span> *devdata, struct thermal_zone_device_ops *ops,</span><br><span class="line">			     struct thermal_zone_params *tzp, <span class="keyword">int</span> passive_delay,</span><br><span class="line">			     <span class="keyword">int</span> polling_delay)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thermal_zone_device</span> *<span class="title">tz</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thermal_governor</span> *<span class="title">governor</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 初始化thermal_instances链表，thermal_instances变量为一个具体的实例策略。</span></span><br><span class="line"><span class="comment"> 	 * This structure(thermal_instances) is used to </span></span><br><span class="line"><span class="comment"> 	 * describe the behavior of a certain cooling device </span></span><br><span class="line"><span class="comment">	 * on a certain trip point in a certain thermal zone</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;tz-&gt;thermal_instances);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 对thermal_zone_device *tz变量进行赋值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	tz-&gt;id = result;</span><br><span class="line">	strlcpy(tz-&gt;type, type, <span class="keyword">sizeof</span>(tz-&gt;type));</span><br><span class="line">	tz-&gt;ops = ops;</span><br><span class="line">	tz-&gt;tzp = tzp;</span><br><span class="line">	tz-&gt;device.class = &amp;thermal_class;</span><br><span class="line">	tz-&gt;devdata = devdata;</span><br><span class="line">	tz-&gt;trips = trips;</span><br><span class="line">	tz-&gt;passive_delay = passive_delay;</span><br><span class="line">	tz-&gt;polling_delay = polling_delay;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* sys I/F */</span></span><br><span class="line">	<span class="comment">/* Add nodes that are always present via .groups */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 把各种attribute_group结构体变量赋值给tz-&gt;device.groups</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	thermal_zone_create_device_groups(tz, mask);</span><br><span class="line">    ----&gt;<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size - <span class="number">2</span>; i++)</span><br><span class="line">            groups[i] = thermal_zone_attribute_groups[i];</span><br><span class="line">    ---&gt;<span class="keyword">if</span> (tz-&gt;trips) &#123;</span><br><span class="line">            result = create_trip_attrs(tz, mask);</span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                kfree(groups);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            groups[size - <span class="number">2</span>] = &amp;tz-&gt;trips_attribute_group;</span><br><span class="line">        &#125;</span><br><span class="line">	---&gt;tz-&gt;device.groups = groups;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 设置新的thermal zone*名字，</span></span><br><span class="line"><span class="comment">	 * 并根据上面的tz-&gt;device.groups创建/sys/class/thermal/thermal_zoneN 下面的各个属性节点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dev_set_name(&amp;tz-&gt;device, <span class="string">&quot;thermal_zone%d&quot;</span>, tz-&gt;id);</span><br><span class="line">	device_register(&amp;tz-&gt;device);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 为thermal zoneN设置新的governor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    thermal_set_governor(tz, governor);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 把该thermal_zone_device结构体添加到链表thermal_tz_list中</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	list_add_tail(&amp;tz-&gt;node, &amp;thermal_tz_list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Bind cooling devices for this zone */</span></span><br><span class="line">	bind_tz(tz);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 初始化poll_queue工作队列，对应的function主要用来轮询检测thermal zone device是否触发温度</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	INIT_DEFERRABLE_WORK(&amp;(tz-&gt;poll_queue), thermal_zone_device_check);</span><br><span class="line">	---&gt;thermal_zone_device_update(tz, THERMAL_EVENT_UNSPECIFIED);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 主要工作为对thermal_instance实例中的initialized变量赋为false.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	thermal_zone_device_reset(tz);</span><br><span class="line">	---&gt;thermal_zone_device_init(tz);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Update the new thermal zone and mark it as already updated. */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 1.更新thermal device zone对应的温度</span></span><br><span class="line"><span class="comment">	 * 2.设置触发温度</span></span><br><span class="line"><span class="comment">	 * 3.处理温度触发情况</span></span><br><span class="line"><span class="comment">	 * ---&gt;a.如果为critical类型，到达触发温度，执行关机/重启操作</span></span><br><span class="line"><span class="comment">	 * ---&gt;b.如果非critical类型，到达触发温度，执行对应的governor算法操作</span></span><br><span class="line"><span class="comment">	 * ---&gt;c.延时启动poll_queue工作队列，再次调用thermal_zone_device_update函数。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (atomic_cmpxchg(&amp;tz-&gt;need_update, <span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">		thermal_zone_device_update(tz, THERMAL_EVENT_UNSPECIFIED);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> tz;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(thermal_zone_device_register);</span><br></pre></td></tr></table></figure><br>接来下我们重点解析 bind_tz 和 thermal_zone_device_update 函数,首先分析bind_tz函数<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind_tz</span><span class="params">(struct thermal_zone_device *tz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thermal_cooling_device</span> *<span class="title">pos</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">thermal_zone_params</span> *<span class="title">tzp</span> = <span class="title">tz</span>-&gt;<span class="title">tzp</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If there is ops-&gt;bind, try to use ops-&gt;bind */</span></span><br><span class="line">	<span class="keyword">if</span> (tz-&gt;ops-&gt;bind) &#123;</span><br><span class="line">		list_for_each_entry(pos, &amp;thermal_cdev_list, node) &#123;</span><br><span class="line">			ret = tz-&gt;ops-&gt;bind(tz, pos);</span><br><span class="line">			---&gt;of_thermal_bind</span><br><span class="line">                ---&gt; thermal_zone_bind_cooling_device(thermal,</span><br><span class="line">												tbp-&gt;trip_id, cdev,</span><br><span class="line">												tbp-&gt;max,</span><br><span class="line">												tbp-&gt;min,</span><br><span class="line">												tbp-&gt;usage);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * thermal_zone_bind_cooling_device() - bind a cooling device to a thermal zone</span></span><br><span class="line"><span class="comment"> * @tz:		pointer to struct thermal_zone_device</span></span><br><span class="line"><span class="comment"> * @trip:	indicates which trip point the cooling devices is</span></span><br><span class="line"><span class="comment"> *		associated with in this thermal zone.</span></span><br><span class="line"><span class="comment"> * @cdev:	pointer to struct thermal_cooling_device</span></span><br><span class="line"><span class="comment"> * @upper:	the Maximum cooling state for this trip point.</span></span><br><span class="line"><span class="comment"> *		THERMAL_NO_LIMIT means no upper limit,</span></span><br><span class="line"><span class="comment"> *		and the cooling device can be in max_state.</span></span><br><span class="line"><span class="comment"> * @lower:	the Minimum cooling state can be used for this trip point.</span></span><br><span class="line"><span class="comment"> *		THERMAL_NO_LIMIT means no lower limit,</span></span><br><span class="line"><span class="comment"> *		and the cooling device can be in cooling state 0.</span></span><br><span class="line"><span class="comment"> * @weight:	The weight of the cooling device to be bound to the</span></span><br><span class="line"><span class="comment"> *		thermal zone. Use THERMAL_WEIGHT_DEFAULT for the</span></span><br><span class="line"><span class="comment"> *		default value</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This interface function bind a thermal cooling device to the certain trip</span></span><br><span class="line"><span class="comment"> * point of a thermal zone device.</span></span><br><span class="line"><span class="comment"> * This function is usually called in the thermal zone device .bind callback.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: 0 on success, the proper error value otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">thermal_zone_bind_cooling_device</span><span class="params">(struct thermal_zone_device *tz,</span></span></span><br><span class="line"><span class="function"><span class="params">				     <span class="keyword">int</span> trip,</span></span></span><br><span class="line"><span class="function"><span class="params">				     struct thermal_cooling_device *cdev,</span></span></span><br><span class="line"><span class="function"><span class="params">				     <span class="keyword">unsigned</span> <span class="keyword">long</span> upper, <span class="keyword">unsigned</span> <span class="keyword">long</span> lower,</span></span></span><br><span class="line"><span class="function"><span class="params">				     <span class="keyword">unsigned</span> <span class="keyword">int</span> weight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thermal_instance</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thermal_instance</span> *<span class="title">pos</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thermal_zone_device</span> *<span class="title">pos1</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thermal_cooling_device</span> *<span class="title">pos2</span>;</span></span><br><span class="line"></span><br><span class="line">	dev = kzalloc(<span class="keyword">sizeof</span>(*dev), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	dev-&gt;tz = tz;</span><br><span class="line">	dev-&gt;cdev = cdev;</span><br><span class="line">	dev-&gt;trip = trip;</span><br><span class="line">	dev-&gt;upper = upper;</span><br><span class="line">	dev-&gt;lower = lower;</span><br><span class="line">	dev-&gt;target = THERMAL_NO_TARGET;</span><br><span class="line">	dev-&gt;weight = weight;</span><br><span class="line"></span><br><span class="line">	result = ida_simple_get(&amp;tz-&gt;ida, <span class="number">0</span>, <span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (result &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> free_mem;</span><br><span class="line"></span><br><span class="line">	dev-&gt;id = result;</span><br><span class="line">	<span class="built_in">sprintf</span>(dev-&gt;name, <span class="string">&quot;cdev%d&quot;</span>, dev-&gt;id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 暴露属性节点，并赋值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="built_in">sprintf</span>(dev-&gt;attr_name, <span class="string">&quot;cdev%d_trip_point&quot;</span>, dev-&gt;id);</span><br><span class="line">	sysfs_attr_init(&amp;dev-&gt;attr.attr);</span><br><span class="line">	dev-&gt;attr.attr.name = dev-&gt;attr_name;</span><br><span class="line">	dev-&gt;attr.attr.mode = <span class="number">0444</span>;</span><br><span class="line">	dev-&gt;attr.show = thermal_cooling_device_trip_point_show;</span><br><span class="line">	result = device_create_file(&amp;tz-&gt;device, &amp;dev-&gt;attr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">snprintf</span>(dev-&gt;upper_attr_name, THERMAL_NAME_LENGTH,</span><br><span class="line">			<span class="string">&quot;cdev%d_upper_limit&quot;</span>, dev-&gt;id);</span><br><span class="line">	sysfs_attr_init(&amp;dev-&gt;upper_attr.attr);</span><br><span class="line">	dev-&gt;upper_attr.attr.name = dev-&gt;upper_attr_name;</span><br><span class="line">	dev-&gt;upper_attr.attr.mode = <span class="number">0644</span>;</span><br><span class="line">	dev-&gt;upper_attr.show = thermal_cooling_device_upper_limit_show;</span><br><span class="line">	dev-&gt;upper_attr.store = thermal_cooling_device_upper_limit_store;</span><br><span class="line">	result = device_create_file(&amp;tz-&gt;device, &amp;dev-&gt;upper_attr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">snprintf</span>(dev-&gt;lower_attr_name, THERMAL_NAME_LENGTH,</span><br><span class="line">			<span class="string">&quot;cdev%d_lower_limit&quot;</span>, dev-&gt;id);</span><br><span class="line">	sysfs_attr_init(&amp;dev-&gt;lower_attr.attr);</span><br><span class="line">	dev-&gt;lower_attr.attr.name = dev-&gt;lower_attr_name;</span><br><span class="line">	dev-&gt;lower_attr.attr.mode = <span class="number">0644</span>;</span><br><span class="line">	dev-&gt;lower_attr.show = thermal_cooling_device_lower_limit_show;</span><br><span class="line">	dev-&gt;lower_attr.store = thermal_cooling_device_lower_limit_store;</span><br><span class="line">	result = device_create_file(&amp;tz-&gt;device, &amp;dev-&gt;lower_attr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sprintf</span>(dev-&gt;weight_attr_name, <span class="string">&quot;cdev%d_weight&quot;</span>, dev-&gt;id);</span><br><span class="line">	sysfs_attr_init(&amp;dev-&gt;weight_attr.attr);</span><br><span class="line">	dev-&gt;weight_attr.attr.name = dev-&gt;weight_attr_name;</span><br><span class="line">	dev-&gt;weight_attr.attr.mode = S_IWUSR | S_IRUGO;</span><br><span class="line">	dev-&gt;weight_attr.show = thermal_cooling_device_weight_show;</span><br><span class="line">	dev-&gt;weight_attr.store = thermal_cooling_device_weight_store;</span><br><span class="line">	result = device_create_file(&amp;tz-&gt;device, &amp;dev-&gt;weight_attr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 把 thermal zone device 和对应的 thermal cooling device 添加到thermal_instances中</span></span><br><span class="line"><span class="comment">     * 即绑定操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">if</span> (!result) &#123;</span><br><span class="line">		list_add_tail(&amp;dev-&gt;tz_node, &amp;tz-&gt;thermal_instances);</span><br><span class="line">		list_add_tail(&amp;dev-&gt;cdev_node, &amp;cdev-&gt;thermal_instances);</span><br><span class="line">		atomic_set(&amp;tz-&gt;need_update, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(thermal_zone_bind_cooling_device);</span><br></pre></td></tr></table></figure><br>然后分析 thermal_zone_device_update 函数<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thermal_zone_device_update</span><span class="params">(struct thermal_zone_device *tz,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">enum</span> thermal_notify_event event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 获取对应thermal zone device最新的温度</span></span><br><span class="line"><span class="comment">	 * 并存储上次的温度值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	update_temperature(tz);</span><br><span class="line">	---&gt;thermal_zone_get_temp(tz, &amp;temp);</span><br><span class="line">	---&gt;store_temperature(tz, temp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 设置触发温度</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	thermal_zone_set_trips(tz);</span><br><span class="line"></span><br><span class="line">	tz-&gt;notify_event = event;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; tz-&gt;trips; count++)</span><br><span class="line">		handle_thermal_trip(tz, count);</span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 根据触发类型，执行对应的函数处理函数</span></span><br><span class="line"><span class="comment">		 * critical类型对应关机/重启</span></span><br><span class="line"><span class="comment">		 * non_critical类型对应设置的governor</span></span><br><span class="line"><span class="comment">		 */</span> </span><br><span class="line">		---&gt;handle_critical_trips(tz, trip, type);</span><br><span class="line">		<span class="keyword">or</span></span><br><span class="line">		---&gt;handle_non_critical_trips(tz, trip, type);</span><br><span class="line">		</span><br><span class="line">		---&gt;monitor_thermal_zone(tz);</span><br><span class="line">			---&gt;thermal_zone_device_set_polling</span><br><span class="line">				---&gt;延时调用poll_queue工作队列，再次执行thermal_zone_device_update</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(thermal_zone_device_update);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>代码流程总结：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">thermal_init</span><br><span class="line"><span class="comment">//解析dts中的thermal zone节点，并利用解析出来的数据注册thermal zone device</span></span><br><span class="line">---&gt;of_parse_thermal_zones</span><br><span class="line">	<span class="comment">//注册thermal zone device</span></span><br><span class="line">	---&gt;thermal_zone_device_register</span><br><span class="line">		---&gt;<span class="number">1.</span>创建thermal_zoneN下面的属性节点</span><br><span class="line">		---&gt;<span class="number">2.</span>为thermal_zoneN设置新的governor</span><br><span class="line">		---&gt;<span class="number">3.</span>把该thermal_zone_device结构体添加到链表thermal_tz_list中</span><br><span class="line">		---&gt;<span class="number">4.</span>把thermal zone device 和对应的thermal cooling device进行绑定</span><br><span class="line">		---&gt;<span class="number">5.</span>初始化poll_queue工作队列</span><br><span class="line">		---&gt;<span class="number">6.</span>周期性调度工作队列poll_queue，主要作用如下</span><br><span class="line">			---&gt;a.获取thermal device zone对应的温度</span><br><span class="line">			---&gt;b.设置触发温度</span><br><span class="line">			---&gt;c.处理温度触发情况</span><br><span class="line">				---&gt;(<span class="number">1</span>).如果为critical类型，到达触发温度，执行关机/重启操作</span><br><span class="line">				---&gt;(<span class="number">2</span>).如果非critical类型，到达触发温度，执行对应的governor算法操作</span><br><span class="line">				---&gt;(<span class="number">3</span>).延时启动poll_queue工作队列，再次调用thermal_zone_device_update函数。</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h2 id="Thermal-Cooling-Device"><a href="#Thermal-Cooling-Device" class="headerlink" title="Thermal Cooling Device"></a>Thermal Cooling Device</h2><p>Thermal Cooling Device 为降温设备，可用的降温设备大致如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Cooling device</th>
<th>Ation</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU</td>
<td>CPU frequency throttling, core isolation is last mitigation level</td>
</tr>
<tr>
<td>GPU(devfreq)</td>
<td>GPU frequency throttling</td>
</tr>
<tr>
<td>Battery</td>
<td>Charge rate throttling</td>
</tr>
<tr>
<td>Regulator</td>
<td>Increase of voltage on CPU rail</td>
</tr>
<tr>
<td>Backlight</td>
<td>Display backlight throttling</td>
</tr>
<tr>
<td>Modem</td>
<td>Adjustment of peak data rates, maximum Tx power</td>
</tr>
<tr>
<td>AOP</td>
<td>Voltage restriction on CX/EBI with RPMh architecture</td>
</tr>
</tbody>
</table>
</div>
<p>它们在内核中抽象为thermal_cooling_device结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thermal_cooling_device</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">char</span> type[THERMAL_NAME_LENGTH];<span class="comment">//cooling device name</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">device</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *devdata;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">thermal_cooling_device_ops</span> *<span class="title">ops</span>;</span><span class="comment">//操作函数集</span></span><br><span class="line">	<span class="keyword">bool</span> updated; <span class="comment">/* true if the cooling device does not need update */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span> <span class="comment">/* protect thermal_instances list */</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 挂载所有thermal策略示例的链表，</span></span><br><span class="line"><span class="comment">     * 一个thermal_instances一般正常包含一个thermal zone device，一个cooling device</span></span><br><span class="line"><span class="comment">     * 和对应的触发温度，以及对应的触发措施。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">thermal_instances</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span><span class="comment">//挂载thermal cooling device的链表</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sysfs_cur_state_req;<span class="comment">//当前等级请求</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sysfs_min_state_req;<span class="comment">//最小等级请求</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里以 backlight 和 cpu 实例分析一下thermal cooling devices的整个使用流程。</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="backlight示例"><a href="#backlight示例" class="headerlink" title="backlight示例"></a>backlight示例</h3><p>首先framebuff驱动中，会调用 backlight_device_register 来注册背光驱动，在其中会调用 backlight_cdev_register 来注册backlight cooling devices，所以我们来分析一下在其中 backlight_cdev_register 的调用流程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kernel/msm<span class="number">-4.14</span>/drivers/video/backlight/backlight.c</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backlight_cdev_register</span><span class="params">(struct device *parent,</span></span></span><br><span class="line"><span class="function"><span class="params">				    struct backlight_device *bd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (of_find_property(parent-&gt;of_node, <span class="string">&quot;#cooling-cells&quot;</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		bd-&gt;cdev = thermal_of_cooling_device_register(parent-&gt;of_node,</span><br><span class="line">				(<span class="keyword">char</span> *)dev_name(&amp;bd-&gt;dev), bd, &amp;bd_cdev_ops);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thermal_of_cooling_device_register(struct device_node *np,</span><br><span class="line">				   <span class="keyword">char</span> *type, <span class="keyword">void</span> *devdata,</span><br><span class="line">				   <span class="keyword">const</span> struct thermal_cooling_device_ops *ops)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __thermal_cooling_device_register(np, type, devdata, ops);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __thermal_cooling_device_register() - register a new thermal cooling device</span></span><br><span class="line"><span class="comment"> * @np:		a pointer to a device tree node.</span></span><br><span class="line"><span class="comment"> * @type:	the thermal cooling device type.</span></span><br><span class="line"><span class="comment"> * @devdata:	device private data.</span></span><br><span class="line"><span class="comment"> * @ops:		standard thermal cooling devices callbacks.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This interface function adds a new thermal cooling device (fan/processor/...)</span></span><br><span class="line"><span class="comment"> * to /sys/class/thermal/ folder as cooling_device[0-*]. It tries to bind itself</span></span><br><span class="line"><span class="comment"> * to all the thermal zone devices registered at the same time.</span></span><br><span class="line"><span class="comment"> * It also gives the opportunity to link the cooling device to a device tree</span></span><br><span class="line"><span class="comment"> * node, so that it can be bound to a thermal zone created out of device tree.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: a pointer to the created struct thermal_cooling_device or an</span></span><br><span class="line"><span class="comment"> * ERR_PTR. Caller must check return value with IS_ERR*() helpers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">thermal_cooling_device</span> *</span></span><br><span class="line"><span class="class">__<span class="title">thermal_cooling_device_register</span>(<span class="title">struct</span> <span class="title">device_node</span> *<span class="title">np</span>,</span></span><br><span class="line"><span class="class">				  <span class="title">char</span> *<span class="title">type</span>, <span class="title">void</span> *<span class="title">devdata</span>,</span></span><br><span class="line"><span class="class">				  <span class="title">const</span> <span class="title">struct</span> <span class="title">thermal_cooling_device_ops</span> *<span class="title">ops</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thermal_cooling_device</span> *<span class="title">cdev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thermal_zone_device</span> *<span class="title">pos</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;cdev-&gt;thermal_instances);</span><br><span class="line">	</span><br><span class="line">	cdev-&gt;np = np;</span><br><span class="line">	cdev-&gt;ops = ops;</span><br><span class="line">	cdev-&gt;updated = <span class="literal">false</span>;</span><br><span class="line">	cdev-&gt;device.class = &amp;thermal_class;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 设置thermal cooling devcie使用到的属性</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	thermal_cooling_device_setup_sysfs(cdev);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 生成sys/class/thermal/cooling_deviceN/节点和里面的属性，主要属性如下</span></span><br><span class="line"><span class="comment">	 * 关于其中的属性函数设置，在对应的cooling_device驱动中，这里backlight驱动路径为</span></span><br><span class="line"><span class="comment">	 * kernel/msm-4.14/drivers/video/backlight/backlight.c</span></span><br><span class="line"><span class="comment">	 * static struct attribute *cooling_device_attrs[] = &#123;</span></span><br><span class="line"><span class="comment">	 *	&amp;dev_attr_cdev_type.attr,</span></span><br><span class="line"><span class="comment">	 * 	&amp;dev_attr_max_state.attr,</span></span><br><span class="line"><span class="comment">	 * 	&amp;dev_attr_cur_state.attr,</span></span><br><span class="line"><span class="comment">	 * 	&amp;dev_attr_min_state.attr,</span></span><br><span class="line"><span class="comment">	 *  NULL,</span></span><br><span class="line"><span class="comment">	 * 	&#125;;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dev_set_name(&amp;cdev-&gt;device, <span class="string">&quot;cooling_device%d&quot;</span>, cdev-&gt;id);</span><br><span class="line">	device_register(&amp;cdev-&gt;device);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Add &#x27;this&#x27; new cdev to the global cdev list */</span></span><br><span class="line">	list_add(&amp;cdev-&gt;node, &amp;thermal_cdev_list);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Update binding information for &#x27;this&#x27; new cdev */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 和bind_tz(tz)类似，主要功能是把thermal zone device</span></span><br><span class="line"><span class="comment">	 * 和对应的thermal cooling device联系起来</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	bind_cdev(cdev);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Update binding information for &#x27;this&#x27; new cdev */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果在注册thermal zone device中已经执行poll_queue工作队列</span></span><br><span class="line"><span class="comment">	 * 这里就直接跳过，否则调用poll_queue工作队列</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	list_for_each_entry(pos, &amp;thermal_tz_list, node)</span><br><span class="line">		<span class="keyword">if</span> (atomic_cmpxchg(&amp;pos-&gt;need_update, <span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">			thermal_zone_device_update(pos,</span><br><span class="line">						   THERMAL_EVENT_UNSPECIFIED);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cdev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">关于 thermal cooling device 的具体函数操作集如下，当thermal-engine通过调用sys/<span class="class"><span class="keyword">class</span>/<span class="title">thermal</span>/<span class="title">cooling_device</span>*/下面的属性节点来调节背光亮度时，具体就会调用对应的函数去实现。</span></span><br><span class="line"><span class="class"><span class="title">static</span> <span class="title">struct</span> <span class="title">thermal_cooling_device_ops</span> <span class="title">bd_cdev_ops</span> = &#123;</span></span><br><span class="line">	.get_max_state = bd_cdev_get_max_brightness,</span><br><span class="line">	.get_cur_state = bd_cdev_get_cur_brightness,</span><br><span class="line">	.set_cur_state = bd_cdev_set_cur_brightness,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总结：<br>thermal cooling device注册流程比较简单，大致如下：</p>
<ol>
<li>生成 “sys/class/thermal/cooling_deviceN/“ 节点和里面的属性（get_max_state，get_cur_state，set_cur_state）</li>
<li>把cdev node添加到 thermal_cdev_list 链表中</li>
<li>把thermal zone device 和thermal cooling device绑定起来</li>
<li>如果在注册thermal zone device时，已经启动poll_queue工作队列，这里就不调用，否则调用poll_queue工作队列来检测温度，执行对应动作。</li>
</ol>
<p>当温度到达某个 thermal_instances 中thermal zone device对应的触发温度，该触发温度如果绑定的thermal cooling device 为backlight，则调用backlight中的set_cur_state函数设置背光为对应的级别。</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="cpufreq示例"><a href="#cpufreq示例" class="headerlink" title="cpufreq示例"></a>cpufreq示例</h3><p>首先分析cpufreq注册为thermal cooling device的软件流程,主要是通过在 qcom-cpufreq.c 中的 msm_cpufreq_ready函数调用of_cpufreq_cooling_register来完成的，所以我们来分析核心函数of_cpufreq_cooling_register。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * of_cpufreq_cooling_register - function to create cpufreq cooling device.</span></span><br><span class="line"><span class="comment"> * @np: a valid struct device_node to the cooling device device tree node</span></span><br><span class="line"><span class="comment"> * @policy: cpufreq policy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This interface function registers the cpufreq cooling device with the name</span></span><br><span class="line"><span class="comment"> * &quot;thermal-cpufreq-%x&quot;. This api can support multiple instances of cpufreq</span></span><br><span class="line"><span class="comment"> * cooling devices. Using this API, the cpufreq cooling device will be</span></span><br><span class="line"><span class="comment"> * linked to the device tree node provided.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: a valid struct thermal_cooling_device pointer on success,</span></span><br><span class="line"><span class="comment"> * on failure, it returns a corresponding ERR_PTR().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thermal_cooling_device</span> *</span></span><br><span class="line"><span class="class"><span class="title">of_cpufreq_cooling_register</span>(<span class="title">struct</span> <span class="title">device_node</span> *<span class="title">np</span>,</span></span><br><span class="line"><span class="class">			    <span class="title">struct</span> <span class="title">cpufreq_policy</span> *<span class="title">policy</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">if</span> (!np)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __cpufreq_cooling_register(np, policy, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __cpufreq_cooling_register - helper function to create cpufreq cooling device</span></span><br><span class="line"><span class="comment"> * @np: a valid struct device_node to the cooling device device tree node</span></span><br><span class="line"><span class="comment"> * @policy: cpufreq policy</span></span><br><span class="line"><span class="comment"> * Normally this should be same as cpufreq policy-&gt;related_cpus.</span></span><br><span class="line"><span class="comment"> * @capacitance: dynamic power coefficient for these cpus</span></span><br><span class="line"><span class="comment"> * @plat_static_func: function to calculate the static power consumed by these</span></span><br><span class="line"><span class="comment"> *                    cpus (optional)</span></span><br><span class="line"><span class="comment"> * @plat_mitig_func: function that does the mitigation by changing the</span></span><br><span class="line"><span class="comment"> *                   frequencies (Optional). By default, cpufreq framework will</span></span><br><span class="line"><span class="comment"> *                   be notified of the new limits.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This interface function registers the cpufreq cooling device with the name</span></span><br><span class="line"><span class="comment"> * &quot;thermal-cpufreq-%x&quot;. This api can support multiple instances of cpufreq</span></span><br><span class="line"><span class="comment"> * cooling devices. It also gives the opportunity to link the cooling device</span></span><br><span class="line"><span class="comment"> * with a device tree node, in order to bind it via the thermal DT code.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: a valid struct thermal_cooling_device pointer on success,</span></span><br><span class="line"><span class="comment"> * on failure, it returns a corresponding ERR_PTR().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * of_cpufreq_cooling_register调用__cpufreq_cooling_register时</span></span><br><span class="line"><span class="comment"> * 传入的后3个参数分别为0,NULL,NULL</span></span><br><span class="line"><span class="comment"> * 即capacitance = 0,plat_static_func和plat_ops为NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">thermal_cooling_device</span> *</span></span><br><span class="line"><span class="class">__<span class="title">cpufreq_cooling_register</span>(<span class="title">struct</span> <span class="title">device_node</span> *<span class="title">np</span>,</span></span><br><span class="line"><span class="class">			<span class="title">struct</span> <span class="title">cpufreq_policy</span> *<span class="title">policy</span>, <span class="title">u32</span> <span class="title">capacitance</span>,</span></span><br><span class="line"><span class="class">			<span class="title">get_static_t</span> <span class="title">plat_static_func</span>,</span></span><br><span class="line"><span class="class">			<span class="title">struct</span> <span class="title">cpu_cooling_ops</span> *<span class="title">plat_ops</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thermal_cooling_device</span> *<span class="title">cdev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_cooling_device</span> *<span class="title">cpufreq_cdev</span>;</span></span><br><span class="line">	<span class="keyword">char</span> dev_name[THERMAL_NAME_LENGTH];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> freq, i, num_cpus, cpu_idx;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thermal_cooling_device_ops</span> *<span class="title">cooling_ops</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> first;</span><br><span class="line">    </span><br><span class="line">	cpufreq_cdev = kzalloc(<span class="keyword">sizeof</span>(*cpufreq_cdev), GFP_KERNEL);</span><br><span class="line">	</span><br><span class="line">	cpufreq_cdev-&gt;policy = policy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 从dts中解析出cpu_idx赋值给cpu_id. */</span></span><br><span class="line">	cpufreq_cdev-&gt;cpu_id = <span class="number">-1</span>;</span><br><span class="line">	for_each_cpu(cpu_idx, policy-&gt;related_cpus) &#123;</span><br><span class="line">		<span class="keyword">if</span> (np == of_cpu_device_node_get(cpu_idx)) &#123;</span><br><span class="line">			cpufreq_cdev-&gt;cpu_id = cpu_idx;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Last level will indicate the core will be isolated. */</span></span><br><span class="line">	cpufreq_cdev-&gt;max_level = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	cpufreq_cdev-&gt;freq_table = kmalloc_array(cpufreq_cdev-&gt;max_level,</span><br><span class="line">					<span class="keyword">sizeof</span>(*cpufreq_cdev-&gt;freq_table),</span><br><span class="line">					GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* max_level is an index */</span></span><br><span class="line">	cpufreq_cdev-&gt;max_level--;</span><br><span class="line"></span><br><span class="line">	ret = ida_simple_get(&amp;cpufreq_ida, <span class="number">0</span>, <span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">	cpufreq_cdev-&gt;id = ret;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">snprintf</span>(dev_name, <span class="keyword">sizeof</span>(dev_name), <span class="string">&quot;thermal-cpufreq-%d&quot;</span>,</span><br><span class="line">		 cpufreq_cdev-&gt;id);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fill freq-table in descending order of frequencies */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, freq = <span class="number">-1</span>; i &lt; cpufreq_cdev-&gt;max_level; i++) &#123;</span><br><span class="line">		freq = find_next_max(policy-&gt;freq_table, freq);</span><br><span class="line">		cpufreq_cdev-&gt;freq_table[i].frequency = freq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Max level index is for core isolation, set this level as zero */</span></span><br><span class="line">	cpufreq_cdev-&gt;freq_table[cpufreq_cdev-&gt;max_level].frequency = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * cpu cooling device的操作函数集如下</span></span><br><span class="line"><span class="comment">	 * static struct thermal_cooling_device_ops cpufreq_cooling_ops = &#123;</span></span><br><span class="line"><span class="comment">	 * .get_max_state = cpufreq_get_max_state,</span></span><br><span class="line"><span class="comment">	 * .get_cur_state = cpufreq_get_cur_state,</span></span><br><span class="line"><span class="comment">	 * .set_cur_state = cpufreq_set_cur_state,</span></span><br><span class="line"><span class="comment">	 * .set_min_state = cpufreq_set_min_state,</span></span><br><span class="line"><span class="comment">	 * .get_min_state = cpufreq_get_min_state,</span></span><br><span class="line"><span class="comment">	 * &#125;;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cooling_ops = &amp;cpufreq_cooling_ops;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * thermal core提供的统一API，填充相关参数，用来注册thermal cooling devces</span></span><br><span class="line"><span class="comment">	 * 在backlight示例中已分析此函数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cdev = thermal_of_cooling_device_register(np, dev_name, cpufreq_cdev,cooling_ops);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 给clipped_freq赋值freq_table中最大的频率</span></span><br><span class="line"><span class="comment">	 * 给floor_freq赋值freq_table中最小的频率</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cpufreq_cdev-&gt;clipped_freq = cpufreq_cdev-&gt;freq_table[<span class="number">0</span>].frequency;</span><br><span class="line">	cpufreq_cdev-&gt;floor_freq =</span><br><span class="line">		cpufreq_cdev-&gt;freq_table[cpufreq_cdev-&gt;max_level].frequency;</span><br><span class="line">	cpufreq_cdev-&gt;cpufreq_floor_state = cpufreq_cdev-&gt;max_level;</span><br><span class="line">	cpufreq_cdev-&gt;cdev = cdev;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Register the notifier for first cpufreq cooling device */</span></span><br><span class="line">	first = list_empty(&amp;cpufreq_cdev_list);</span><br><span class="line">	list_add(&amp;cpufreq_cdev-&gt;node, &amp;cpufreq_cdev_list);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 注册事件通知链 cpufreq_policy_notifier_list ，其中回调函数为</span></span><br><span class="line"><span class="comment">	 * thermal_cpufreq_notifier_block</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (first &amp;&amp; !cpufreq_cdev-&gt;plat_ops)</span><br><span class="line">		cpufreq_register_notifier(&amp;thermal_cpufreq_notifier_block,</span><br><span class="line">					  CPUFREQ_POLICY_NOTIFIER);</span><br><span class="line">    	---&gt;blocking_notifier_chain_register(</span><br><span class="line">				&amp;cpufreq_policy_notifier_list, nb);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 1.注册事件通知链 pm_chain_head ，其中回调函数为 cpufreq_cooling_pm_nb</span></span><br><span class="line"><span class="comment">	 * 2.初始化cpuhp_register_work工作队列，并立即调度</span></span><br><span class="line"><span class="comment">	 * ---&gt;该工作队列主要目的为设置cpu hotplug状态的回调函数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!cpuhp_registered) &#123;</span><br><span class="line">		cpuhp_registered = <span class="number">1</span>;</span><br><span class="line">		register_pm_notifier(&amp;cpufreq_cooling_pm_nb);</span><br><span class="line">		INIT_WORK(&amp;cpuhp_register_work, register_cdev);</span><br><span class="line">		queue_work(system_wq, &amp;cpuhp_register_work);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cdev;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，注册cpufreq thermal cooling device的流程和backlight基本一致，只是要执行最终对应的动作时，2者使用的函数集不同，cpufreq对应cpufreq_cooling_ops，而backlight对应bd_cdev_ops。</p>
<p>注意点：<br>关于cooling device的dts中cooling-device属性的格式如下：<br>cooling-device =&lt;&amp;<mitigation_device> <perf_ceiling> <perf_floor>&gt;;</perf_floor></perf_ceiling></mitigation_device></p>
<ul>
<li>perf_ceiling parameter is the highest allowable performance level (that is, the ceiling)</li>
<li>perf_floor is the lowest allowable performance level (that is, the floor)</li>
<li>In either case, a lower index means less mitigation and higher index means deeper mitigation; there can be<br>multiple of these levels depending on rule</li>
<li>perf_ceiling value should always be &lt;= to perf_floor</li>
</ul>
<p>其中perf_ceiling和perf_floor有2种填写类型：</p>
<ol>
<li><p>使用THERMAL_MAX_LIMIT宏，即使用相对值的方式：<br>cooling-device = &lt;&amp;CPU7 (THERMAL_MAX_LIMIT-5) (THERMAL_MAX_LIMIT-2)&gt;;<br>这里假设 cooling device的min_state为0，max_state为8，那么上面的dts的等效为<br>cooling-device = &lt;&amp;CPU7 3 6&gt;;</p>
</li>
<li><p>直接使用绝对值的方式：<br>cooling-device = &lt;&amp;modem_vdd 0 0&gt;;<br>相关详细代码可以参见如下逻辑：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* kernel/msm-4.14/drivers/thermal/thermal_core.c */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If upper or lower has a MACRO to define the mitigation state,</span></span><br><span class="line"><span class="comment">	 * based on the MACRO determine the default state to use or the</span></span><br><span class="line"><span class="comment">	 * offset from the max_state.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (upper &gt;= (THERMAL_MAX_LIMIT - max_state)) &#123;</span><br><span class="line">		<span class="comment">/* upper default max_state */</span></span><br><span class="line">		<span class="keyword">if</span> (upper == THERMAL_NO_LIMIT)</span><br><span class="line">			upper = max_state;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			upper = max_state - (THERMAL_MAX_LIMIT - upper);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lower &gt;= (THERMAL_MAX_LIMIT - max_state)) &#123;</span><br><span class="line">		<span class="comment">/* lower default 0 */</span></span><br><span class="line">		<span class="keyword">if</span> (lower == THERMAL_NO_LIMIT)</span><br><span class="line">			lower = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			lower =  max_state - (THERMAL_MAX_LIMIT - lower);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h2 id="Thermal-Governor"><a href="#Thermal-Governor" class="headerlink" title="Thermal Governor"></a>Thermal Governor</h2><p>Thermal Governor作为框架中的降温策略，主要的Governor如下，我们一一介绍</p>
<ul>
<li>user space</li>
<li>step wise</li>
<li>low_limits_floor 和 low_limits_cap</li>
</ul>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="user-space"><a href="#user-space" class="headerlink" title="user space"></a>user space</h3><p>user space算法非常简单，当相关温度触发该机制时，调用notify_user_space函数，使用uevent机制来通知thermal-engine，关于thermal-engine具体怎么接受及使用kernel发送的信息，等后面thermal-engine的章节再介绍。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * notify_user_space - Notifies user space about thermal events</span></span><br><span class="line"><span class="comment"> * @tz - thermal_zone_device</span></span><br><span class="line"><span class="comment"> * @trip - trip point index</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function notifies the user space through UEvents.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">notify_user_space</span><span class="params">(struct thermal_zone_device *tz, <span class="keyword">int</span> trip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *thermal_prop[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">	thermal_prop[<span class="number">0</span>] = kasprintf(GFP_KERNEL, <span class="string">&quot;NAME=%s&quot;</span>, tz-&gt;type);</span><br><span class="line">	thermal_prop[<span class="number">1</span>] = kasprintf(GFP_KERNEL, <span class="string">&quot;TEMP=%d&quot;</span>, tz-&gt;temperature);</span><br><span class="line">	thermal_prop[<span class="number">2</span>] = kasprintf(GFP_KERNEL, <span class="string">&quot;TRIP=%d&quot;</span>, trip);</span><br><span class="line">	thermal_prop[<span class="number">3</span>] = kasprintf(GFP_KERNEL, <span class="string">&quot;EVENT=%d&quot;</span>, tz-&gt;notify_event);</span><br><span class="line">	thermal_prop[<span class="number">4</span>] = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 发送uevent事件给thermal-engine服务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	kobject_uevent_env(&amp;tz-&gt;device.kobj, KOBJ_CHANGE, thermal_prop);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">thermal_governor</span> <span class="title">thermal_gov_user_space</span> = &#123;</span></span><br><span class="line">	.name		= <span class="string">&quot;user_space&quot;</span>,</span><br><span class="line">	.throttle	= notify_user_space,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">thermal_gov_user_space_register</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> thermal_register_governor(&amp;thermal_gov_user_space);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="step-wise"><a href="#step-wise" class="headerlink" title="step wise"></a>step wise</h3><p>step wise 策略根据当前温度和温度的趋势来动态调节温度制御等级，多用于cpu，gpu频率等级的动态调节，其策略的实现逻辑如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">step_wise_throttle</span><span class="params">(struct thermal_zone_device *tz, <span class="keyword">int</span> trip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thermal_instance</span> *<span class="title">instance</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 主要作用是通过温度趋势来决定instance-&gt;target</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	thermal_zone_trip_update(tz, trip);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 根据如下2个值来最终决定cooling device的当前状态</span></span><br><span class="line"><span class="comment">	 * cdev-&gt;sysfs_cur_state_req</span></span><br><span class="line"><span class="comment">	 * instance-&gt;target</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	list_for_each_entry(instance, &amp;tz-&gt;thermal_instances, tz_node)</span><br><span class="line">		thermal_cdev_update(instance-&gt;cdev);</span><br><span class="line">		---&gt;<span class="comment">//设置cooling devices为目标状态</span></span><br><span class="line">			cdev-&gt;ops-&gt;set_cur_state(cdev, current_target);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">thermal_governor</span> <span class="title">thermal_gov_step_wise</span> = &#123;</span></span><br><span class="line">	.name		= <span class="string">&quot;step_wise&quot;</span>,</span><br><span class="line">	.throttle	= step_wise_throttle,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">thermal_gov_step_wise_register</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> thermal_register_governor(&amp;thermal_gov_step_wise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中step wise策略核心思想是由thermal_zone_trip_update实现的，主要内容如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thermal_zone_trip_update</span><span class="params">(struct thermal_zone_device *tz, <span class="keyword">int</span> trip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> trip_temp, hyst_temp;</span><br><span class="line">	<span class="keyword">enum</span> thermal_trip_type trip_type;</span><br><span class="line">	<span class="keyword">enum</span> thermal_trend trend;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thermal_instance</span> *<span class="title">instance</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> throttle = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> old_target;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 获取therma zone 的tirp 温度和hyst温度</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (trip == THERMAL_TRIPS_NONE) &#123;</span><br><span class="line">		hyst_temp = trip_temp = tz-&gt;forced_passive;</span><br><span class="line">		trip_type = THERMAL_TRIPS_NONE;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		tz-&gt;ops-&gt;get_trip_temp(tz, trip, &amp;trip_temp);</span><br><span class="line">		<span class="keyword">if</span> (tz-&gt;ops-&gt;get_trip_hyst) &#123;</span><br><span class="line">			tz-&gt;ops-&gt;get_trip_hyst(tz, trip, &amp;hyst_temp);</span><br><span class="line">			hyst_temp = trip_temp - hyst_temp;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			hyst_temp = trip_temp;</span><br><span class="line">		&#125;</span><br><span class="line">		tz-&gt;ops-&gt;get_trip_type(tz, trip, &amp;trip_type);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 获取当前的温度趋势，trend结果如下</span></span><br><span class="line"><span class="comment">	 * THERMAL_TREND_RAISING:温度上升</span></span><br><span class="line"><span class="comment">	 * THERMAL_TREND_DROPPING:温度下降</span></span><br><span class="line"><span class="comment">	 * THERMAL_TREND_STABLE:温度平稳</span></span><br><span class="line"><span class="comment">	 * THERMAL_TREND_RAISE_FULL:应用最高等级的温度制御动作</span></span><br><span class="line"><span class="comment">	 * THERMAL_TREND_DROP_FULL：应用最低等级的温度制御动作</span></span><br><span class="line"><span class="comment">	 * 最后2种状态在当前kernel-4.19版本中并没有涉及。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	trend = get_tz_trend(tz, trip);</span><br><span class="line"></span><br><span class="line">	list_for_each_entry(instance, &amp;tz-&gt;thermal_instances, tz_node) &#123;</span><br><span class="line">		<span class="keyword">if</span> (instance-&gt;trip != trip)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		old_target = instance-&gt;target;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Step wise has to lower the mitigation only if the</span></span><br><span class="line"><span class="comment">		 * temperature goes below the hysteresis temperature.</span></span><br><span class="line"><span class="comment">		 * Atleast, it has to hold on to mitigation device lower</span></span><br><span class="line"><span class="comment">		 * limit if the temperature is above the hysteresis</span></span><br><span class="line"><span class="comment">		 * temperature.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (tz-&gt;temperature &gt;= trip_temp ||</span><br><span class="line">			(tz-&gt;temperature &gt; hyst_temp &amp;&amp;</span><br><span class="line">			 old_target != THERMAL_NO_TARGET))</span><br><span class="line">			throttle = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			throttle = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果温度高于触发温度</span></span><br><span class="line"><span class="comment">		 *    a. 温度趋势为 THERMAL_TREND_RAISING</span></span><br><span class="line"><span class="comment">		 *    ---&gt;提升温度制御动作</span></span><br><span class="line"><span class="comment">		 *    b. 温度趋势 THERMAL_TREND_DROPPING</span></span><br><span class="line"><span class="comment">		 *    ---&gt;不处理</span></span><br><span class="line"><span class="comment">		 *    c. 温度趋势 THERMAL_TREND_RAISE_FULL</span></span><br><span class="line"><span class="comment">         *    ---&gt;使用最高等级的温度制御动作</span></span><br><span class="line"><span class="comment">		 *    a. 温度趋势为 THERMAL_TREND_DROP_FULL</span></span><br><span class="line"><span class="comment">		 *    ---&gt;使用最低等级的温度制御动作</span></span><br><span class="line"><span class="comment">		 *    </span></span><br><span class="line"><span class="comment">		 * 如果温度低于触发温度</span></span><br><span class="line"><span class="comment">		 *    a. 温度趋势为 THERMAL_TREND_RAISING</span></span><br><span class="line"><span class="comment">		 *    ---&gt;不处理</span></span><br><span class="line"><span class="comment">		 *    b. 温度趋势 THERMAL_TREND_DROPPING</span></span><br><span class="line"><span class="comment">		 *    ---&gt;降低温度制御等级，</span></span><br><span class="line"><span class="comment">		 *    ---&gt;如果已经为最低温度制御等级，停止thermal instance策略</span></span><br><span class="line"><span class="comment">		 *    c. 温度趋势 THERMAL_TREND_RAISE_FULL</span></span><br><span class="line"><span class="comment">         *    ---&gt;不处理</span></span><br><span class="line"><span class="comment">		 *    a. 温度趋势为 THERMAL_TREND_DROP_FULL</span></span><br><span class="line"><span class="comment">		 *    ---&gt;使用最低等级的温度制御动作</span></span><br><span class="line"><span class="comment">		 *    ---&gt;如果已经为最低等级温度制御等级，停止thermal instance策略</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		instance-&gt;target = get_target_state(instance, trend, throttle);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 初始化完成，并且温度制御目标等级未发生变化，跳过</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (instance-&gt;initialized &amp;&amp; old_target == instance-&gt;target)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">			</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 根据instance-&gt;target来更新tz-&gt;passive的值</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!instance-&gt;initialized) &#123;</span><br><span class="line">			<span class="keyword">if</span> (instance-&gt;target != THERMAL_NO_TARGET) &#123;</span><br><span class="line">				trace_thermal_zone_trip(tz, trip, trip_type,</span><br><span class="line">							<span class="literal">true</span>);</span><br><span class="line">				update_passive_instance(tz, trip_type, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* Activate a passive thermal instance */</span></span><br><span class="line">			<span class="keyword">if</span> (old_target == THERMAL_NO_TARGET &amp;&amp;</span><br><span class="line">				instance-&gt;target != THERMAL_NO_TARGET) &#123;</span><br><span class="line">				trace_thermal_zone_trip(tz, trip, trip_type,</span><br><span class="line">							<span class="literal">true</span>);</span><br><span class="line">				update_passive_instance(tz, trip_type, <span class="number">1</span>);</span><br><span class="line">			<span class="comment">/* Deactivate a passive thermal instance */</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (old_target != THERMAL_NO_TARGET &amp;&amp;</span><br><span class="line">				instance-&gt;target == THERMAL_NO_TARGET) &#123;</span><br><span class="line">				trace_thermal_zone_trip(tz, trip, trip_type,</span><br><span class="line">							<span class="literal">false</span>);</span><br><span class="line">				update_passive_instance(tz, trip_type, <span class="number">-1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		instance-&gt;initialized = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		instance-&gt;cdev-&gt;updated = <span class="literal">false</span>; <span class="comment">/* cdev needs update */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;tz-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>step wise机制的逻辑框图大致如下：<br><img src="/2021/01/05/Thermal_Core_Framework_Architecture/step_wise.PNG" alt="step wise机制"></p>
<p>如果dts中某个实例的cooling-device属性中的perf_ceiling与perf_floor相等时，当触发实例时，该算法直接设置相关cooling devices的等级为定值，不进行动态变化。</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="low-limits-floor-和-low-limits-cap"><a href="#low-limits-floor-和-low-limits-cap" class="headerlink" title="low_limits_floor 和 low_limits_cap"></a>low_limits_floor 和 low_limits_cap</h3><ul>
<li>low_limits_floor handles VDD restriction by placing a perf floor on cooling device</li>
<li>low_limits_cap handles SOC and VBat conditions by placing a perf ceiling on cooling device</li>
</ul>
<p>low_limits_floor 和 low_limits_cap 为一类别算法，在如下代码中可以看出，low_limits_floor 相关结构体只是多了”.min_state_throttle = 1”一行代码，导致他们的处理逻辑不一致。</p>
<ul>
<li>low_limits_floor 当检测到thermal zone温度低于触发温度时,将instance-&gt;target设置为最高cooling device制御级别，如果该值小于cdev-&gt;sysfs_min_state_req（这里的min state对应cooling device的最高制御），则重新设置cooling device的最高温度制御状态，即 cooling the device floor state为当前instance-&gt;target的值。</li>
<li>low_limits_cap 当检测到thermal zone温度低于触发温度时,将instance-&gt;target设置为最高cooling device制御级别，如果该值大于当前的cooling device等级，则设置当前温度制御等级的值为instance-&gt;target的值。<br>详细代码流程如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">low_limits_throttle</span><span class="params">(struct thermal_zone_device *tz, <span class="keyword">int</span> trip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thermal_instance</span> *<span class="title">instance</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 主要作用是通过温度是否低于触发温度来决定instance-&gt;target</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	thermal_zone_trip_update(tz, trip);</span><br><span class="line"></span><br><span class="line">	list_for_each_entry(instance, &amp;tz-&gt;thermal_instances, tz_node)</span><br><span class="line">		thermal_cdev_update(instance-&gt;cdev);</span><br><span class="line">		---&gt;<span class="comment">//low_limits_floor算法，替换cooling device 的floor state</span></span><br><span class="line">			cdev-&gt;ops-&gt;set_min_state(cdev, min_target);</span><br><span class="line">		[<span class="keyword">or</span>]</span><br><span class="line">		---&gt;<span class="comment">//low_limits_cap算法,替换cooling device的ceiling state</span></span><br><span class="line">			cdev-&gt;ops-&gt;set_cur_state(cdev, current_target);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">thermal_governor</span> <span class="title">thermal_gov_low_limits_floor</span> = &#123;</span></span><br><span class="line">	.name		= <span class="string">&quot;low_limits_floor&quot;</span>,</span><br><span class="line">	.throttle	= low_limits_throttle,</span><br><span class="line">	.min_state_throttle = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">thermal_governor</span> <span class="title">thermal_gov_low_limits_cap</span> = &#123;</span></span><br><span class="line">	.name		= <span class="string">&quot;low_limits_cap&quot;</span>,</span><br><span class="line">	.throttle	= low_limits_throttle,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thermal_zone_trip_update</span><span class="params">(struct thermal_zone_device *tz, <span class="keyword">int</span> trip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> trip_temp, trip_hyst;</span><br><span class="line">	<span class="keyword">enum</span> thermal_trip_type trip_type;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thermal_instance</span> *<span class="title">instance</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> throttle;</span><br><span class="line">	<span class="keyword">int</span> old_target;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 获取therma zone 的tirp 温度和hyst温度</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	tz-&gt;ops-&gt;get_trip_temp(tz, trip, &amp;trip_temp);</span><br><span class="line">	tz-&gt;ops-&gt;get_trip_type(tz, trip, &amp;trip_type);</span><br><span class="line">	<span class="keyword">if</span> (tz-&gt;ops-&gt;get_trip_hyst) &#123;</span><br><span class="line">		tz-&gt;ops-&gt;get_trip_hyst(tz, trip, &amp;trip_hyst);</span><br><span class="line">		trip_hyst = trip_temp + trip_hyst;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		trip_hyst = trip_temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;tz-&gt;lock);</span><br><span class="line"></span><br><span class="line">	list_for_each_entry(instance, &amp;tz-&gt;thermal_instances, tz_node) &#123;</span><br><span class="line">		<span class="keyword">if</span> (instance-&gt;trip != trip)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 	 * 获取therma zone 温度低于触发温度时，设置throttle为true</span></span><br><span class="line"><span class="comment">	 	 * 同时设置instance-&gt;target为最高制御等级限制行为</span></span><br><span class="line"><span class="comment">	 	 */</span></span><br><span class="line">		<span class="keyword">if</span> ((tz-&gt;temperature &lt;= trip_temp) ||</span><br><span class="line">			(instance-&gt;target != THERMAL_NO_TARGET</span><br><span class="line">				&amp;&amp; tz-&gt;temperature &lt; trip_hyst))</span><br><span class="line">			throttle = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			throttle = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		old_target = instance-&gt;target;</span><br><span class="line">		instance-&gt;target = (throttle) ? instance-&gt;upper</span><br><span class="line">					: THERMAL_NO_TARGET;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (instance-&gt;initialized &amp;&amp; old_target == instance-&gt;target)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 根据instance-&gt;target来更新tz-&gt;passive的值</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!instance-&gt;initialized) &#123;</span><br><span class="line">			<span class="keyword">if</span> (instance-&gt;target != THERMAL_NO_TARGET) &#123;</span><br><span class="line">				trace_thermal_zone_trip(tz, trip, trip_type,</span><br><span class="line">							<span class="literal">true</span>);</span><br><span class="line">				tz-&gt;passive += <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (old_target == THERMAL_NO_TARGET &amp;&amp;</span><br><span class="line">				instance-&gt;target != THERMAL_NO_TARGET) &#123;</span><br><span class="line">				trace_thermal_zone_trip(tz, trip, trip_type,</span><br><span class="line">							<span class="literal">true</span>);</span><br><span class="line">				tz-&gt;passive += <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (old_target != THERMAL_NO_TARGET &amp;&amp;</span><br><span class="line">				instance-&gt;target == THERMAL_NO_TARGET) &#123;</span><br><span class="line">				trace_thermal_zone_trip(tz, trip, trip_type,</span><br><span class="line">							<span class="literal">false</span>);</span><br><span class="line">				tz-&gt;passive -= <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		instance-&gt;initialized = <span class="literal">true</span>;</span><br><span class="line">		instance-&gt;cdev-&gt;updated = <span class="literal">false</span>; <span class="comment">/* cdev needs update */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;tz-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法代码流程如上，比较简单，我们这里用 CPU 和 BCL 来举例说明low_limits_floor 和 low_limits_cap的具体流程。</p>
<p>CPU 示例：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cpu<span class="number">-1</span><span class="number">-0</span>-lowf &#123;</span><br><span class="line">		polling-delay-passive = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">		polling-delay = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">		thermal-governor = <span class="string">&quot;low_limits_floor&quot;</span>;</span><br><span class="line">		thermal-sensors = &lt;&amp;tsens0 <span class="number">9</span>&gt;;</span><br><span class="line">		wake-capable-sensor;</span><br><span class="line">		tracks-low;</span><br><span class="line">		trips &#123;</span><br><span class="line">			cpu4_lowf_trip: cpu4-lowf-trip &#123;</span><br><span class="line">				temperature = &lt;<span class="number">5000</span>&gt;;</span><br><span class="line">				hysteresis = &lt;<span class="number">5000</span>&gt;;</span><br><span class="line">				type = <span class="string">&quot;passive&quot;</span>;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">		cooling-maps &#123;</span><br><span class="line">			cpu0_cdev &#123;</span><br><span class="line">				trip = &lt;&amp;cpu4_lowf_trip&gt;;</span><br><span class="line">				cooling-device = &lt;&amp;CPU0 (THERMAL_MAX_LIMIT<span class="number">-5</span>)</span><br><span class="line">							(THERMAL_MAX_LIMIT<span class="number">-5</span>)&gt;;</span><br><span class="line">			&#125;;</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">			</span><br><span class="line">            cpu7_cdev &#123;</span><br><span class="line">				trip = &lt;&amp;cpu4_lowf_trip&gt;;</span><br><span class="line">				cooling-device = &lt;&amp;CPU7 (THERMAL_MAX_LIMIT<span class="number">-5</span>)</span><br><span class="line">							(THERMAL_MAX_LIMIT<span class="number">-5</span>)&gt;;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">		&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>此段dts的目的为</p>
<ol>
<li>注册一个名字为 cpu-1-0-lowf 的thermal zone</li>
<li>此thermal zone没有使用轮询方式，而是 type为 passive 来主动进行温度制御</li>
<li>算法使用low_limits_floor</li>
<li>使用的cpu内部tsens0 id为9的sensor</li>
<li>设置温度触发点为5摄氏度，滞后值也为5摄氏度</li>
<li>假设该平台，CPU max state为8，min state为0，当sensor温度低于5摄氏度时，查看当前的cdev-&gt;sysfs_min_state_req（这里的min state对应cooling device的最高制御），如果【max_state - (THERMAL_MAX_LIMIT - lower) = 3】小于cdev-&gt;sysfs_min_state_req，则重新设置cooling dev的floor state 为3。主要作用为低温时，减少对CPU频率上限的限制。</li>
</ol>
<p>BCL battery voltage控制示例<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pmi632-vbat-lvl0 &#123;</span><br><span class="line">	polling-delay-passive = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">	polling-delay = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">	thermal-governor = <span class="string">&quot;low_limits_cap&quot;</span>;</span><br><span class="line">	thermal-sensors = &lt;&amp;bcl_sensor <span class="number">2</span>&gt;;</span><br><span class="line">	wake-capable-sensor;</span><br><span class="line">	tracks-low;</span><br><span class="line"></span><br><span class="line">	trips &#123;</span><br><span class="line">		pmi632_vbat_lvl0: vbat-lvl0 &#123;</span><br><span class="line">			temperature = &lt;<span class="number">3000</span>&gt;;</span><br><span class="line">			hysteresis = &lt;<span class="number">100</span>&gt;;</span><br><span class="line">			type = <span class="string">&quot;passive&quot;</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>此段dts的目的为</p>
<ol>
<li>注册一个名字为 pmi632-vbat-lvl0的thermal zone</li>
<li>此thermal zone没有使用轮询方式，而是 type为 passive 来主动进行温度制御</li>
<li>算法使用 low_limits_cap</li>
<li>使用的bcl_sensor id为2的sensor，虚构的sensor，实际是读取的电压值，单位为mV</li>
<li>设置sensor触发值为3v，滞后值为0.1v</li>
<li>当sensor值低于3v时，触发某些动作，由于此平台默认没有动作，所以没有cooling-maps部分，我们可以根据实际项目情况添加。</li>
</ol>
<p>BCL battery soc控制示例<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">soc &#123;</span><br><span class="line">	polling-delay-passive = &lt;<span class="number">100</span>&gt;;</span><br><span class="line">	polling-delay = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">	thermal-governor = <span class="string">&quot;low_limits_cap&quot;</span>;</span><br><span class="line">	thermal-sensors = &lt;&amp;bcl_soc&gt;;</span><br><span class="line">	wake-capable-sensor;</span><br><span class="line">	tracks-low;</span><br><span class="line"></span><br><span class="line">	trips &#123;</span><br><span class="line">		pmi632_low_soc: low-soc &#123;</span><br><span class="line">			temperature = &lt;<span class="number">10</span>&gt;;</span><br><span class="line">			hysteresis = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">			type = <span class="string">&quot;passive&quot;</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	cooling-maps &#123;</span><br><span class="line">		soc_cpu0 &#123;</span><br><span class="line">			trip = &lt;&amp;pmi632_low_soc&gt;;</span><br><span class="line">			cooling-device =</span><br><span class="line">				&lt;&amp;CPU0 (THERMAL_MAX_LIMIT<span class="number">-5</span>)</span><br><span class="line">					(THERMAL_MAX_LIMIT<span class="number">-5</span>)&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">		soc_cpu7 &#123;</span><br><span class="line">			trip = &lt;&amp;pmi632_low_soc&gt;;</span><br><span class="line">			cooling-device =</span><br><span class="line">				&lt;&amp;CPU7 THERMAL_MAX_LIMIT</span><br><span class="line">					THERMAL_MAX_LIMIT&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>此段dts的目的为</p>
<ol>
<li>注册一个名字为 soc 的thermal zone</li>
<li>此thermal zone没有使用轮询方式，而是 type为 passive 来主动进行温度制御</li>
<li>算法使用 low_limits_cap</li>
<li>使用的bcl_soc sensor，虚构的sensor，实际是读取电池容量百分比</li>
<li>设置sensor触发值为10%，无滞后值</li>
<li>当sensor值低于10%时，设置CPU0的cooling state为3（假设max = 8，min = 0），同时设置CPU7的cooling state为8，即hotplug该cpu。</li>
</ol>
<p>除了step wise,userspace,low_limits_floor 和 low_limits_cap算法在高通Android系统有经常使用到，<br>thermal governor还包括了power_allocator，bang_bang，fair_share算法，但是从目前高通Android代码看，基本没有使用到，所以这里就不做介绍了。</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h2 id="Thermal-Core总结"><a href="#Thermal-Core总结" class="headerlink" title="Thermal Core总结"></a>Thermal Core总结</h2><p>以使用backlight来控制亮度，step wise算法来控制温度为例，相关时序图如下：<br><img src="/2021/01/05/Thermal_Core_Framework_Architecture/Thermal_core.png" alt="Thermal Core 时序图"></p>
]]></content>
      <categories>
        <category>Thermal</category>
      </categories>
      <tags>
        <tag>Thermal</tag>
      </tags>
  </entry>
  <entry>
    <title>Android_USB_Framework_Architecture</title>
    <url>/2021/03/20/Android-USB-Framework-Architecture/</url>
    <content><![CDATA[<!-- toc -->
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>USB是通用串行总线（Universal Serial Bus）的缩写，，目前USB协议版本如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>USB Version</th>
<th>BandWidth</th>
<th>Power</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>USB1.0</td>
<td>1.5Mbps</td>
<td>5V/500mA</td>
<td>USB LOW SPEED</td>
</tr>
<tr>
<td>USB1.1</td>
<td>12Mbps</td>
<td>5V/500mA</td>
<td>USB FULL SPEED</td>
</tr>
<tr>
<td>USB2.0</td>
<td>480Mbps</td>
<td>5V/500mA</td>
<td>USB HIGH SPEED</td>
</tr>
<tr>
<td>USB3.0</td>
<td>5Gbps</td>
<td>5V/1A</td>
<td>SuperSpeed USB<br>当USB3.1推出时，USB3.0被追溯命名为 USB 3.1 Gen 1,<br>在2019年USB IF再次更新标准，USB3.0被称为USB 3.2 Gen1</td>
</tr>
<tr>
<td>USB3.1</td>
<td>10Gbps</td>
<td>5V/1A <br>12V/2A <br>20V/5A</td>
<td>SuperSpeed USB 10Gbps<br>当USB3.1推出时，按照新的标准命名为USB 3.1 Gen2，<br>在2019年USB IF再次更新标准，被重命名为USB 3.2 Gen 2</td>
</tr>
<tr>
<td>USB3.2</td>
<td>20Gbps</td>
<td>5V/1A<br>12V/2A<br>20V/5A</td>
<td>SuperSpeed USB 20Gbps<br>根据新标准，被命名为USB 3.2 Gen 2×2</td>
</tr>
<tr>
<td>USB4.0</td>
<td>40Gbps</td>
<td>5V/1A<br>12V/2A<br>20V/5A</td>
<td>只是协议，还没有配套硬件推出</td>
</tr>
</tbody>
</table>
</div>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h3><p>USB的拓扑结构如下，可以看到主要由3种元素组成：主机、Hub和设备。<br><img src="/2021/03/20/Android-USB-Framework-Architecture/USB_Topology.PNG" alt="USB_Topology"></p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="物理接口"><a href="#物理接口" class="headerlink" title="物理接口"></a>物理接口</h3><p>物理接口分为3类，USB1.x &amp;&amp; USB2.0，USB3.x和 Type-C，下面分别介绍3种类别的物理接口</p>
<p>USB1.x &amp;&amp; USB2.0:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>引脚</th>
<th>线缆颜色</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>VBUS</td>
<td>红色</td>
<td>+5V供电</td>
<td>Type-A/B</td>
</tr>
<tr>
<td>D+</td>
<td>白色</td>
<td>差分数据线</td>
<td>Type-A/B</td>
</tr>
<tr>
<td>D-</td>
<td>绿色</td>
<td>差分数据线</td>
<td>Type-A/B</td>
</tr>
<tr>
<td>GND</td>
<td>黑色</td>
<td>地</td>
<td>Type-A/B</td>
</tr>
<tr>
<td>ID</td>
<td>N/A</td>
<td>见如下备注</td>
<td>mini/micro-A/B USB</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：</span><br><span class="line">当设备检测到USB_ID信号为低时，表该设备应作为Host（主机，也称A设备）用。</span><br><span class="line">当设备检测到USB_ID信号为高时，表示该设备作为Slave(外设，也称B设备）用。</span><br><span class="line">实际的USB连接线中，是没有USB_ID这根线的。 都是在接口部分直接拉死的的。</span><br><span class="line">对于Host端，只需将连接线的USB_ID pin和地短接即可，</span><br><span class="line">对于Slave端，USB连接线的USB_ID pin是悬空的。（设备内部上拉）。</span><br></pre></td></tr></table></figure>
<p>USB3.x:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>A型连接器引脚B</th>
<th>B型连接器引脚</th>
<th>线缆颜色</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>VBUS</td>
<td>VBUS</td>
<td>红色</td>
<td>供电</td>
</tr>
<tr>
<td>D+</td>
<td>D+</td>
<td>绿色</td>
<td>USB 2.0数据差分线</td>
</tr>
<tr>
<td>D-</td>
<td>D-</td>
<td>白色</td>
<td>USB 2.0数据差分线</td>
</tr>
<tr>
<td>GND</td>
<td>GND</td>
<td>黑色</td>
<td>电源低</td>
</tr>
<tr>
<td>StdA_SSRX-</td>
<td>StdA_SSTX-</td>
<td>蓝色</td>
<td>高速数据差分对</td>
</tr>
<tr>
<td>StdA_SSR+</td>
<td>StdA_SSTX-</td>
<td>黄色</td>
<td>高速数据差分对</td>
</tr>
<tr>
<td>GND_DRAIN</td>
<td>GND_DRAIN</td>
<td>N/A</td>
<td>信号地</td>
</tr>
<tr>
<td>StdA_SSTX-</td>
<td>StdA_SSRX-</td>
<td>紫色</td>
<td>高速数据差分对</td>
</tr>
<tr>
<td>StdA_SSTX-</td>
<td>StdA_SSR+</td>
<td>橙色</td>
<td>高速数据差分对</td>
</tr>
</tbody>
</table>
</div>
<p>TYPE-C：Type-C的所有引脚定义如下图所示：<br><img src="/2021/03/20/Android-USB-Framework-Architecture/Type-C_pin.jpg" alt="Type-C_pin"></p>
<p>其中Type-C USB的插座和插头并不完全一样，相关定义如下图<br><img src="/2021/03/20/Android-USB-Framework-Architecture/Type-C_receptacle_plug.PNG" alt="Type-C_receptacle_plug"></p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h3><p>USB的4种传输模式如下，这里只是粗略列出来：<br>控制传输：用于usb枚举过程<br>批量传输：用于大容量存储设备<br>等时传输：用于音频，视频设备<br>中断传输：用于鼠标键盘等设备</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h3><p>这里只说明USB的最基础常用的描述符</p>
<ol>
<li><p>标准描述符：是指一组准备设备描述符，他们具有类似的格式</p>
<ul>
<li>设备描述符：设备描述符描述有关USB设备的一般信息。它包括信息全局适用于设备和所有设备的配置。 USB设备只有一个设备描述符。</li>
<li>配置描述符：一个USB设备可以有多种配置，不同的配置使设备工作在不同的状态下。每个配置必须有一个配置描述符， 每个配置都有一个或多个接口，每个接口都有零个或多个端点。</li>
<li>字符串描述符：在USB协议中字符串描述符是可选的。字符串描述符用于保存一些供应商名称、产品序列号等文本信息</li>
<li>接口描述符：接口是端点的集合，负责完成USB的特定功能，例如数据的输入输出。接口描述符用于描述一个接口，包含了接口的特性，如端点个数，所属设备类和子类等。</li>
<li>端点描述符：描述端点的基本属性（地址，大小等）</li>
</ul>
</li>
<li><p>HID描述符：即Human Interface Devices，人机接口设备。这类设备包括鼠标、键盘等，主要用于人与计算机进行交互，传输方式通常采用中断方式。</p>
</li>
</ol>
<p>如下为某设备的基础描述符关系图：<br><img src="/2021/03/20/Android-USB-Framework-Architecture/USB_Descriptor.jpg" alt="USB_Descriptor"></p>
<ul>
<li>该设备有2个配置：配置0和配置1</li>
<li>配置0下面有1个接口：接口0，该接口下有3个端点</li>
<li>配置1下面有2个接口：接口0和接口1</li>
<li>接口0下面有1个端点，接口1下面有2个端点</li>
</ul>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="枚举流程"><a href="#枚举流程" class="headerlink" title="枚举流程"></a>枚举流程</h3><p>枚举就是从设备读取一些信息，知道设备是什么样的设备，使用什么协议，这样Host就可以根据这些信息来加载合适的驱动程序与Device进行通信。<br>枚举流程大致如下，这里只是简单说明一下流程，后面会根据代码进行情景分析。</p>
<ol>
<li>USB设备插入Uost的根hub或者下行端口上的hub端口或者系统启动时设备上电。</li>
<li>Hub端口通过 D+/D- 的电压值来判断是全速/低速设备插入端口。</li>
<li>Host通过Get_Port_Status请求(request)给hub以了解此次状态改变的确切含义。</li>
<li>Hub端口把设备的速度信息反馈给Host。</li>
<li>Host端口通过Set_Port_Feature请求让hub端口同时拉低D+/D-来复位刚插入的USB设备。</li>
<li>如果前面Hub端口通过 D+/D- 判断设备支持全速，Host端口继续检测所连接的USB设备是否支持高速模式。</li>
<li>Host向hub发现Get_Port_Status请求，以查询设备是否复位成功。</li>
<li>Host发送Get_Descriptor获取设备描述符，主要是获取描述符的长度，然后设备再次进行复位操作。</li>
<li>Host分配地址给设备</li>
<li>Host再次发送Get_Descriptor给新的usb设备地址来读取设备描述符，之后Host再通过Get_Descriptor来读取配置描述符，接口描述符，字符描述符。</li>
<li>Host通过获取到的设备信息，整合之后，找到该设备的驱动。</li>
<li>设备驱动选择一个配置。</li>
</ol>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h2 id="Android-USB-Driver"><a href="#Android-USB-Driver" class="headerlink" title="Android USB Driver"></a>Android USB Driver</h2><p>Android USB既可以做host，起控制作用，也可以作为slave，来应答host的控制。<br>Android USB设备，当连接PC时，自身作为Devcie设备，当连接U盘时，自身作为Host设备。<br>下面我们分别从 Host 和 Device 2个方面来分析 Android USB driver。</p>
<h3 id="Android-USB-Host"><a href="#Android-USB-Host" class="headerlink" title="Android USB Host"></a>Android USB Host</h3><p>USB Host整体如下图左侧：<br><img src="/2021/03/20/Android-USB-Framework-Architecture/Android-USB-Framework-Architecture_Host.jpg" alt="Android_USB_Framework_Architecture_Host"></p>
<p>Android USB作为host时，软件架构分为如下3层：</p>
<ul>
<li>USB设备驱动：具体的USB外设设备驱动，针对不同的USB外设，需要加载不同的USB设备驱动，比如说U盘需要加载 mass storage usb设备驱动，鼠标需要加载 mouse usb设备驱动</li>
<li>USB core：Linux usb的核心协议栈，纯软件部分，为USB设备驱动程序提供一个用于访问和控制USB硬件的接口，是USB设备驱动和HCD的桥梁。</li>
<li>HCD：Host controller Driver的缩写，是对主机控制器硬件的一个抽象，USB HCD包含多种USB接口规范：UHCI,OHCI,EHCI。</li>
</ul>
<p>下面我们根据代码流程详细分析Android USB host。</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h4 id="代码路径"><a href="#代码路径" class="headerlink" title="代码路径"></a>代码路径</h4><div class="table-container">
<table>
<thead>
<tr>
<th>模块</th>
<th>路径</th>
</tr>
</thead>
<tbody>
<tr>
<td>core</td>
<td>kernel/msm-4.19/drivers/usb/core/usb.c</td>
</tr>
<tr>
<td>dwc3</td>
<td>kernel/msm-4.19/drivers/usb/dwc3/core.c</td>
</tr>
<tr>
<td>dwc3</td>
<td>kernel/msm-4.19/drivers/usb/dwc3/dwc3-msm.c</td>
</tr>
<tr>
<td>host</td>
<td>ernel/msm-4.19/drivers/usb/host/xhci-plat.c</td>
</tr>
<tr>
<td>ss-phy</td>
<td>kernel/msm-4.19/drivers/usb/phy/phy-msm-ssusb-qmp.c</td>
</tr>
<tr>
<td>hs-phy</td>
<td>kernel/msm-4.19/drivers/usb/phy/phy-msm-snps-hs.c</td>
</tr>
</tbody>
</table>
</div>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h4 id="核心结构体"><a href="#核心结构体" class="headerlink" title="核心结构体"></a>核心结构体</h4><p>在下面代码情景分析中，我们会遇到很多usb相关的结构体，下面列出核心结构体</p>
<ul>
<li>usb_device描述一个USB的device的软件信息，包括usb_device_descriptor</li>
<li>usb_device_descriptor来描述一个USB设备的device信息</li>
<li>urb_host_config描述一个USB设备config的软件信息，包括usb_config_descriptor</li>
<li>usb_config_descriptor来描述一个device的config信息</li>
<li>usb_interface描述一个接口信息</li>
<li>usb_host_interface描述一个interface的设置信息，包括usb_interface_descriptor，我们编写驱动就是针对这一层次的</li>
<li>usb_interface_descriptor来描述一个config的interface信息</li>
<li>usb_host_endpoint描述一个interdace的endpoint信息，包括usb_endpoint_descriptor，这是USB通信的最小单位，我们读写一个设备就是针对一个endpoint</li>
<li>usb_endpoint_descriptor来描述一个interface的endpoint信息</li>
</ul>
<p>它们的关系如图所示：</p>
<p><img src="/2021/03/20/Android-USB-Framework-Architecture/USB_STRUCT.PNG" alt="usb struct"></p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h4 id="dwc3"><a href="#dwc3" class="headerlink" title="dwc3"></a>dwc3</h4><p>从dwc3的角度分析USB整体流程，查看反编译的dts如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ssusb@a600000 &#123;</span><br><span class="line">	compatible = <span class="string">&quot;qcom,dwc-usb3-msm&quot;</span>;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	dwc3@a600000 &#123;</span><br><span class="line">		compatible = <span class="string">&quot;snps,dwc3&quot;</span>;</span><br><span class="line">		...</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure><br>usb dts compatible匹配，导致如下2个probe执行</p>
<ul>
<li><p>a.compatible = “snps,dwc3”</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** drivers/usb/dwc3/core.c **/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dwc3_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dwc3</span>		*<span class="title">dwc</span>;</span></span><br><span class="line">	<span class="comment">//分配内存</span></span><br><span class="line">	dwc = devm_kzalloc(dev, <span class="keyword">sizeof</span>(*dwc), GFP_KERNEL);</span><br><span class="line">	dwc-&gt;dev = dev;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//申请中断</span></span><br><span class="line">	irq = platform_get_irq(to_platform_device(dwc-&gt;dev), <span class="number">0</span>);</span><br><span class="line">	devm_request_irq(dev, irq, dwc3_interrupt, IRQF_SHARED, <span class="string">&quot;dwc3&quot;</span>, dwc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化队列</span></span><br><span class="line">	INIT_WORK(&amp;dwc-&gt;bh_work, dwc3_bh_work);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取dts中的属性，</span></span><br><span class="line">	dwc3_get_properties(dwc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//分配各种buffer的内存</span></span><br><span class="line">	dwc3_alloc_event_buffers(dwc, DWC3_EVENT_BUFFERS_SIZE);</span><br><span class="line">	dwc3_alloc_scratch_buffers(dwc);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * dts中dr_mode = otg 或者 peripheral，初始化gadget相关的寄存器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (dwc-&gt;dr_mode == USB_DR_MODE_OTG ||</span><br><span class="line">		dwc-&gt;dr_mode == USB_DR_MODE_PERIPHERAL) &#123;</span><br><span class="line">		ret = dwc3_gadget_init(dwc);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建debugfs节点编译调试</span></span><br><span class="line">	dwc3_debugfs_init(dwc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：这里主要做的一些基础的动作，如分配内存，申请中断，初始化队列，解析dts，初始化相关寄存器，创建debugfs节点等。</p>
</li>
<li><p>b.compatible = “qcom,dwc-usb3-msm”</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** drivers/usb/dwc3/dwc3-msm.c **/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dwc3_msm_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dwc3_msm</span> *<span class="title">mdwc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dwc3</span>	*<span class="title">dwc</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//分配内存</span></span><br><span class="line">	mdwc = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(*mdwc), GFP_KERNEL);</span><br><span class="line">	mdwc-&gt;dev = &amp;pdev-&gt;dev;</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;mdwc-&gt;req_complete_list);</span><br><span class="line">	INIT_WORK(&amp;mdwc-&gt;resume_work, dwc3_resume_work);</span><br><span class="line">	INIT_WORK(&amp;mdwc-&gt;restart_usb_work, dwc3_restart_usb_work);</span><br><span class="line">	INIT_WORK(&amp;mdwc-&gt;vbus_draw_work, dwc3_msm_vbus_draw_work);</span><br><span class="line">	INIT_DELAYED_WORK(&amp;mdwc-&gt;sm_work, dwc3_otg_sm_work);</span><br><span class="line">	INIT_DELAYED_WORK(&amp;mdwc-&gt;perf_vote_work, msm_dwc3_perf_vote_work);</span><br><span class="line">	INIT_DELAYED_WORK(&amp;mdwc-&gt;sdp_check, check_for_sdp_connection);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//解析dts并赋值给mdwc</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * static const struct usb_irq usb_irq_info[USB_MAX_IRQ] = &#123;</span></span><br><span class="line"><span class="comment">	 * 		&#123;&quot;hs_phy_irq&quot;, 0&#125;,</span></span><br><span class="line"><span class="comment">	 * 		&#123;&quot;pwr_event_irq&quot;, 0&#125;,</span></span><br><span class="line"><span class="comment">	 * 		&#123;&quot;dp_hs_phy_irq&quot;, 0&#125;,</span></span><br><span class="line"><span class="comment">	 * 		&#123;&quot;dm_hs_phy_irq&quot;, 0&#125;,</span></span><br><span class="line"><span class="comment">	 * 		&#123;&quot;ss_phy_irq&quot;, 0&#125;,</span></span><br><span class="line"><span class="comment">	 * &#125;;</span></span><br><span class="line"><span class="comment">	 * 申请usb_irq_info数组中的中断</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	devm_request_threaded_irq(&amp;pdev-&gt;dev,</span><br><span class="line">			mdwc-&gt;wakeup_irq[i].irq,</span><br><span class="line">			msm_dwc3_pwr_irq,</span><br><span class="line">			msm_dwc3_pwr_irq_thread,</span><br><span class="line">			irq_type,</span><br><span class="line">			mdwc-&gt;wakeup_irq[i].name, mdwc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//继续解析dts赋值给mdwc</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置notify_event = dwc3_msm_notify_event;</span></span><br><span class="line">	dwc3_set_notifier(&amp;dwc3_msm_notify_event);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//又双叒解析dts赋值给mdwc</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (dwc-&gt;dr_mode) &#123;</span><br><span class="line">	<span class="keyword">case</span> USB_DR_MODE_OTG:</span><br><span class="line">		<span class="keyword">if</span> (of_property_read_bool(node,</span><br><span class="line">					<span class="string">&quot;qcom,default-mode-host&quot;</span>)) &#123;</span><br><span class="line">			dev_dbg(mdwc-&gt;dev, <span class="string">&quot;%s: start host mode\n&quot;</span>,</span><br><span class="line">							__func__);</span><br><span class="line">			mdwc-&gt;id_state = DWC3_ID_GROUND;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (of_property_read_bool(node,</span><br><span class="line">					<span class="string">&quot;qcom,default-mode-none&quot;</span>)) &#123;</span><br><span class="line">			dev_dbg(mdwc-&gt;dev, <span class="string">&quot;%s: stay in none mode\n&quot;</span>,</span><br><span class="line">							__func__);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			dev_dbg(mdwc-&gt;dev, <span class="string">&quot;%s: start peripheral mode\n&quot;</span>,</span><br><span class="line">							__func__);</span><br><span class="line">			mdwc-&gt;vbus_active = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> USB_DR_MODE_HOST:</span><br><span class="line">		mdwc-&gt;id_state = DWC3_ID_GROUND;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> USB_DR_MODE_PERIPHERAL:</span><br><span class="line">		<span class="comment">/* fall through */</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		mdwc-&gt;vbus_active = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 根据状态来设置mdwc-&gt;inputs，每个bit的含义如下</span></span><br><span class="line"><span class="comment">	/* Input bits to state machine (mdwc-&gt;inputs) */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * #define ID			0</span></span><br><span class="line"><span class="comment">	 * #define B_SESS_VLD		1</span></span><br><span class="line"><span class="comment">	 * #define B_SUSPEND		2</span></span><br><span class="line"><span class="comment">	 * #define WAIT_FOR_LPM		3</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dwc3_ext_event_notify(mdwc);</span><br><span class="line">		---&gt;根据当前状态设置mdwc-&gt;inputs的ID，B_SESS_VLD和B_SUSPEND bit</span><br><span class="line">		---&gt;queue_delayed_work(mdwc-&gt;sm_usb_wq, &amp;mdwc-&gt;sm_work, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建属性节点</span></span><br><span class="line">	device_create_file(&amp;pdev-&gt;dev, &amp;dev_attr_mode);</span><br><span class="line">	device_create_file(&amp;pdev-&gt;dev, &amp;dev_attr_speed);</span><br><span class="line">	device_create_file(&amp;pdev-&gt;dev, &amp;dev_attr_usb_compliance_mode);</span><br><span class="line">	device_create_file(&amp;pdev-&gt;dev, &amp;dev_attr_bus_vote);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>总结：</p>
<ol>
<li>一系列初始化动作：分配内存，初始化队列，解析dts，申请中断…</li>
<li>根据当前状态设置mdwc-&gt;inputs bit，一共有4个bit：ID，B_SESS_VLD,B_SUSPEND，WAIT_FOR_LPM</li>
<li>调用队列函数 dwc3_otg_sm_work</li>
<li>创建属性节点</li>
</ol>
<p>接下来是 dwc3_otg_sm_work 函数<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** kernel/msm-4.19/drivers/usb/dwc3/dwc3-msm.c **/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dwc3_otg_sm_work - workqueue function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @w: Pointer to the dwc3 otg workqueue</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> After any change in drd_state, we must reschdule the state machine.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * dwc3状态机，根据 mdwc-&gt;inputs 和 mdwc-&gt;drd_state来确定当前的状态</span></span><br><span class="line"><span class="comment"> * 这里主要是host状态和device状态，对应函数如下</span></span><br><span class="line"><span class="comment"> * Device ---&gt; dwc3_otg_start_peripheral(mdwc, 1);</span></span><br><span class="line"><span class="comment"> * Host ---&gt; dwc3_otg_start_host(mdwc, 1);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dwc3_otg_sm_work</span><span class="params">(struct work_struct *w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dwc3_msm</span> *<span class="title">mdwc</span> = <span class="title">container_of</span>(<span class="title">w</span>, <span class="title">struct</span> <span class="title">dwc3_msm</span>, <span class="title">sm_work</span>.<span class="title">work</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dwc3</span> *<span class="title">dwc</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check OTG state */</span></span><br><span class="line">	<span class="keyword">switch</span> (mdwc-&gt;drd_state) &#123;</span><br><span class="line">	<span class="keyword">case</span> DRD_STATE_UNDEFINED:</span><br><span class="line">		...</span><br><span class="line">		mdwc-&gt;drd_state = DRD_STATE_IDLE;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">/* fall-through */</span></span><br><span class="line">	<span class="keyword">case</span> DRD_STATE_IDLE:</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">//恢复dwc3的工作</span></span><br><span class="line">		queue_delayed_work(mdwc-&gt;dwc3_wq,</span><br><span class="line">				&amp;mdwc-&gt;sdp_check,</span><br><span class="line">		msecs_to_jiffies(SDP_CONNETION_CHECK_TIME));</span><br><span class="line">		---&gt;queue_work(mdwc-&gt;dwc3_wq, &amp;mdwc-&gt;resume_work);</span><br><span class="line">		...</span><br><span class="line">		dwc3_otg_start_peripheral(mdwc, <span class="number">1</span>);</span><br><span class="line">		mdwc-&gt;drd_state = DRD_STATE_PERIPHERAL;</span><br><span class="line">		work = <span class="number">1</span>;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DRD_STATE_PERIPHERAL:</span><br><span class="line">		...</span><br><span class="line">		mdwc-&gt;drd_state = DRD_STATE_IDLE;</span><br><span class="line">		dwc3_otg_start_peripheral(mdwc, <span class="number">0</span>);</span><br><span class="line">		work = <span class="number">1</span>;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DRD_STATE_PERIPHERAL_SUSPEND:</span><br><span class="line">		...</span><br><span class="line">		mdwc-&gt;drd_state = DRD_STATE_IDLE;</span><br><span class="line">		dwc3_otg_start_peripheral(mdwc, <span class="number">0</span>);</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> DRD_STATE_HOST_IDLE:</span><br><span class="line">	</span><br><span class="line">		mdwc-&gt;drd_state = DRD_STATE_HOST;</span><br><span class="line">		dwc3_otg_start_host(mdwc, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> DRD_STATE_HOST:</span><br><span class="line">			dev_dbg(mdwc-&gt;dev, <span class="string">&quot;id || hc_died\n&quot;</span>);</span><br><span class="line">			dwc3_otg_start_host(mdwc, <span class="number">0</span>);</span><br><span class="line">			mdwc-&gt;drd_state = DRD_STATE_IDLE;</span><br><span class="line">			work = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		dev_err(mdwc-&gt;dev, <span class="string">&quot;%s: invalid otg-state\n&quot;</span>, __func__);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (work)</span><br><span class="line">		schedule_delayed_work(&amp;mdwc-&gt;sm_work, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>总结：dw3状态机，当mdwc-&gt;drd_state 发生改变，调用此队列，主要作用是根据 mdwc-&gt;drd_state 和 mdwc-&gt;inputs 来确认状态并调用对应的动作，这里最主要是根据host还是devices分别调用如下函数</p>
<ul>
<li>Host —-&gt; dwc3_otg_start_host</li>
<li>Device —-&gt; dwc3_otg_start_peripheral</li>
</ul>
<p>这里只介绍作为Host来分析代码，作Device的流程后面专门会分析<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** kernel/msm-4.19/drivers/usb/dwc3/dwc3-msm.c **/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dwc3_otg_start_host</span><span class="params">(struct dwc3_msm *mdwc, <span class="keyword">int</span> on)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dwc3</span> *<span class="title">dwc</span> = <span class="title">platform_get_drvdata</span>(<span class="title">mdwc</span>-&gt;<span class="title">dwc3</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (on) &#123;</span><br><span class="line">		dev_dbg(mdwc-&gt;dev, <span class="string">&quot;%s: turn on host\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * CONFIG_USB_MSM_SSPHY_QMP=y</span></span><br><span class="line"><span class="comment">		 * ---&gt;Enable this to support the SuperSpeed USB transceiver on MSM chips.</span></span><br><span class="line"><span class="comment">		 * CONFIG_MSM_HSUSB_PHY=y</span></span><br><span class="line"><span class="comment">		 * ---&gt;Enable this to support the HSUSB PHY on MSM chips.</span></span><br><span class="line"><span class="comment">		 * 调用SuperSpeed PHY和 high-speed PHY对应的驱动来修改连接状态</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		usb_phy_notify_connect(mdwc-&gt;ss_phy, USB_SPEED_SUPER);</span><br><span class="line">		usb_phy_notify_connect(mdwc-&gt;hs_phy, USB_SPEED_HIGH);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//注册host_nb通知事件链</span></span><br><span class="line">		mdwc-&gt;host_nb.notifier_call = dwc3_msm_host_notifier;</span><br><span class="line">		usb_register_notify(&amp;mdwc-&gt;host_nb);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//注册usbdev_nb通知事件链</span></span><br><span class="line">		mdwc-&gt;usbdev_nb.notifier_call = msm_dwc3_usbdev_notify;</span><br><span class="line">		usb_register_atomic_notify(&amp;mdwc-&gt;usbdev_nb);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">/************************************************</span></span><br><span class="line"><span class="comment">        从 xhci-plat的角度，Path如下:</span></span><br><span class="line"><span class="comment">        kernel/msm-4.9/drivers/usb/host/xhci-plat.c</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        Source:</span></span><br><span class="line"><span class="comment">        static struct platform_driver usb_xhci_driver = &#123;</span></span><br><span class="line"><span class="comment">            .probe	= xhci_plat_probe,</span></span><br><span class="line"><span class="comment">            .remove	= xhci_plat_remove,</span></span><br><span class="line"><span class="comment">            .driver	= &#123;</span></span><br><span class="line"><span class="comment">                .name = &quot;xhci-hcd&quot;,</span></span><br><span class="line"><span class="comment">                .pm = DEV_PM_OPS,</span></span><br><span class="line"><span class="comment">                .of_match_table = of_match_ptr(usb_xhci_of_match),</span></span><br><span class="line"><span class="comment">                .acpi_match_table = ACPI_PTR(usb_xhci_acpi_match),</span></span><br><span class="line"><span class="comment">            &#125;,</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        static int __init xhci_plat_init(void)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            xhci_init_driver(&amp;xhci_plat_hc_driver, &amp;xhci_plat_overrides);</span></span><br><span class="line"><span class="comment">            return platform_driver_register(&amp;usb_xhci_driver);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">		************************************************/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 这里调用platform device add 和上面的drvier 的name匹配，导致调用 xhci_plat_probe 函数</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		dwc3_host_init(dwc);</span><br><span class="line">		---&gt;platform_device_alloc(<span class="string">&quot;xhci-hcd&quot;</span>, PLATFORM_DEVID_AUTO);</span><br><span class="line">		---&gt;platform_device_add(xhci);</span><br><span class="line">	</span><br><span class="line">		mdwc-&gt;in_host_mode = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		msm_dwc3_perf_vote_update(mdwc, <span class="literal">true</span>);</span><br><span class="line">		schedule_delayed_work(&amp;mdwc-&gt;perf_vote_work,</span><br><span class="line">				msecs_to_jiffies(<span class="number">1000</span> * PM_QOS_SAMPLE_SEC));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//stop the host controller driver.</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>总结：</p>
<ol>
<li>通过 platform_device_add 来注册 “xhci-hcd” 设备。</li>
<li>在xhci-plat.c中有注册 “xhci-hcd” 驱动，这样导致对应的 xhci_plat_probe被调用。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xhci_plat_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">hc_driver</span>	*<span class="title">driver</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xhci_hcd</span>		*<span class="title">xhci</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_hcd</span>		*<span class="title">hcd</span>;</span></span><br><span class="line"></span><br><span class="line">	driver = &amp;xhci_plat_hc_driver;</span><br><span class="line"></span><br><span class="line">	irq = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	hcd = __usb_create_hcd(driver, sysdev, &amp;pdev-&gt;dev,</span><br><span class="line">			       dev_name(&amp;pdev-&gt;dev), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* convert between an HCD pointer and the corresponding EHCI_HCD */</span></span><br><span class="line">	hcd_to_xhci(hcd);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 获取并调用相关phy的初始化函数 */</span></span><br><span class="line">	hcd-&gt;usb_phy = devm_usb_get_phy_by_phandle(phydev, <span class="string">&quot;usb-phy&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	usb_phy_init(hcd-&gt;usb_phy);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 对HCD进行初始化和注册 */</span></span><br><span class="line">	usb_add_hcd(hcd, irq, IRQF_SHARED);</span><br><span class="line">		<span class="comment">/* 注册 a root hub */</span></span><br><span class="line">	---&gt; register_root_hub(hcd)</span><br><span class="line">			<span class="comment">/* 执行usb core 内部的初始化设置，构建新usb devices */</span></span><br><span class="line">		---&gt; usb_new_device (usb_dev)</span><br><span class="line">			---&gt; usb_enumerate_device(udev)</span><br><span class="line">				<span class="comment">/* </span></span><br><span class="line"><span class="comment">				 * 在hub.c中有注册 &quot;hub&quot; driver:usb_register(&amp;hub_driver)</span></span><br><span class="line"><span class="comment">				 * 2者匹配导致 hub_probe 被调用 </span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">			---&gt; device_add(&amp;udev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建device attr file */</span></span><br><span class="line">	device_create_file(&amp;pdev-&gt;dev, &amp;dev_attr_config_imod);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：这里核心函数为 usb_add_hcd，主要是对HCD进行初始化和注册，最终会把 “hub” 通过device_add添加到设备队列中。而另外在 usb/core/hub.c 中，有通过usb_register(&amp;hub_driver)来注册 “hub” 驱动，从而导致 hub_probe 被调用。</p>
<p>这里简单时序图如下:<br><img src="/2021/03/20/Android-USB-Framework-Architecture/USB_HUB_Timing_Diagram.JPG" alt="USB root  hub flow"></p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h4 id="usb-core"><a href="#usb-core" class="headerlink" title="usb core"></a>usb core</h4><p>在介绍 hub_probe 之前，我们从usb core的角度从上到下分析一下代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** kernel/msm-4.19/drivers/usb/core/usb.c **/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">usb_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	usb_init_pool_max();<span class="comment">//初始化pool_max数组</span></span><br><span class="line"></span><br><span class="line">	usb_debugfs_init();<span class="comment">//初始化usb debugfs</span></span><br><span class="line"></span><br><span class="line">	usb_acpi_register();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注册usb 总线，生成/sys/bus/usb文件目录</span></span><br><span class="line">	<span class="comment">//当我们注册一个总线的时候，他会初始化两个链表，一个用来链接总线上所有的device，一个用来链接总线上所有的driver</span></span><br><span class="line">	bus_register(&amp;usb_bus_type);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化通知链，回调函数为usb_bus_nb</span></span><br><span class="line">	bus_register_notifier(&amp;usb_bus_type, &amp;usb_bus_nb);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注册 usb 字符设备，主设备号180</span></span><br><span class="line">	usb_major_init();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注册usbfs驱动,添加到上面的usb总线上</span></span><br><span class="line">	usb_register(&amp;usbfs_driver);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注册 usb 字符设备，主设备号189</span></span><br><span class="line">	usb_devio_init();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注册usb hub驱动，重点分析该函数</span></span><br><span class="line">	usb_hub_init();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//注册usb_generic_driver驱动</span></span><br><span class="line">	usb_register_device_driver(&amp;usb_generic_driver, THIS_MODULE);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usb总线结构体</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">usb_bus_type</span> = &#123;</span></span><br><span class="line">	.name =		<span class="string">&quot;usb&quot;</span>,</span><br><span class="line">	.match =	usb_device_match,</span><br><span class="line">	.uevent =	usb_uevent,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">usb通知链回调函数结构体</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> <span class="title">usb_bus_nb</span> = &#123;</span></span><br><span class="line">	.notifier_call = usb_bus_notify,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">注册字符设备，主设备号为<span class="number">180</span>对应的结构体</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">usb_fops</span> = &#123;</span></span><br><span class="line">	.owner =	THIS_MODULE,</span><br><span class="line">	.open =		usb_open,</span><br><span class="line">	.llseek =	noop_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">usbfs 驱动相关结构体</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">usbfs_driver</span> = &#123;</span></span><br><span class="line">	.name =		<span class="string">&quot;usbfs&quot;</span>,</span><br><span class="line">	.probe =	driver_probe,</span><br><span class="line">	.disconnect =	driver_disconnect,</span><br><span class="line">	.suspend =	driver_suspend,</span><br><span class="line">	.resume =	driver_resume,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">注册字符设备，主设备号为<span class="number">189</span>对应的结构体</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">usbdev_file_operations</span> = &#123;</span></span><br><span class="line">	.owner =	  THIS_MODULE,</span><br><span class="line">	.llseek =	  usbdev_lseek,</span><br><span class="line">	.read =		  usbdev_read,</span><br><span class="line">	.poll =		  usbdev_poll,</span><br><span class="line">	.unlocked_ioctl = usbdev_ioctl,</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">	.compat_ioctl =   usbdev_compat_ioctl,</span><br><span class="line">#endif</span><br><span class="line">	.open =		  usbdev_open,</span><br><span class="line">	.release =	  usbdev_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">usb_generic_driver结构体</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device_driver</span> <span class="title">usb_generic_driver</span> = &#123;</span></span><br><span class="line">	.name =	<span class="string">&quot;usb&quot;</span>,</span><br><span class="line">	.probe = generic_probe,</span><br><span class="line">	.disconnect = generic_disconnect,</span><br><span class="line">#ifdef	CONFIG_PM</span><br><span class="line">	.suspend = generic_suspend,</span><br><span class="line">	.resume = generic_resume,</span><br><span class="line">#endif</span><br><span class="line">	.supports_autosuspend = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在usb_init函数中调用 usb_hub_init 函数，我们重点分析 usb_hub_init 该函数<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">usb hub 驱动相关结构体</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">hub_driver</span> = &#123;</span></span><br><span class="line">	.name =		<span class="string">&quot;hub&quot;</span>,</span><br><span class="line">	.probe =	hub_probe,</span><br><span class="line">	.disconnect =	hub_disconnect,</span><br><span class="line">	.suspend =	hub_suspend,</span><br><span class="line">	.resume =	hub_resume,</span><br><span class="line">	.reset_resume =	hub_reset_resume,</span><br><span class="line">	.pre_reset =	hub_pre_reset,</span><br><span class="line">	.post_reset =	hub_post_reset,</span><br><span class="line">	.unlocked_ioctl = hub_ioctl,</span><br><span class="line">	.id_table =	hub_id_table,</span><br><span class="line">	.supports_autosuspend =	<span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usb_hub_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//注册hub_driver usb驱动</span></span><br><span class="line">	usb_register(&amp;hub_driver) </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//不使用系统workqueue，创建 hub_wq workqueue</span></span><br><span class="line">	hub_wq = alloc_workqueue(<span class="string">&quot;usb_hub_wq&quot;</span>, WQ_FREEZABLE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>总结:</p>
<ol>
<li>注册hub_driver usb驱动</li>
<li>新建 usb_hub_wq workqueue</li>
</ol>
<p>在usb2.0 spec上,规定了hub的设备class和接口class都为0x9.也就是代码中定义的USB_CLASS_HUB.<br>因为root hub内置在usb控制器中,所以当开机设备检测到root hub会根据idVendor找到hub_id_table，从而添加device.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_id</span> <span class="title">hub_id_table</span>[] = &#123;</span></span><br><span class="line">    &#123; .match_flags = USB_DEVICE_ID_MATCH_VENDOR</span><br><span class="line">			| USB_DEVICE_ID_MATCH_INT_CLASS,</span><br><span class="line">      .idVendor = USB_VENDOR_GENESYS_LOGIC,</span><br><span class="line">      .bInterfaceClass = USB_CLASS_HUB,</span><br><span class="line">      .driver_info = HUB_QUIRK_CHECK_PORT_AUTOSUSPEND&#125;,</span><br><span class="line">    &#123; .match_flags = USB_DEVICE_ID_MATCH_DEV_CLASS,</span><br><span class="line">      .bDeviceClass = USB_CLASS_HUB&#125;,</span><br><span class="line">    &#123; .match_flags = USB_DEVICE_ID_MATCH_INT_CLASS,</span><br><span class="line">      .bInterfaceClass = USB_CLASS_HUB&#125;,</span><br><span class="line">    &#123; &#125;						<span class="comment">/* Terminating entry */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>从 usb core 的角度，注册hub_driver usb驱动</li>
<li>从 dw3 的角度，添加了hub device设备。</li>
</ul>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h4 id="root-hub"><a href="#root-hub" class="headerlink" title="root hub"></a>root hub</h4><p>首先说明一下整个root hub的前置流程：</p>
<p>1.在usb core子系统初始化的时候会注册一个hub的驱动（hub_driver）和一个USB设备驱动（usb_generic_driver），</p>
<p>2.当root hub作为device注册到总线后首先会匹配到usb_generic_driver驱动，这时会调用usb_generic_driver中的probe函数，也就是generic_probe()函数，</p>
<p>3.在generic_probe()函数中会配置root hub，然后再分配USB接口设备，将USB接口设备注册到总线，此时才会匹配到hub_driver驱动，</p>
<p>4.然后调用hub_driver中的probe函数，也就是hub_probe()函数，在hub_probe()函数中会为hub的这个接口下的中断端点设置urb，并且会设置一个回调函数hub_irq()。</p>
<p>首先分析 hub_probe 函数<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hub_probe</span><span class="params">(struct usb_interface *intf, <span class="keyword">const</span> struct usb_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//初始化led指示灯work</span></span><br><span class="line">	INIT_DELAYED_WORK(&amp;hub-&gt;leds, led_work);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	INIT_DELAYED_WORK(&amp;hub-&gt;init_work, <span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化hub-&gt;events</span></span><br><span class="line">	INIT_WORK(&amp;hub-&gt;events, hub_event);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置hub</span></span><br><span class="line">	hub_configure(hub, endpoint)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>接下来是hub_configure函数<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hub_configure</span><span class="params">(struct usb_hub *hub,</span></span></span><br><span class="line"><span class="function"><span class="params">	struct usb_endpoint_descriptor *endpoint)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//取得hub描述符</span></span><br><span class="line">	get_hub_descriptor(hdev, hub-&gt;descriptor);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取描述hub特性的信息</span></span><br><span class="line">	wHubCharacteristics = le16_to_cpu(hub-&gt;descriptor-&gt;wHubCharacteristics);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* FIXME for USB 3.0, skip for now */</span></span><br><span class="line">	<span class="comment">//是否是一个复合设备</span></span><br><span class="line">	<span class="keyword">if</span> ((wHubCharacteristics &amp; HUB_CHAR_COMPOUND) &amp;&amp;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//电源开关模式</span></span><br><span class="line">	<span class="keyword">switch</span> (wHubCharacteristics &amp; HUB_CHAR_LPSM) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	  <span class="comment">//过电流保护模式</span></span><br><span class="line">	<span class="keyword">switch</span> (wHubCharacteristics &amp; HUB_CHAR_OCPM) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	INIT_LIST_HEAD(&amp;hub-&gt;tt.clear_list);</span><br><span class="line">	INIT_WORK(&amp;hub-&gt;tt.clear_work, hub_tt_work);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//根据设备描述符中bDeviceProtocol字段信息设置hub-&gt;tt</span></span><br><span class="line">	<span class="keyword">switch</span> (hdev-&gt;descriptor.bDeviceProtocol) &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Note 8 FS bit times == (8 bits / 12000000 bps) ~= 666ns */</span></span><br><span class="line">	<span class="comment">//设置usb-&gt;tt.think_time</span></span><br><span class="line">	<span class="keyword">switch</span> (wHubCharacteristics &amp; HUB_CHAR_TTTT) &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断是否支持指示</span></span><br><span class="line">	<span class="keyword">if</span> (wHubCharacteristics &amp; HUB_CHAR_PORTIND) &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获得hub的状态</span></span><br><span class="line">	usb_get_status(hdev, USB_RECIP_DEVICE, <span class="number">0</span>, &amp;hubstatus);</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//对hub的电源管理</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	hub_hub_status(hub, &amp;hubstatus, &amp;hubchange);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//分配一个urb</span></span><br><span class="line">	hub-&gt;urb = usb_alloc_urb(<span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//利用usb_fill_int_urb来初始化这个urb结构，包括hub的中断服务程序hub_irq的，查询的周期等</span></span><br><span class="line">	usb_fill_int_urb(hub-&gt;urb, hdev, pipe, *hub-&gt;buffer, maxp, hub_irq,</span><br><span class="line">		hub, endpoint-&gt;bInterval);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//激活hub</span></span><br><span class="line">	hub_activate(hub, HUB_INIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>总结：<br>1.获取hub相关信息及状态<br>2.利用函数usb_alloc_urb函数来分配一个urb<br>3.利用usb_fill_int_urb来初始化这个urb结构，包括hub的中断服务程序hub_irq的，查询的周期，每当有设备连接到USB接口时，USB总线在查询hub状态信息的时候会触发hub的中断服务程 hub_irq</p>
<p>我们接下分析该函数 hub_irq<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hub_irq</span><span class="params">(struct urb *urb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> status = urb-&gt;status;</span><br><span class="line">	<span class="keyword">switch</span> (status) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* let hub_wq handle things */</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:			<span class="comment">// 端口的状态发生了变化</span></span><br><span class="line">		bits = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; urb-&gt;actual_length; ++i)</span><br><span class="line">			bits |= ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) ((*hub-&gt;buffer)[i]))</span><br><span class="line">					&lt;&lt; (i*<span class="number">8</span>);</span><br><span class="line">		hub-&gt;event_bits[<span class="number">0</span>] = bits;<span class="comment">//保存状态改变的信息</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hub-&gt;nerrors = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Something happened, let hub_wq figure it out */</span></span><br><span class="line">	<span class="comment">//唤醒hub工作队列</span></span><br><span class="line">	kick_hub_wq(hub);</span><br><span class="line">	----&gt;queue_work(hub_wq, &amp;hub-&gt;events)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面开始分析hub_wq工作队列&amp;hub-&gt;events对应的函数hub_event<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hub_event</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* deal with port status changes */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= hdev-&gt;maxchild; i++) &#123;</span><br><span class="line">	</span><br><span class="line">			port_event(hub, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* deal with hub status changes */</span></span><br><span class="line">	<span class="comment">//处理一些hub的状态改变，如power变化或者过流.</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>总结：<br>hub_irq主要调用关系如下，主要核心函数为port_event<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hub_irq</span><br><span class="line">----&gt;kick_hub_wq(hub)</span><br><span class="line">	----&gt;queue_work(hub_wq, &amp;hub-&gt;events)</span><br><span class="line">		----&gt;hub_event</span><br><span class="line">			----&gt;port_event(hub, i)</span><br></pre></td></tr></table></figure></p>
<p>接下来分析port_event函数<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">port_event</span><span class="params">(struct usb_hub *hub, <span class="keyword">int</span> port1)</span></span></span><br><span class="line"><span class="function">		__<span class="title">must_hold</span><span class="params">(&amp;port_dev-&gt;status_lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//获取hub状态变化</span></span><br><span class="line">	hub_port_status(hub, port1, &amp;portstatus, &amp;portchange)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对相应的状态进行简单处理</span></span><br><span class="line">	<span class="keyword">if</span> (portchange &amp; USB_PORT_STAT_C_CONNECTION) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (portchange &amp; USB_PORT_STAT_C_ENABLE) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (portchange &amp; USB_PORT_STAT_C_OVERCURRENT) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (portchange &amp; USB_PORT_STAT_C_RESET) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((portchange &amp; USB_PORT_STAT_C_BH_RESET)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (portchange &amp; USB_PORT_STAT_C_LINK_STATE) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (portchange &amp; USB_PORT_STAT_C_CONFIG_ERROR) &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (connect_change)</span><br><span class="line">		hub_port_connect_change(hub, port1, portstatus, portchange);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> hub_port_connect_change(struct usb_hub *hub, <span class="keyword">int</span> port1,</span><br><span class="line">					u16 portstatus, u16 portchange)</span><br><span class="line">		__must_hold(&amp;port_dev-&gt;status_lock)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	hub_port_connect(hub, port1, portstatus, portchange);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> hub_port_connect(struct usb_hub *hub, <span class="keyword">int</span> port1, u16 portstatus,</span><br><span class="line">		u16 portchange)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//为探测到的usb设备（包括普通hub，u盘等）分配并初始化udev</span></span><br><span class="line">	usb_alloc_dev(hdev, hdev-&gt;bus, port1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对这个usb_dev结构进行一系的初始化,在这个函数中会处理:Get_Description,Set_address.等操作</span></span><br><span class="line">	hub_port_init(hub, udev, port1, i);</span><br><span class="line">	----&gt;hub_set_address<span class="comment">//把地址告诉usb设备</span></span><br><span class="line">	----&gt;usb_get_device_descriptor<span class="comment">//获取usb设备描述符</span></span><br><span class="line">	----&gt;usb_get_device_descriptor<span class="comment">//再获取一次usb设备描述符</span></span><br><span class="line">	</span><br><span class="line">	usb_new_device(udev);</span><br><span class="line">	---&gt;usb_enumerate_device(udev);<span class="comment">//读取所有的描述符并解析</span></span><br><span class="line">	---&gt;announce_device(udev);<span class="comment">/* Tell the world! */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * announce_device dmesg对应的相关日志如下:</span></span><br><span class="line"><span class="comment">	 * [  313.706377] usb 2-1: udev 2, busnum 2, minor = 129</span></span><br><span class="line"><span class="comment">	 * [  313.706391] usb 2-1: New USB device found, idVendor=0951, idProduct=1666, bcdDevice= 0.01</span></span><br><span class="line"><span class="comment">	 * [  313.706399] usb 2-1: New USB device strings: Mfr=1, Product=2, SerialNumber=3</span></span><br><span class="line"><span class="comment">	 * [  313.706407] usb 2-1: Product: DataTraveler 3.0</span></span><br><span class="line"><span class="comment">	 * [  313.706415] usb 2-1: Manufacturer: Kingston</span></span><br><span class="line"><span class="comment">	 * [  313.706431] usb 2-1: SerialNumber: 60A44C42539CF310971C3C75</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//把设备放入总线的dev链表，从总线的driver链表中取出driver一一比较,usb_interface和usb_driver的id_table比较,如果匹配上了，则调用对应driver的probe函数。</span></span><br><span class="line">	----&gt; device_add(&amp;udev-&gt;dev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>总结：<br>1.获取hub状态变化，对相应的状态进行简单处理<br>2.为探测到的usb设备（包括普通hub，u盘等）分配并初始化udev<br>3.对这个usb_dev结构进行一系的初始化,在这个函数中会处理:Get_Description,Set_address.等操作<br>4.读取并解析设备描述符，并且把设备放到总结的dev链表上<br>5.将usb设备注册到系统里，这个动作将触发驱动的匹配，由于这是个usb设备，所以万能usb驱动 usb_generic_driver 会匹配上，从而generic_probe会得到执行.关于usb_generic_driver的probe函数稍后分析。</p>
<p>先来看一下usb_device_match函数<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">usb_device_match</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* devices and interfaces are handled separately */</span></span><br><span class="line">	<span class="keyword">if</span> (is_usb_device(dev)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* interface drivers never match devices */</span></span><br><span class="line">		<span class="keyword">if</span> (!is_usb_device_driver(drv))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* <span class="doctag">TODO:</span> Add real matching code */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_usb_interface(dev)) &#123;</span><br><span class="line">		struct usb_interface *intf;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> *<span class="title">usb_drv</span>;</span></span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* device drivers never match interfaces */</span></span><br><span class="line">		<span class="keyword">if</span> (is_usb_device_driver(drv))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		intf = to_usb_interface(dev);</span><br><span class="line">		usb_drv = to_usb_driver(drv);</span><br><span class="line"></span><br><span class="line">		id = usb_match_id(intf, usb_drv-&gt;id_table);</span><br><span class="line">		<span class="keyword">if</span> (id)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		id = usb_match_dynamic_id(intf, usb_drv);</span><br><span class="line">		<span class="keyword">if</span> (id)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>总结：<br>该函数的流程一条给USB设备走，一条给USB接口走。<br>1.当设备插入，枚举完成后，调用该匹配函数走设备分支，匹配usb万能驱动usb_generic_driver,在其中选择，设置配置，构造一个新的interface设备。<br>2.添加interface设备到总线，调用该匹配函数，走interface分支，在其中根据枚举中获取的信息构造的usb_device_id结构体的内容与interface驱动中的.id_table匹配，成功后调用具体的interface驱动的probe函数.</p>
<p>root hub驱动总结：<br>a.主要函数调用关系：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hub_probe</span><br><span class="line">----&gt;hub_configure</span><br><span class="line">	----&gt;hub_irq</span><br><span class="line">		----&gt;hub_event</span><br><span class="line">			----&gt;port_event</span><br><span class="line">				----&gt;hub_port_connect_change</span><br><span class="line">					----&gt;hub_port_connect</span><br></pre></td></tr></table></figure>
<p>b.root hub初始化流程：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1.</span>在usb子系统初始化的时候会注册一个hub的驱动（hub_driver）和一个USB设备驱动（usb_generic_driver），</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>当root hub的作为device注册到总线后首先会匹配到usb_generic_driver驱动，这时会调用usb_generic_driver中的probe函数，也就是 generic_probe()函数，</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>在generic_probe()函数中会配置root hub，然后再分配USB接口设备，将USB接口设备注册到总线，此时才会匹配到hub_driver驱动，</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>然后调用hub_driver中的probe函数，也就是hub_probe()函数，在hub_probe()函数中会为hub的这个接口下的中断端点设置urb，并且会设置一个回调函数hub_irq()。</span><br></pre></td></tr></table></figure></p>
<p>c.普通usb插入流程<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">当有usb设备插入时，主机控制器检测到hub端口状态的变化，会执行hub_irq函数，然后按照上面的函数调用顺序一路往下执行，实现usb设备的识别过程：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>给新设备分配地址并将该地址告诉usb设备即设置usb地址</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>.获取设备描述符</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>读取所有的描述符并解析,向总线上添加usb设备,调用usb_bus_type.mach()，走 device 分支,万能usb驱动 usb_generic_driver 会匹配上,然后调用 generic_probe 函数</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>generic_probe中选择并设置配置，并利用描述符初始化一个新的interface设备，最后device_add添加接口设备，调用usb_bus_type.mach()，走interface分支，这个时候应该就根据id_table和自己写的设备驱动进行匹配操作了），然后调用对应的usb接口驱动的probe函数</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h4 id="usb-generic-driver"><a href="#usb-generic-driver" class="headerlink" title="usb generic driver"></a>usb generic driver</h4><p>当开机时检测到root hub或者后面插入usb设备时，检测到usb设备后，首先调用 usb_device_match 走device分支，导致generic_probe被调用。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">generic_probe</span><span class="params">(struct usb_device *udev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Choose and set the configuration.  This registers the interfaces</span></span><br><span class="line"><span class="comment">	 * with the driver core and lets interface drivers bind to them.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 选择配置 */</span></span><br><span class="line">	usb_choose_configuration(udev);</span><br><span class="line">	<span class="comment">/* 核心函数，设置配置 */</span></span><br><span class="line">	usb_set_configuration(udev, c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USB device state == configured ... usable */</span></span><br><span class="line">    usb_notify_add_device(udev);</span><br><span class="line">    	<span class="comment">//调用如下事件通知链来通知相关驱动，回调函数为 dwc3_msm_host_notifier.</span></span><br><span class="line">    ---&gt;blocking_notifier_call_chain(&amp;usb_notifier_list, USB_DEVICE_ADD, udev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usb_set_configuration</span><span class="params">(struct usb_device *dev, <span class="keyword">int</span> configuration)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_host_config</span> *<span class="title">cp</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_interface</span> **<span class="title">new_interfaces</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_hcd</span> *<span class="title">hcd</span> = <span class="title">bus_to_hcd</span>(<span class="title">dev</span>-&gt;<span class="title">bus</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 申请指针数组的内存 */</span></span><br><span class="line">	new_interfaces = kmalloc_array(nintf, <span class="keyword">sizeof</span>(*new_interfaces),</span><br><span class="line">							GFP_NOIO);</span><br><span class="line">	<span class="comment">/* 申请每一项new_interfaces[n]的内存 */</span></span><br><span class="line">	new_interfaces[n] = kzalloc(<span class="keyword">sizeof</span>(struct usb_interface), </span><br><span class="line">							GFP_NOIO);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Wake up the device so we can send it the Set-Config request */</span></span><br><span class="line">	ret = usb_autoresume_device(dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if it&#x27;s already configured, clear out old state first.</span></span><br><span class="line"><span class="comment">	 * getting rid of old interfaces means unbinding their drivers.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;state != USB_STATE_ADDRESS)</span><br><span class="line">		usb_disable_device(dev, <span class="number">1</span>);	<span class="comment">/* Skip ep0 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure we have bandwidth (and available HCD resources) for this configuration. */</span></span><br><span class="line">	ret = usb_hcd_alloc_bandwidth(dev, cp, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Initialize the new interface structures and the</span></span><br><span class="line"><span class="comment">	 * hc/hcd/usbcore interface/endpoint state.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nintf; ++i) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">usb_interface_cache</span> *<span class="title">intfc</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">usb_interface</span> *<span class="title">intf</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">usb_host_interface</span> *<span class="title">alt</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 获得这个接口为0号设置,接口的默认设置总是0号设置 */</span></span><br><span class="line">		alt = usb_altnum_to_altsetting(intf, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Enable all the endpoints for an interface */</span></span><br><span class="line">		usb_enable_interface(dev, intf, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * usb_bus_type 结构体变量如下，后续会通过device_add添加intface导致</span></span><br><span class="line"><span class="comment">		 * match函数调用，继而走interface这条路.</span></span><br><span class="line"><span class="comment">		 * struct bus_type usb_bus_type = &#123;</span></span><br><span class="line"><span class="comment">		 * .name =		&quot;usb&quot;,</span></span><br><span class="line"><span class="comment">		 * .match =	usb_device_match,</span></span><br><span class="line"><span class="comment">		 * .uevent =	usb_uevent,</span></span><br><span class="line"><span class="comment">		 * .need_parent_lock =	true,</span></span><br><span class="line"><span class="comment">		 * &#125;;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		intf-&gt;dev.driver = <span class="literal">NULL</span>;</span><br><span class="line">		intf-&gt;dev.bus = &amp;usb_bus_type;</span><br><span class="line">		intf-&gt;dev.type = &amp;usb_if_device_type;</span><br><span class="line">		intf-&gt;dev.groups = usb_interface_groups;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Please refer to usb_alloc_dev() to see why we set</span></span><br><span class="line"><span class="comment">		 * dma_mask and dma_pfn_offset.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">/* init device structure. */</span></span><br><span class="line">		device_initialize(&amp;intf-&gt;dev);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* increments the reference count of the usb device structure */</span></span><br><span class="line">		usb_get_dev(dev);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 发送配置请求 */</span></span><br><span class="line">	usb_control_msg(dev, usb_sndctrlpipe(dev, <span class="number">0</span>),</span><br><span class="line">			      USB_REQ_SET_CONFIGURATION, <span class="number">0</span>, configuration, <span class="number">0</span>,</span><br><span class="line">			      <span class="literal">NULL</span>, <span class="number">0</span>, USB_CTRL_SET_TIMEOUT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置设备的状态为configured */</span></span><br><span class="line">	usb_set_device_state(dev, USB_STATE_CONFIGURED);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Now that all the interfaces are set up, register them</span></span><br><span class="line"><span class="comment">	 * to trigger binding of drivers to interfaces.  probe()</span></span><br><span class="line"><span class="comment">	 * routines may install different altsettings and may</span></span><br><span class="line"><span class="comment">	 * claim() any interfaces not yet bound.  Many class drivers</span></span><br><span class="line"><span class="comment">	 * need that: CDC, audio, video, etc.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	 <span class="comment">/*</span></span><br><span class="line"><span class="comment">	  * 将接口所对应的设备添加到系统，此动作将引发接口设备和接口驱动匹配，</span></span><br><span class="line"><span class="comment">	  * 从而引发接口设备驱动对应的probe函数</span></span><br><span class="line"><span class="comment">	  */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nintf; ++i) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">usb_interface</span> *<span class="title">intf</span> = <span class="title">cp</span>-&gt;<span class="title">interface</span>[<span class="title">i</span>];</span></span><br><span class="line">		<span class="comment">/* interface匹配，导致usb_device_match再次被调用，走interface这一路 */</span></span><br><span class="line">		ret = device_add(&amp;intf-&gt;dev);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Interface driver 和device匹配，从而usb_device_match再次被调用，走interface这一路<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">usb_device_match</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* devices and interfaces are handled separately */</span></span><br><span class="line">	<span class="keyword">if</span> (is_usb_device(dev)) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_usb_interface(dev)) &#123;</span><br><span class="line">		struct usb_interface *intf;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> *<span class="title">usb_drv</span>;</span></span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* device drivers never match interfaces */</span></span><br><span class="line">		<span class="keyword">if</span> (is_usb_device_driver(drv))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">/* 首先找到对应的usb_interface 和 usb_driver结构体 */</span></span><br><span class="line">		intf = to_usb_interface(dev);</span><br><span class="line">		usb_drv = to_usb_driver(drv);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* find first usb_device_id matching device or interface */</span></span><br><span class="line">        <span class="comment">/* 这里是查找在usb驱动通过 MODULE_DEVICE_TABLE 来注册的 usb_device_id*/</span></span><br><span class="line">		id = usb_match_id(intf, usb_drv-&gt;id_table);</span><br><span class="line">		---&gt;usb_match_one_id(interface, id)<span class="comment">/* 匹配核心函数 */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 如果在 usb_device_id 中没有找到，则在动态id链表dynids里查找*/</span></span><br><span class="line">		id = usb_match_dynamic_id(intf, usb_drv);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usb_match_one_id</span><span class="params">(struct usb_interface *interface,</span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="keyword">const</span> struct usb_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_host_interface</span> *<span class="title">intf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 获取对应的usb_host_interface和usb_device结构体 */</span></span><br><span class="line">	intf = interface-&gt;cur_altsetting;</span><br><span class="line">	dev = interface_to_usbdev(interface);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 查看设备描述符中的如下数据是否与 usb_device_id 中的数据匹配：</span></span><br><span class="line"><span class="comment">	 * idVendor，idProduct，bcdDevice，bDeviceClass，bDeviceSubClass，bDeviceProtocol</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	usb_match_device(dev, id);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 查看接口描述符中的如下数据是否与usb_device_id 中的数据匹配：</span></span><br><span class="line"><span class="comment">	 * bInterfaceClass，bInterfaceSubClass，bInterfaceProtocol，bInterfaceNumber</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	usb_match_one_id_intf(dev, intf, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当匹配到对应的 usb_device_id 时，最终导致接口的probe函数被调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">usb_probe_interface</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> *<span class="title">driver</span> = <span class="title">to_usb_driver</span>(<span class="title">dev</span>-&gt;<span class="title">driver</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_interface</span> *<span class="title">intf</span> = <span class="title">to_usb_interface</span>(<span class="title">dev</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">udev</span> = <span class="title">interface_to_usbdev</span>(<span class="title">intf</span>);</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 再次确认接口与驱动的匹配情况 */</span></span><br><span class="line">	usb_match_dynamic_id(intf, driver);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 设置状态 */</span></span><br><span class="line">	intf-&gt;condition = USB_INTERFACE_BINDING;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 设置当前接口 */</span></span><br><span class="line">	usb_set_interface(udev, intf-&gt;altsetting[<span class="number">0</span>].desc.bInterfaceNumber, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* 调用具体驱动的probe函数 */</span></span><br><span class="line">	driver-&gt;probe(intf, id);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里终于调到最终的具体驱动的probe函数了。</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h4 id="usb-skeleton-driver"><a href="#usb-skeleton-driver" class="headerlink" title="usb-skeleton  driver"></a>usb-skeleton  driver</h4><p>“./drivers/usb/usb-skeleton.c”是内核提供给usb设备驱动开发者的大容量存储usb设备的模板程序，我们简单分析该驱动的probe函数即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">skel_probe</span><span class="params">(struct usb_interface *interface,</span></span></span><br><span class="line"><span class="function"><span class="params">		      <span class="keyword">const</span> struct usb_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_skel</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_endpoint_descriptor</span> *<span class="title">bulk_in</span>, *<span class="title">bulk_out</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* allocate memory for our device state and initialize it */</span></span><br><span class="line">	dev = kzalloc(<span class="keyword">sizeof</span>(*dev), GFP_KERNEL);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 获取usb device 和 usb interface结构体 */</span></span><br><span class="line">	dev-&gt;udev = usb_get_dev(interface_to_usbdev(interface));</span><br><span class="line">	dev-&gt;interface = usb_get_intf(interface);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* set up the endpoint information */</span></span><br><span class="line">	<span class="comment">/* use only the first bulk-in and bulk-out endpoints */</span></span><br><span class="line">	retval = usb_find_common_endpoints(interface-&gt;cur_altsetting,</span><br><span class="line">			&amp;bulk_in, &amp;bulk_out, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 获取 bulk_in 端点的相关信息并赋值给dev相关结构体 */</span></span><br><span class="line">	dev-&gt;bulk_in_size = usb_endpoint_maxp(bulk_in);</span><br><span class="line">	dev-&gt;bulk_in_endpointAddr = bulk_in-&gt;bEndpointAddress;</span><br><span class="line">	dev-&gt;bulk_in_buffer = kmalloc(dev-&gt;bulk_in_size, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 给bulk_in申请分配一个urb*/</span></span><br><span class="line">	dev-&gt;bulk_in_urb = usb_alloc_urb(<span class="number">0</span>, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 获取 bulk_out 端点的相关信息*/</span></span><br><span class="line">	dev-&gt;bulk_out_endpointAddr = bulk_out-&gt;bEndpointAddress;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* save our data pointer in this interface device */</span></span><br><span class="line">	usb_set_intfdata(interface, dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we can register the device now, as it is ready */</span></span><br><span class="line">	retval = usb_register_dev(interface, &amp;skel_class);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>首先利用探测函数 usb_find_common_endpoints 来搜索到当前接口的第一个 bulk_in 和 buld_out 端点。</li>
<li>申请usb请求块urb，urb的处理全流程如下<ul>
<li>使用usb_alloc_urb来创建urb。</li>
<li>填充urb（中断端点：usb_fill_int_urb，批量端点：usb_fill_bulk_urb，控制端点：usb_fill_control_urb）。</li>
<li>在USB设备驱动中的 read/write 操作中，使用usb_submit_urb()把urb提交给USB core。</li>
<li>USB core 把urb传递给 USB Host controller。</li>
<li>USB Host controller 对 urb进行处理，进行一次到USB设备的数据传递。</li>
<li>当urb传递完成后，调用urb的回调函数，将urb控制权重新交给USB设备驱动程序。</li>
</ul>
</li>
<li>注册usb设备，后续在 read/write 函数中利用urb来传递数据。</li>
</ol>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<p>以上就是USB HOST的基础流程，大体框图如下：<br><img src="/2021/03/20/Android-USB-Framework-Architecture/USB_FLOW.jpg" alt="USB_FLOW"></p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="USB-Device"><a href="#USB-Device" class="headerlink" title="USB Device"></a>USB Device</h3><h4 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h4><p>USB设备控制器（UDC）驱动指的是，当Android USB设备最为device时，插入其他USB主机控制器时，自身作为从设备而运行在底层硬件控制器的驱动。例如，当Android手机连接PC最为MTP功能时，Android 设备作为USB设备控制器的功能，这时运行在底层的是UDC驱动，在UDC驱动之上需要另外一个驱动，作为上层应用的接口，这个驱动为File Storage驱动，称为Function驱动。</p>
<p>简略框图参见如下右侧：<br><img src="/2021/03/20/Android-USB-Framework-Architecture/Android_USB_Framework_Architecture_Device.jpg" alt="Android_USB_Framework_Architecture_Device"></p>
<p>Android USB作为device时，引入gadget概念。Android USB Gadget软件架构分为3层：(Composite Framework和USB Gadget Interface为Gadget设备层)</p>
<ul>
<li><p>USB 功能驱动层:  最主要的结构是struct usb_composite_driver，这个结构在这层定义，并且实现结构中的各个函数。</p>
</li>
<li><p>Composite Framework 层:  最主要的数据结构是 struct usb_composite_dev 与 usb_gadget_driver。前一个代表一个USB复合设备，而后一个是Gadget驱动，与UDC层交互。</p>
</li>
<li><p>USB Gadget Interface层: 功能层的功能接口(interface)，主要对应USB协议，提供统一的APIGadget Function驱动，同时和UDC进行交互，和硬件无关。</p>
</li>
<li><p>UDC层:  最主要的数据结构是struct usb_gadget，通常包含在其他结构体中。这个结构体代表了一个USB设备控制器的所有关于USB通信的信息。该层和平台硬件相关。</p>
</li>
</ul>
<p>USB Host是从 HCD —-&gt; USB Core —-&gt; USB设备驱动 自下而上的进行代码分析，我们这里对USB Device进行源码分析时，选择  USB功能驱动层 和 Gaget 设备层 —-&gt; UDC的方向进行分析。（以Mass storage为例进行源码分析）</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h4 id="代码路径-1"><a href="#代码路径-1" class="headerlink" title="代码路径"></a>代码路径</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>msm-4.19/drivers/usb/gadget/function/f_mass_storage.c</td>
</tr>
<tr>
<td></td>
<td>kernel/msm-4.19/drivers/usb/gadget/legacy/mass_storage.c</td>
</tr>
<tr>
<td></td>
<td>kernel/msm-4.19/drivers/usb/gadget/composite.c</td>
</tr>
<tr>
<td></td>
<td>kernel/msm-4.19/drivers/usb/gadget/udc/core.c</td>
</tr>
</tbody>
</table>
</div>
<h4 id="核心结构体-1"><a href="#核心结构体-1" class="headerlink" title="核心结构体"></a>核心结构体</h4><ol>
<li><p>mass storage 结构体</p>
<ul>
<li>struct fsg_dev 代表mass storage 设备</li>
<li>fsg_common 代码mass storage设备中共同结构体</li>
</ul>
</li>
<li><p>核心结构体</p>
<ul>
<li>struct usb_composite_dev  代表一个复合的usb gadget设备，一般嵌入到具体的设备自定义结构体中，这里嵌入到 fsg_common中</li>
<li>usb_composite_driver 代表复合设备绑定的驱动</li>
<li>struct usb_udc 代表一个usb device controller</li>
<li>struct usb_gadget 代表一个usb从设备</li>
<li>struct usb_gadget_driver 代表 usb 从设备对应的驱动。</li>
<li>usb_function_driver 代表 usb function功能对应的驱动</li>
<li>usb_function_instance 代表 usb function功能对应的实例</li>
<li>usb_configuration 代表一个gadget设备的配置</li>
<li>usb_function 代表配置中的一个function</li>
</ul>
</li>
</ol>
<p>核心结构体对应的关系如下：<br><img src="/2021/03/20/Android-USB-Framework-Architecture/UDC_STRUCT.bmp" alt="usb device controller struct"></p>
<h4 id="USB-功能驱动层-amp-Gaget-设备层"><a href="#USB-功能驱动层-amp-Gaget-设备层" class="headerlink" title="USB 功能驱动层 &amp; Gaget 设备层"></a>USB 功能驱动层 &amp; Gaget 设备层</h4><ul>
<li><p>function 入口函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** msm-4.19/drivers/usb/gadget/function/f_mass_storage.c **/</span></span><br><span class="line"></span><br><span class="line">DECLARE_USB_FUNCTION_INIT(mass_storage, fsg_alloc_inst, fsg_alloc);</span><br><span class="line">宏定义为：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_USB_FUNCTION_INIT(_name, _inst_alloc, _func_alloc)</span></span><br></pre></td></tr></table></figure>
<p>展开该宏定义:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_function_driver</span> <span class="title">mass_storageusb_func</span> = &#123;</span></span><br><span class="line">	.name = __stringify(mass_storage),</span><br><span class="line">	.mod  = THIS_MODULE,</span><br><span class="line">	.alloc_inst = _inst_alloc,</span><br><span class="line">	.alloc_func = _func_alloc,</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_ALIAS(<span class="string">&quot;usbfunc:&quot;</span>__stringify(mass_storage));</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">mass_storagemod_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> usb_function_register(&amp;mass_storageusb_func);</span><br><span class="line">	<span class="comment">//添加 mass_storageusb_func 到 func_list中</span></span><br><span class="line">	---&gt;list_add_tail(&amp;newf-&gt;<span class="built_in">list</span>, &amp;func_list);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">mass_storagemod_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	usb_function_unregister(&amp;mass_storageusb_func);</span><br><span class="line">&#125;</span><br><span class="line">module_init(mass_storagemod_init);</span><br><span class="line">module_exit(mass_storagemod_exit);</span><br></pre></td></tr></table></figure>
<p>从如上展开的宏定义可以看出，该宏主要作用为调用 usb_function_register 来注册 mass_storageusb_func function。<br>可以看出，这里主要是添加上层的各个usb_function_driver 到 func_list 中。</p>
</li>
<li><p>legacy 入口函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** kernel/msm-4.19/drivers/usb/gadget/legacy/mass_storage.c **/</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_composite_driver</span> <span class="title">msg_driver</span> = &#123;</span></span><br><span class="line">	.name		= <span class="string">&quot;g_mass_storage&quot;</span>,</span><br><span class="line">	.dev		= &amp;msg_device_desc,</span><br><span class="line">	.max_speed	= USB_SPEED_SUPER_PLUS,</span><br><span class="line">	.needs_serial	= <span class="number">1</span>,</span><br><span class="line">	.strings	= dev_strings,</span><br><span class="line">	.bind		= msg_bind,</span><br><span class="line">	.unbind		= msg_unbind,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">msg_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> usb_composite_probe(&amp;msg_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是利用 usb_composite_probe注册一个 name 为 g_mass_storage 的复合驱动，我们接下来重点分析具体操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * usb_composite_probe() - register a composite driver</span></span><br><span class="line"><span class="comment"> * @driver: the driver to register</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Context: single threaded during gadget setup</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is used to register drivers using the composite driver</span></span><br><span class="line"><span class="comment"> * framework.  The return value is zero, or a negative errno value.</span></span><br><span class="line"><span class="comment"> * Those values normally come from the driver&#x27;s @bind method, which does</span></span><br><span class="line"><span class="comment"> * all the work of setting up the driver to match the hardware.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On successful return, the gadget is ready to respond to requests from</span></span><br><span class="line"><span class="comment"> * the host, unless one of its components invokes usb_gadget_disconnect()</span></span><br><span class="line"><span class="comment"> * while it was binding.  That would usually be done in order to wait for</span></span><br><span class="line"><span class="comment"> * some userspace participation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/** kernel/msm-4.19/drivers/usb/gadget/composite.c **/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usb_composite_probe</span><span class="params">(struct usb_composite_driver *driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_gadget_driver</span> *<span class="title">gadget_driver</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * 把模板赋值给该usb_composite_driver的gadget_driver成员变量   </span></span><br><span class="line"><span class="comment">	 * 然后填充 gadget_driver 变量，最后通过 usb_gadget_probe_driver 注册该结构体</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	driver-&gt;gadget_driver = composite_driver_template;</span><br><span class="line">	gadget_driver = &amp;driver-&gt;gadget_driver;</span><br><span class="line"></span><br><span class="line">	gadget_driver-&gt;function =  (<span class="keyword">char</span> *) driver-&gt;name;</span><br><span class="line">	gadget_driver-&gt;driver.name = driver-&gt;name;</span><br><span class="line">	gadget_driver-&gt;max_speed = driver-&gt;max_speed;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> usb_gadget_probe_driver(gadget_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** kernel/msm-4.19/drivers/usb/gadget/udc/core.c **/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usb_gadget_probe_driver</span><span class="params">(struct usb_gadget_driver *driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_udc</span>		*<span class="title">udc</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="comment">/* 这里涉及到udc_list，其实就是框图中的UDC(这里为DW3 usb device controller)，后面在UDC章节分析*/</span></span><br><span class="line">	list_for_each_entry(udc, &amp;udc_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="comment">/* For now we take the first one */</span></span><br><span class="line">		<span class="keyword">if</span> (!udc-&gt;driver)</span><br><span class="line">			<span class="keyword">goto</span> found;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 如果在上面没有找到UDC，添加 usb_gadget_driver-&gt;pending 到 gadget_driver_pending_list 中 */</span></span><br><span class="line">	<span class="keyword">if</span> (!driver-&gt;match_existing_only) &#123;</span><br><span class="line">		list_add_tail(&amp;driver-&gt;pending, &amp;gadget_driver_pending_list);</span><br><span class="line">		pr_info(<span class="string">&quot;udc-core: couldn&#x27;t find an available UDC - added [%s] to list of pending drivers\n&quot;</span>,</span><br><span class="line">			driver-&gt;function);</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	 udc_bind_to_driver(udc, driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
</li>
</ul>
<ol>
<li>首先构造 usb_gadget_driver 结构体.</li>
<li>遍历udc_list，寻找udc 设备，高通平台对应dwc3 usb device  controller .</li>
<li>如果没有找到UDC，把 该 usb_gadget_driver 私有数据 pending 添加到 gadget_driver_pending_list 中</li>
<li>利用 udc_bind_to_driver 函数把 usb_gadget_driver（即msg_driver-&gt;gadget_driver） 与对应的 usb_udc（即dw3 usb device controller） 进行绑定。</li>
</ol>
<p>接下来对 udc_bind_to_driver 进行分析<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** kernel/msm-4.19/drivers/usb/gadget/udc/core.c **/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">udc_bind_to_driver</span><span class="params">(struct usb_udc *udc, struct usb_gadget_driver *driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 注册UDC driver g_mass_storage*/</span></span><br><span class="line">	dev_dbg(&amp;udc-&gt;dev, <span class="string">&quot;registering UDC driver [%s]\n&quot;</span>,</span><br><span class="line">			driver-&gt;function);</span><br><span class="line">	<span class="comment">/* 关联 usb_udc 和 usb_gadget_driver */</span></span><br><span class="line">	udc-&gt;driver = driver;</span><br><span class="line">	udc-&gt;dev.driver = &amp;driver-&gt;driver;</span><br><span class="line">	udc-&gt;gadget-&gt;dev.driver = &amp;driver-&gt;driver;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 当前驱动支持的最大速度 */</span></span><br><span class="line">	usb_gadget_udc_set_speed(udc, driver-&gt;max_speed);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 前面构造 usb_gadget_driver 时，</span></span><br><span class="line"><span class="comment">	 * 把 composite_driver_template 结构体赋值给 usb_gadget_driver</span></span><br><span class="line"><span class="comment">	 * 所以这里对应的bind为 composite_bind</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	driver-&gt;bind(udc-&gt;gadget, driver);</span><br><span class="line">		---&gt; composite_bind</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * 通知UDC开始启动</span></span><br><span class="line"><span class="comment">	 * 最终调用kernel/msm-4.19/drivers/usb/dwc3/gadget.c</span></span><br><span class="line"><span class="comment">	 * .udc_start		= dwc3_gadget_start,</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	usb_gadget_udc_start(udc);</span><br><span class="line">	---&gt; udc-&gt;gadget-&gt;ops-&gt;udc_start(udc-&gt;gadget, udc-&gt;driver);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * software-controlled connect to USB host</span></span><br><span class="line"><span class="comment">	 *  主要动作为使能 D+/D- 上拉，host接受到该信息后会开始进行枚举动作</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	usb_udc_connect_control(udc);</span><br><span class="line">		---&gt; usb_gadget_connect(udc-&gt;gadget);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 发送uevent事件 */</span></span><br><span class="line">	kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_CHANGE);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>总结：</p>
<ol>
<li>把 usb_udc 和 usb_gadget_driver 通过成员变量关联起来</li>
<li>设置驱动支持的最大的速度</li>
<li>第一次调用模板 composite_driver_template 的成员变量 bind —-&gt; composite_bind</li>
<li>使能 D+/D- 上拉，host接受到该信息后会开始进行枚举动作</li>
<li>发生 usb change uevent 事件</li>
</ol>
<p>接下来分析上面的核心函数 composite_bind</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** kernel/msm-4.19/drivers/usb/gadget/composite.c **/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">composite_bind</span><span class="params">(struct usb_gadget *gadget,</span></span></span><br><span class="line"><span class="function"><span class="params">		struct usb_gadget_driver *gdriver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_composite_dev</span>	*<span class="title">cdev</span>;</span></span><br><span class="line">	<span class="comment">/* 获取到 msg_driver 结构体*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_composite_driver</span>	*<span class="title">composite</span> = <span class="title">to_cdriver</span>(<span class="title">gdriver</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*初始化 confis 和gstrings 2个list*/</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;cdev-&gt;configs);</span><br><span class="line">	INIT_LIST_HEAD(&amp;cdev-&gt;gstrings);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置 usb_composite_dev	*cdev ，做一些准备动作*/</span></span><br><span class="line">	composite_dev_prepare(composite, cdev);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* composite gadget needs to assign strings for whole device (like</span></span><br><span class="line"><span class="comment">	 * serial number), register function drivers, potentially update</span></span><br><span class="line"><span class="comment">	 * power state and consumption, etc</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里调取 usb_composite_driver msg_driver中的bind函数.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	composite-&gt;bind(cdev);</span><br><span class="line">	---&gt; .bind		= msg_bind,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新设备描述符 */</span></span><br><span class="line">	update_unchanged_dev_desc(&amp;cdev-&gt;desc, composite-&gt;dev);</span><br><span class="line"></span><br><span class="line">	INFO(cdev, <span class="string">&quot;%s ready\n&quot;</span>, composite-&gt;name);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板bind函数，主要作用为调用上层对应的 usb_composite_driver 结构体的bind —-&gt; msg_bind，这里又回到 legacy 入口函数时，注册的 msg_driver的bind成员变量 —-&gt; msg_bind。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** kernel/msm-4.19/drivers/usb/gadget/legacy/mass_storage.c **/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">msg_bind</span><span class="params">(struct usb_composite_dev *cdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fsg_opts</span> *<span class="title">opts</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fsg_config</span> <span class="title">config</span>;</span></span><br><span class="line">	<span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">	fi_msg = usb_get_function_instance(<span class="string">&quot;mass_storage&quot;</span>);</span><br><span class="line">	<span class="comment">/* 请求安装 mass_storge kernel module ko */</span></span><br><span class="line">	---&gt; request_module(<span class="string">&quot;usbfunc:%s&quot;</span>, name);</span><br><span class="line">	---&gt; try_get_usb_function_instance(name);</span><br><span class="line">		<span class="comment">/* 调用 mass_storageusb_func.alloc_inst 来分配实例，</span></span><br><span class="line"><span class="comment">		/* 这里主要和mass storage相关，不具体分析*/</span></span><br><span class="line">		---&gt; fsg_alloc_inst</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 配置一些 mass storage的一些基础参数 */</span></span><br><span class="line">	fsg_config_from_params(&amp;config, &amp;mod_data, fsg_num_buffers);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 获取到 fsg_opts */</span></span><br><span class="line">	opts = fsg_opts_from_func_inst(fi_msg);</span><br><span class="line"></span><br><span class="line">	opts-&gt;no_configfs = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置一些mass storage专用的配置 */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 判断是否为OTG，如果是，对OTG设备描述符进行一些操作 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 为 dev 添加绑定一个 config */</span></span><br><span class="line">	usb_add_config(cdev, &amp;msg_config_driver, msg_do_config);</span><br><span class="line">	---&gt; usb_add_config_only(cdev, config);</span><br><span class="line">    ---&gt; bind(config);</span><br><span class="line">		---&gt; msg_do_config</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>获取 mass_storage function实例</li>
<li>设置一些mass storage的配置</li>
<li>判断是否为OTG设备，进行一些操作</li>
<li>为 dev 添加绑定一个 config，最终调用 msg_do_config 来实现</li>
</ol>
<p>接下来分析 msg_do_config<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">msg_do_config</span><span class="params">(struct usb_configuration *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * 根据name，遍历func_list中name为 mass_storage 的 function</span></span><br><span class="line"><span class="comment">	 * 在kernel/msm-4.19/drivers/usb/gadget/function/f_mass_storage.c中</span></span><br><span class="line"><span class="comment">	 * 我们有通过宏 DECLARE_USB_FUNCTION_INIT 来注册一个name为mass_storage的usb_function_driver，</span></span><br><span class="line"><span class="comment">	 * 即添加 mass_storageusb_func 到 func_list中</span></span><br><span class="line"><span class="comment">	 **/</span></span><br><span class="line">	f_msg = usb_get_function(fi_msg);</span><br><span class="line">	---&gt; fi_msg-&gt;fd-&gt;alloc_func(fi_msg);</span><br><span class="line">		<span class="comment">/* 构建fsg_dev *fsg </span></span><br><span class="line"><span class="comment">		 * fsg-&gt;function.name	= FSG_DRIVER_DESC;</span></span><br><span class="line"><span class="comment">		 * fsg-&gt;function.bind	= fsg_bind;</span></span><br><span class="line"><span class="comment">		 * fsg-&gt;function.unbind	= fsg_unbind;</span></span><br><span class="line"><span class="comment">		 * fsg-&gt;function.setup	= fsg_setup;</span></span><br><span class="line"><span class="comment">		 * fsg-&gt;function.set_alt	= fsg_set_alt;</span></span><br><span class="line"><span class="comment">		 * fsg-&gt;function.disable	= fsg_disable;</span></span><br><span class="line"><span class="comment">		 * fsg-&gt;function.free_func	= fsg_free;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		---&gt;fsg_alloc</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 为 config 添加一个function ---&gt; mass_storageusb_func */</span></span><br><span class="line">	usb_add_function(c, f_msg);</span><br><span class="line">	---&gt; f_msg-&gt;bind(config, function);</span><br><span class="line">		---&gt;fsg_bind</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>总结：</p>
<ol>
<li>遍历 func_list 中 name 为 mass_storage 的 function</li>
<li>构造一个fsg_dev，对其成员变量 function 进行赋值操作</li>
<li>为该 usb config 添加绑定如上 function，最终调用 fsg_bind 进行绑定操作。</li>
</ol>
<p>接下来看 fsg_bind 函数：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fsg_bind</span><span class="params">(struct usb_configuration *c, struct usb_function *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fsg_dev</span>		*<span class="title">fsg</span> = <span class="title">fsg_from_func</span>(<span class="title">f</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fsg_common</span>	*<span class="title">common</span> = <span class="title">fsg</span>-&gt;<span class="title">common</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_gadget</span>	*<span class="title">gadget</span> = <span class="title">c</span>-&gt;<span class="title">cdev</span>-&gt;<span class="title">gadget</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_ep</span>		*<span class="title">ep</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fsg_opts</span>		*<span class="title">opts</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Don&#x27;t allow to bind if we don&#x27;t have at least one LUN */</span></span><br><span class="line">	ret = _fsg_common_get_max_lun(common);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建 &quot;file-storage&quot; thread，并启动，这里主要和mass storage相关，不具体分析*/</span></span><br><span class="line">    common-&gt;thread_task =kthread_create(fsg_main_thread, common, <span class="string">&quot;file-storage&quot;</span>);</span><br><span class="line">    wake_up_process(common-&gt;thread_task);</span><br><span class="line">msg_bind</span><br><span class="line">	<span class="comment">/* New interface */</span></span><br><span class="line">	i = usb_interface_id(c, f);</span><br><span class="line"></span><br><span class="line">	fsg_intf_desc.bInterfaceNumber = i;</span><br><span class="line">	fsg-&gt;interface_number = i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Find all the endpoints we will use */</span></span><br><span class="line">	ep = usb_ep_autoconfig(gadget, &amp;fsg_fs_bulk_in_desc);</span><br><span class="line">	fsg-&gt;bulk_in = ep;</span><br><span class="line"></span><br><span class="line">	ep = usb_ep_autoconfig(gadget, &amp;fsg_fs_bulk_out_desc);</span><br><span class="line">	fsg-&gt;bulk_out = ep;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 根据不同的usb速度分配usb interface 和 usb endpoint描述符 */</span></span><br><span class="line">	usb_assign_descriptors(f, fsg_fs_function, fsg_hs_function,</span><br><span class="line">			fsg_ss_function, fsg_ss_function);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>mass storage最终的bind函数主要做了如下事情 ：</p>
<ol>
<li>创建并运行 file-storage 子进程</li>
<li>构建interface和endpoint，并分配他们的描述符</li>
</ol>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<p>总结：<br>USB 功能驱动层 &amp; Gaget 设备层的关系比较紧密，存在很多回调函数，下图只是列出了简单的调用关系图:<br><img src="/2021/03/20/Android-USB-Framework-Architecture/USB_Gadget_Framework.jpg" alt="USB Gadget Framework"></p>
<p>另外从上面的代码流程可以看出，mass storage一共经历了4次 bind 函数，最终实现mass storage功能。</p>
<ul>
<li><p>struct usb_gadget_driver composite_driver_template 对应的 composite_bind，所有 gadget 驱动都走这个公共函数。</p>
</li>
<li><p>struct usb_composite_driver msg_driver 对应的 msg_bind，这里回调到 上层 legacy/mass_storage.c 的mass storage的驱动。</p>
</li>
<li><p>usb_add_config 中，回调 msg_do_config，来给 dev 绑定一个 configuration</p>
</li>
<li><p>usb_add_function中，回调到 function/f_mass_storage.c 中 struct usb_function_driver mass_storageusb_func-&gt;ubs_function-&gt;bind 函数</p>
</li>
</ul>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h4 id="UDC"><a href="#UDC" class="headerlink" title="UDC"></a>UDC</h4><p>在Android USB作为Host的代码流程 dwc3_probe 函数中：<br>如果dts中dr_mode = otg 或者 peripheral，调用 dwc3_gadget_init 来初始化gadget相关的寄存器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dwc3_gadget_init - Initializes gadget related registers</span></span><br><span class="line"><span class="comment"> * @dwc: pointer to our controller context structure</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 0 on success otherwise negative errno.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dwc3_gadget_init</span><span class="params">(struct dwc3 *dwc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dwc-&gt;gadget.ops			= &amp;dwc3_gadget_ops;</span><br><span class="line">	dwc-&gt;gadget.max_speed		= USB_SPEED_SUPER;</span><br><span class="line">	dwc-&gt;gadget.speed		= USB_SPEED_UNKNOWN;</span><br><span class="line">	dwc-&gt;gadget.name		= <span class="string">&quot;dwc3-gadget&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化 OUT 和 IN 端点 */</span></span><br><span class="line">	dwc3_gadget_init_endpoints(dwc);</span><br><span class="line">	---&gt; dwc3_gadget_init_hw_endpoints(dwc, dwc-&gt;num_out_eps, <span class="number">0</span>);</span><br><span class="line">	---&gt; dwc3_gadget_init_hw_endpoints(dwc, dwc-&gt;num_in_eps, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 在udc class driver list 中增加新的 gadget:&quot;dwc3-gadget&quot; */</span></span><br><span class="line">	usb_add_gadget_udc((struct device *)dwc-&gt;dev, &amp;dwc-&gt;gadget);</span><br><span class="line">	---&gt; usb_add_gadget_udc_release(parent, gadget, <span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着分析 usb_add_gadget_udc_release 函数<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * usb_add_gadget_udc_release - adds a new gadget to the udc class driver list</span></span><br><span class="line"><span class="comment"> * @parent: the parent device to this udc. Usually the controller driver&#x27;s</span></span><br><span class="line"><span class="comment"> * device.</span></span><br><span class="line"><span class="comment"> * @gadget: the gadget to be added to the list.</span></span><br><span class="line"><span class="comment"> * @release: a gadget release function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns zero on success, negative errno otherwise.</span></span><br><span class="line"><span class="comment"> * Calls the gadget release function in the latter case.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usb_add_gadget_udc_release</span><span class="params">(struct device *parent, struct usb_gadget *gadget,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">void</span> (*release)(struct device *dev))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_udc</span>		*<span class="title">udc</span>;</span></span><br><span class="line"></span><br><span class="line">	dev_set_name(&amp;gadget-&gt;dev, <span class="string">&quot;gadget&quot;</span>);</span><br><span class="line">	INIT_WORK(&amp;gadget-&gt;work, usb_gadget_state_work);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化 gadget-&gt;dev 和 udc-&gt;dev 结构体 */</span></span><br><span class="line">	device_initialize(&amp;gadget-&gt;dev);</span><br><span class="line">	device_initialize(&amp;udc-&gt;dev);</span><br><span class="line">	</span><br><span class="line">	udc-&gt;dev.release = usb_udc_release;</span><br><span class="line">	udc-&gt;dev.class = udc_class;</span><br><span class="line">	udc-&gt;dev.groups = usb_udc_attr_groups;</span><br><span class="line">	udc-&gt;dev.parent = parent;</span><br><span class="line">	ret = dev_set_name(&amp;udc-&gt;dev, <span class="string">&quot;%s&quot;</span>, kobject_name(&amp;parent-&gt;kobj));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 把 gadget-&gt;dev 添加到gadget设备中 */</span></span><br><span class="line">	ret = device_add(&amp;gadget-&gt;dev);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* udc 和 gadget 相互建立连接 */</span></span><br><span class="line">	udc-&gt;gadget = gadget;</span><br><span class="line">	gadget-&gt;udc = udc;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 把udc，即dwc3 usb device controller 添加到 udc_list 中 */</span></span><br><span class="line">    list_add_tail(&amp;udc-&gt;<span class="built_in">list</span>, &amp;udc_list);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 把 udev-&gt;dev 添加到udc设备中 */</span></span><br><span class="line">	device_add(&amp;udc-&gt;dev);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* pick up one of pending gadget drivers */</span></span><br><span class="line">	check_pending_gadget_drivers(udc);</span><br><span class="line">	---&gt; 遍历 gadget_driver_pending_list ，根据 name 来给 udc 绑定对应的 driver</span><br><span class="line">	---&gt; udc_bind_to_driver(udc, driver);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>这里和从Gadget Driver层往下分析时调用 udc_bind_to_driver 绑定 usb_gadget_driver（即msg_driver-&gt;gadget_driver） 与对应的 usb_udc（即dw3 usb device controller） 时一致，最终把UDC和对应的驱动绑定，从而使上层gadget driver可以使用。</p>
<p>大致框图如下：</p>
<p><img src="/2021/03/20/Android-USB-Framework-Architecture/UDC_Framework.jpg" alt="UDC Framework Architecture"></p>
<h4 id="Configfs"><a href="#Configfs" class="headerlink" title="Configfs"></a>Configfs</h4><p>详情介绍可以参考 kernel 官方文档，这里只是简单介绍一下。</p>
<ul>
<li>Documentation/filesystems/configfs/configfs.txt</li>
<li>Documentation/usb/gadget_configfs.txt</li>
</ul>
<p>和 usb gadget 相关的configfs主要源码实现路径：</p>
<ul>
<li>kernel/msm-4.19/drivers/usb/gadget/configfs.c</li>
</ul>
<p>首先看下 configfs 中 和 gadget 相关的设备内容， adb 进入设备 /config/usb_gadget/g1 路径<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xxx:/config/usb_gadget/g1 <span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">./strings</span><br><span class="line">./strings/<span class="number">0x409</span></span><br><span class="line">./strings/<span class="number">0x409</span>/serialnumber <span class="comment">/*串号，使用emmc时，该值为emmc id号经过hash运算后生成的唯一值*/</span></span><br><span class="line">./strings/<span class="number">0x409</span>/product</span><br><span class="line">./strings/<span class="number">0x409</span>/manufacturer</span><br><span class="line">./configs</span><br><span class="line">./configs/c<span class="number">.1</span></span><br><span class="line">./configs/c<span class="number">.1</span>/ncm.usb0 -&gt; ../../../../usb_gadget/g1/functions/ncm.usb0</span><br><span class="line">./configs/c<span class="number">.1</span>/strings</span><br><span class="line">./configs/c<span class="number">.1</span>/strings/<span class="number">0x409</span></span><br><span class="line"><span class="comment">/* ------ 在rc文件中，写入对应的功能，即可以把相应function添加到该configuration中 ------ */</span></span><br><span class="line">./configs/c<span class="number">.1</span>/strings/<span class="number">0x409</span>/configuration </span><br><span class="line">./configs/c<span class="number">.1</span>/bmAttributes</span><br><span class="line">./configs/c<span class="number">.1</span>/MaxPower</span><br><span class="line">./functions</span><br><span class="line">./functions/ncm.usb0</span><br><span class="line">./functions/ncm.usb0/ifname</span><br><span class="line">./functions/ncm.usb0/qmult</span><br><span class="line">./functions/ncm.usb0/host_addr</span><br><span class="line">./functions/ncm.usb0/dev_addr</span><br><span class="line">./UDC <span class="comment">/*USB device controller 名字，这里为 a600000.dwc3*/</span></span><br><span class="line">./bcdUSB <span class="comment">/* 该设备遵循的USB版本号，以BCD码表示，USB1.1为0x0101，USB2.0为0x0200 */</span></span><br><span class="line">./bcdDevice <span class="comment">/*用于表示USB设备的版本号*/</span></span><br><span class="line">./idProduct <span class="comment">/* USB product ID */</span></span><br><span class="line">./idVendor <span class="comment">/* USB vendor ID */</span></span><br><span class="line">./bMaxPacketSize0 <span class="comment">/* 用于表示在USB设备中，端点0所支持最大数据包的长度，它以字节为单位 */</span></span><br><span class="line">./bDeviceProtocol <span class="comment">/* 用于表示USB设备类所采用的设备类协议，其值和bDeviceClass和bDeviceSubClass有关 */</span></span><br><span class="line">./bDeviceSubClass <span class="comment">/* 该设备所属的标准设备子类 */</span></span><br><span class="line">./bDeviceClass <span class="comment">/* 该设备所属的标准设备类 */</span></span><br></pre></td></tr></table></figure></p>
<p>在 init.msm.usb.configfs.rc 中，当 sys.usb.config 匹配为mass_storege,adb时，执行脚本如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">on property:sys.usb.ffs.ready=<span class="number">1</span> &amp;&amp; property:sys.usb.config=mass_storage,adb &amp;&amp; property:sys.usb.configfs=<span class="number">1</span></span><br><span class="line">    write /config/usb_gadget/g1/configs/b<span class="number">.1</span>/strings/<span class="number">0x409</span>/configuration <span class="string">&quot;adb_msc&quot;</span></span><br><span class="line">	...</span><br><span class="line">    write /config/usb_gadget/g1/idVendor <span class="number">0x05C6</span></span><br><span class="line">    write /config/usb_gadget/g1/idProduct <span class="number">0x9015</span></span><br><span class="line">    symlink /config/usb_gadget/g1/functions/ffs.adb /config/usb_gadget/g1/configs/b<span class="number">.1</span>/f1</span><br><span class="line">    symlink /config/usb_gadget/g1/functions/mass_storage<span class="number">.0</span> /config/usb_gadget/g1/configs/b<span class="number">.1</span>/f2</span><br><span class="line">    write /config/usb_gadget/g1/UDC $&#123;sys.usb.controller&#125;</span><br><span class="line">    setprop sys.usb.state $&#123;sys.usb.config&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，该脚本主要做了如下事情：</p>
<ul>
<li>把选择的 function 组合 写入到 /config/usb_gadget/g1/configs/b.1/strings/0x409/configuration 中</li>
<li>重写 idVendor 和 idProduct</li>
<li>把2个 function 做 link操作，映射到/config/usb_gadget/g1/configs/b.1/f1和f2</li>
<li>把usb device controller的名字写入到 /config/usb_gadget/g1/UDC</li>
<li>最后设置 sys.usb.state 为当前状态</li>
</ul>
<p>到此，我们通过设置 sys.usb.config 等属性值，就可以切换Android USB设备作为Device的功能选择。</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<p>注：此 USB 文档主要讲述了 Android USB 设备作为 Host 和Device的整体代码流程分析，其中省略掉了 OTG 部分的分析。此外，Android USB 还有如下特性没有分析，后面找机会分别介绍，这里记录一下：</p>
<ul>
<li>OTG</li>
<li>Type C</li>
<li>USB Charging &amp; PD</li>
<li>DP</li>
</ul>
]]></content>
      <categories>
        <category>usb</category>
      </categories>
      <tags>
        <tag>usb</tag>
      </tags>
  </entry>
</search>
