<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="&amp;nbsp;  &amp;nbsp;     Acronym Description     BMS battery monitoring system   RC remaing capacity.当前状态下的剩余电量，充满电时RC&#x3D;FCC   UUC unusable capacity.由于电池电阻导致的电池压降等原因而无法使用的电量   UC usable capacity.UC&#x3D;FCC-UUC">
<meta property="og:type" content="article">
<meta property="og:title" content="Qcom platform battery capacity algorithm">
<meta property="og:url" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/index.html">
<meta property="og:site_name" content="LexYoung笔记">
<meta property="og:description" content="&amp;nbsp;  &amp;nbsp;     Acronym Description     BMS battery monitoring system   RC remaing capacity.当前状态下的剩余电量，充满电时RC&#x3D;FCC   UUC unusable capacity.由于电池电阻导致的电池压降等原因而无法使用的电量   UC usable capacity.UC&#x3D;FCC-UUC">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/Voltage_Mode_BMS_Block_Diagram.PNG">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/VM-BMS_Modes_of_Operation.PNG">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/Sample_OCV-temperature-SOC_lookup_table-1.PNG">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/Sample_OCV-temperature-SOC_lookup_table-2.PNG">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/ACC_lookup_table-1.PNG">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/ACC_lookup_table-2.PNG">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/ACC_lookup_table-3.PNG">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/VM-BMS_Software_Architecture.PNG">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/qpnp_vm_bms_probe-flow-chart.PNG">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/monitor_soc_work.PNG">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/report_vm_bms_soc.PNG">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/property_interface.PNG">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/BMS_Block_Diagram.PNG">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/BMS_State_Machine_Details.PNG">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/PM8921_BMS_Linux_Android_Software_Architecture.PNG">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/Qualcomm_Battery_Gauge_Hardware_Block_Diagram.PNG">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/RAW_SOC.PNG">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/BATTERY_SOC.PNG">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/SYSTEM_SOC.PNG">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/SOC_FLOW.PNG">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/SOC_FLOW2.PNG">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/Qualcomm_Battery_Gauge_software_architecture.PNG">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/Fuel%20Gauge%20Architecture.PNG">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/FG_SOC_FLOW.PNG">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/FG_Battery_SoC.PNG">
<meta property="og:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/Battery_Model.PNG">
<meta property="article:published_time" content="2020-09-24T11:09:55.000Z">
<meta property="article:modified_time" content="2020-10-01T10:13:42.442Z">
<meta property="article:author" content="LexYoung">
<meta property="article:tag" content="Charing">
<meta property="article:tag" content="Battery">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/Voltage_Mode_BMS_Block_Diagram.PNG">

<link rel="canonical" href="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Qcom platform battery capacity algorithm | LexYoung笔记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LexYoung笔记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/24/Qcom-platform-battery-capacity-algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LexYoung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LexYoung笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Qcom platform battery capacity algorithm
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-24 19:09:55" itemprop="dateCreated datePublished" datetime="2020-09-24T19:09:55+08:00">2020-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-01 18:13:42" itemprop="dateModified" datetime="2020-10-01T18:13:42+08:00">2020-10-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Charging/" itemprop="url" rel="index"><span itemprop="name">Charging</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <!-- toc -->
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Acronym</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>BMS</td>
<td>battery monitoring system</td>
</tr>
<tr>
<td>RC</td>
<td>remaing capacity.<br>当前状态下的剩余电量，充满电时RC=FCC</td>
</tr>
<tr>
<td>UUC</td>
<td>unusable capacity.<br>由于电池电阻导致的电池压降等原因而无法使用的电量</td>
</tr>
<tr>
<td>UC</td>
<td>usable capacity.<br>UC=FCC-UUC</td>
</tr>
<tr>
<td>RUC</td>
<td>Remaining Usable Capacity。RUC=RC-UUC</td>
</tr>
<tr>
<td>SoC</td>
<td>State of Charge.<br>剩余电量与总电量的比值，SoC = RUC/UC = (RC-UUC)/(FCC-UUC)</td>
</tr>
<tr>
<td>OCV</td>
<td>Open Circuit Voltage.<br>近乎于0电流情况下的稳定电压，电池带负载工作后，需要5~30min恢复OCV。</td>
</tr>
<tr>
<td>ACC</td>
<td>Apparent Charge Capacity.<br>FCC of the battery modified by increased battery resistance due to temperature and loaded system cutoff voltage</td>
</tr>
</tbody>
</table>
</div>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<p>目前接触到的高通有关电池电量算法一共有4种：</p>
<ol>
<li>Voltage Mode Battery Monitor System</li>
<li>Battery Monitor System</li>
<li>Qualcomm Battery Gauge</li>
<li>Fuel Gauge</li>
</ol>
<p>其中前3种为软件算法，最后一种为硬件算法，接下来我们分别介绍。</p>
<a id="more"></a>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h2 id="Voltage-Mode-Battery-Monitor-System"><a href="#Voltage-Mode-Battery-Monitor-System" class="headerlink" title="Voltage Mode Battery Monitor System"></a>Voltage Mode Battery Monitor System</h2><h3 id="VM-BMS-硬件框架"><a href="#VM-BMS-硬件框架" class="headerlink" title="VM-BMS 硬件框架"></a>VM-BMS 硬件框架</h3><p>VM-BMS主体框架图如下：<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/Voltage_Mode_BMS_Block_Diagram.PNG" alt="Voltage_Mode_BMS_Block_Diagram"></p>
<p>VM-BMS使用电池电压来计算产生SOC值，其中涉及到ADC的测量和Vbatt的测量</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="VM-BMS状态机"><a href="#VM-BMS状态机" class="headerlink" title="VM-BMS状态机"></a>VM-BMS状态机</h3><p>VM-BMS在运行过程中，主要处于下面状态:<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/VM-BMS_Modes_of_Operation.PNG" alt="VM-BMS_states"></p>
<p>S1 - Normal state</p>
<ul>
<li>系统处于唤醒且不在CV charging模式  </li>
<li>BMS按照配置的速率读取Vbat  </li>
<li>BMS读取Vbat的采样，然后存储在FIFO中(默认长度为5)</li>
<li>Software processes SoC using latest accumulated value</li>
</ul>
<p>S2 - CV state</p>
<ul>
<li>系统处于CV charging模式</li>
<li>BMS按照配置的速率读取Vbat，速率比S1快</li>
<li>BMS读取Vbat的采样，然后存储在FIFO中(默认长度为5)</li>
<li>Software processes SoC using latest Vbat value</li>
</ul>
<p>S3 - OCV state</p>
<ul>
<li>系统处于sleep/standby状态，如果有充电器连接，需要处于end of chager状态</li>
<li>BMS按照配置的速率读取Vbat  </li>
<li>如果连续读取的Vbat值落在公差范围内，更新OCV的值</li>
<li>OCV-SOC对照表被用着去计算SOC的值</li>
<li>Software processes SoC using latest OCV value  </li>
</ul>
<p>S7 - PON OSV state</p>
<ul>
<li>系统开机状态</li>
<li>如果关机SoC有效,那么关机SoC的值将作为BMS算法的开始点，否则使用第一个有效的VADC</li>
<li>OVC能被直接转换为相应的启动SoC值</li>
</ul>
<p>注：<br>在当前的软件设计中，只要系统处于唤醒，BMS强制进入S2，只要系统处于suspends，BMS强制进入S3</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="VM-BMS-算法"><a href="#VM-BMS-算法" class="headerlink" title="VM-BMS 算法"></a>VM-BMS 算法</h3><p>1.VM-BMS 通过 GOOD_OCV 和 FIFO中的数据来计算出 Ibat 和 OCV</p>
<p>GOOD_OCV 值的获取如下：</p>
<ul>
<li>PON_OCV if cold boot</li>
<li>Shut down SoC if fast reboot</li>
<li>Updated OCV if system enters S3 state and an OCV update occurs</li>
</ul>
<p>2.通过 OCV 和 temperature 查找对应的数据表获取Internal_Soc</p>
<script type="math/tex; mode=display">
Internal_Soc = LUT(OCV,temperature)</script><p>3.报告给用户的SoC</p>
<ul>
<li><p>充电时:  </p>
<script type="math/tex; mode=display">
Reported SoC = Internal SoC</script></li>
<li><p>放电时:  </p>
<script type="math/tex; mode=display">
Reported SoC = Internal SoC - (1-(ACC/FCC))</script><p>FCC：可从满电池中获取的总电量.<br>ACC：由于温度和system cut-off voltage的因素，实际设备可从满电池中获取的总电量</p>
</li>
</ul>
<p>我们先看充电时的算法示例，即如何获取到Internal SoC<br>已知 OCV = 4180mV，temperature = 28℃，<br>求解Internal SoC</p>
<p>OCV-temperature-SOC 表如下：</p>
<p><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/Sample_OCV-temperature-SOC_lookup_table-1.PNG" alt="Sample OCV-temperature-SOC lookup table-1"></p>
<p>从已知可得28℃在25℃和40℃之间</p>
<ul>
<li>设left_col = COL[3]</li>
<li>设right_col = COL[4]</li>
</ul>
<p><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/Sample_OCV-temperature-SOC_lookup_table-2.PNG" alt="Sample OCV-temperature-SOC lookup table-2"></p>
<p>如上图，在 left_col 中，4180mV在 SOC-85 和 SOC-90 对应的电压值之间，通过下面公式获取25°时，4180mV对应的SOC值</p>
<script type="math/tex; mode=display">
SOC_{interpolate\_left}=(90-85)* \frac {4180-4156} {4210-4156} + 85 = 87.2</script><p>同理，在 right_col 中，4180mV在 SOC-85 和 SOC-90 对应的电压值之间，通过下面公式获取40°时，4180mV对应的SOC值</p>
<script type="math/tex; mode=display">
SOC_{interpolate\_left}=(90-85)* \frac {4180-4154} {4210-41564} + 85 = 87.3</script><p>现在我们知道25℃和40℃时，4180mV对应的SOC值，通过下面的公式我们可以获取28℃时，4180mV对应的SOC值，即Internal SoC</p>
<script type="math/tex; mode=display">
SOC\{n\}=(87.3-87.2)* \frac {28-25} {40-25} + 87.2 = 87.22</script><p>接下来我们来看放电时 VM-BMS 的算法，在放电时，需要引入ACC的概念(需要考虑到 system cut-off voltage)</p>
<p>ACC = FCC - UCC = LUT(cut-off_voltage,temperature,Ibat)</p>
<p>current-temperatu-ACC对照表如下：</p>
<p><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/ACC_lookup_table-1.PNG" alt="ACC_lookup_table"></p>
<p>可以看出，当放电电流增大时，ACC变小.</p>
<p>已知 OCV = 4180mV，temperature = 10℃，放电电流=800mA<br>求解Reported SoC<br>首先按照上面的方法，查找LUT(OCV,temperature)，计算出Internal SoC.</p>
<p>然后查找ACC-temperature-SOC对照表，如下：</p>
<p><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/ACC_lookup_table-2.PNG" alt="ACC_lookup_table-2"></p>
<p>由已知条件temperature = 10℃，在0℃和25℃之间，<br>放电电流=800mA，在500mA~1000mA之间，做如下图：</p>
<p><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/ACC_lookup_table-3.PNG" alt="ACC_lookup_table-3"></p>
<p>通过如下算式，我们可以计算出temperature = 10℃，放电电流=800mA时，ACC的值</p>
<script type="math/tex; mode=display">
ACC@0deg = =(764-1246)* \frac {800-500} {1000-500} + 1246 = 956.8</script><script type="math/tex; mode=display">
ACC@25deg = =(1337-1414)* \frac {800-500} {1000-500} + 1414 = 1367.8</script><script type="math/tex; mode=display">
ACC@10deg = =(1367.8-956.8)* \frac {10-0} {25-0} + 956.8 = 1121.2</script><p>最后通过放电时的公式计算出Reported SoC.</p>
<script type="math/tex; mode=display">
Reported SoC = Internal SoC - (1-(ACC/FCC))</script><p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="VM-BMS-软件"><a href="#VM-BMS-软件" class="headerlink" title="VM-BMS 软件"></a>VM-BMS 软件</h3><h4 id="VM-BMS-代码路径："><a href="#VM-BMS-代码路径：" class="headerlink" title="VM-BMS 代码路径："></a>VM-BMS 代码路径：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kernel/msm<span class="number">-3.18</span>/drivers/power/qpnp-vm-bms.c</span><br><span class="line">kernel/msm<span class="number">-3.18</span>/drivers/power/batterydata-lib.c</span><br><span class="line">kernel/msm<span class="number">-3.18</span>/drivers/power/batterydata-interface.c</span><br><span class="line">kernel/msm<span class="number">-3.18</span>/drivers/of/of_batterydata.c</span><br></pre></td></tr></table></figure>
<h4 id="VM-BMS-软件框图："><a href="#VM-BMS-软件框图：" class="headerlink" title="VM-BMS 软件框图："></a>VM-BMS 软件框图：</h4><p><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/VM-BMS_Software_Architecture.PNG" alt="VM-BMS_Software_Architecture"></p>
<p>注：用户空间算法以二进制形式提供给客户</p>
<h4 id="VM-BMS-代码分析"><a href="#VM-BMS-代码分析" class="headerlink" title="VM-BMS 代码分析"></a>VM-BMS 代码分析</h4><p>1.首先分析qpnp-vm-bms.c的probe函数，大致调用关系如下：<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/qpnp_vm_bms_probe-flow-chart.PNG" alt="qpnp_vm_bms_probe-flow-chart"></p>
<p>其中涉及到的主要函数即作用如下表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>bms_get_adc</td>
<td>获取 VADC 和 ADC_TM clients</td>
</tr>
<tr>
<td>qpnp_pon_is_warm_reset</td>
<td>判断设备是否为warm reset启动</td>
</tr>
<tr>
<td>parse_spmi_dt_propertie</td>
<td>解析spmi相关节点</td>
</tr>
<tr>
<td>parse_bms_dt_properties</td>
<td>解析bms相关节点</td>
</tr>
<tr>
<td>set_battery_data</td>
<td>读取battery id电压，计算出电阻值，通过匹配最接近的电阻值来获取指定battery data（dts），赋给bms_battery_data结构体</td>
</tr>
<tr>
<td>config_battery_data</td>
<td>给batterydata-interface.c中的battery_data结构体赋值</td>
</tr>
<tr>
<td>bms_init_defaults</td>
<td>初始化bms相关变量</td>
</tr>
<tr>
<td>bms_load_hw_defaults</td>
<td>通过dts属性配置硬件寄存器</td>
</tr>
<tr>
<td>setup_vbat_monitoring</td>
<td>为电池低压检测</td>
</tr>
<tr>
<td>bms_request_irqs</td>
<td>Sets up VBAT ADC_TM channel for low vbat monitor</td>
</tr>
<tr>
<td>battery_insertion_check</td>
<td>Restarts BMS hardware to start BMS calculation</td>
</tr>
<tr>
<td>battery_status_check</td>
<td>检测充电状态</td>
</tr>
<tr>
<td>register_bms_char_device</td>
<td>注册bms字符设备</td>
</tr>
<tr>
<td>calculate_initial_soc</td>
<td>设备启动后，计算第一次的SOC值</td>
</tr>
<tr>
<td>calculate_initial_aging_comp</td>
<td>读取charge_cycles和charge_increase数据</td>
</tr>
<tr>
<td>monitor_soc_work</td>
<td>计算soc值</td>
</tr>
<tr>
<td>voltage_soc_timeout_work</td>
<td>超过指定时间，如果bms字符设备没有被open，设置相关flag，后续使用电压来计算SOC，而并非bms算法</td>
</tr>
</tbody>
</table>
</div>
<p>2.接下来我们介绍其中的核心函数monitor_soc_work，主要流程如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">monitor_soc_work</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;chip-&gt;last_soc_mutex);<span class="comment">//上锁</span></span><br><span class="line"></span><br><span class="line">    battery_voltage_check(chip);<span class="comment">//检测充电的状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chip-&gt;dt.cfg_use_voltage_soc) &#123;</span><br><span class="line">        <span class="comment">//使用voltage base on SOC,计算soc值</span></span><br><span class="line">        calculate_soc_from_voltage(chip);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        get_batt_therm(chip, &amp;batt_temp);<span class="comment">//获取电池温度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//查表获取新的soc值</span></span><br><span class="line">        new_soc = lookup_soc_ocv(chip, chip-&gt;last_ocv_uv,batt_temp);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//简单校准soc值</span></span><br><span class="line">        new_soc = clamp_soc_based_on_voltage(chip, new_soc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过查表计算出来的chip-&gt;calculated_soc值有变化</span></span><br><span class="line">        <span class="keyword">if</span> (chip-&gt;calculated_soc != new_soc) &#123;</span><br><span class="line">            chip-&gt;calculated_soc = new_soc;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (chip-&gt;calculated_soc == <span class="number">100</span>)</span><br><span class="line">                <span class="comment">/* update last_soc immediately */</span></span><br><span class="line">                report_vm_bms_soc(chip);</span><br><span class="line"></span><br><span class="line">            power_supply_changed(&amp;chip-&gt;bms_psy);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//上报的soc值还没有更新到与chip-&gt;calculated_soc同步</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chip-&gt;last_soc != chip-&gt;calculated_soc) &#123;</span><br><span class="line">            pr_debug(<span class="string">&quot;update bms_psy\n&quot;</span>);</span><br><span class="line">            power_supply_changed(&amp;chip-&gt;bms_psy);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            report_vm_bms_soc(chip);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* low SOC configuration */</span></span><br><span class="line">    low_soc_check(chip);<span class="comment">// 低电量，重新设置fifo长度</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * schedule the work only if last_soc has not caught up with</span></span><br><span class="line"><span class="comment">	 * the calculated soc or if we are using voltage based soc</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//当上报的soc值和计算出来的soc值不匹配时，延时调用该队列</span></span><br><span class="line">	<span class="keyword">if</span> ((chip-&gt;last_soc != chip-&gt;calculated_soc) ||</span><br><span class="line">					chip-&gt;dt.cfg_use_voltage_soc)</span><br><span class="line">		schedule_delayed_work(&amp;chip-&gt;monitor_soc_work,</span><br><span class="line">			msecs_to_jiffies(get_calculation_delay_ms(chip)));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (chip-&gt;reported_soc_in_use &amp;&amp; chip-&gt;charger_removed_since_full</span><br><span class="line">				&amp;&amp; !chip-&gt;charger_reinserted) &#123;</span><br><span class="line">		<span class="comment">/* record the elapsed time after last reported_soc change */</span></span><br><span class="line">		chip-&gt;reported_soc_change_sec += chip-&gt;delta_time_s;</span><br><span class="line">		pr_debug(<span class="string">&quot;reported_soc_change_sec=%d\n&quot;</span>,</span><br><span class="line">					chip-&gt;reported_soc_change_sec);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* above the catch up time, calculate new reported_soc */</span></span><br><span class="line">		<span class="keyword">if</span> (chip-&gt;reported_soc_change_sec &gt; UI_SOC_CATCHUP_TIME) &#123;</span><br><span class="line">			calculate_reported_soc(chip);</span><br><span class="line">			chip-&gt;reported_soc_change_sec = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;chip-&gt;last_soc_mutex);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要作用是检测并计算soc值，主要流程图如下：</p>
<p><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/monitor_soc_work.PNG" alt="monitor_soc_work"></p>
<p>3.monitor_soc_work其中还涉及到的核心函数report_vm_bms_soc，主要流程如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">report_vm_bms_soc</span><span class="params">(struct qpnp_bms_chip *chip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	soc = chip-&gt;calculated_soc;</span><br><span class="line">	charging = is_battery_charging(chip);<span class="comment">//判断充电状态</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算充电时间</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (chip-&gt;last_soc != -EINVAL) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * last_soc &lt; soc  ... if we have not been charging at all</span></span><br><span class="line"><span class="comment">		 * since the last time this was called, report previous SoC.</span></span><br><span class="line"><span class="comment">		 * Otherwise, scale and catch up.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        get_batt_therm(chip, &amp;batt_temp);<span class="comment">//获取电池温度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果last_soc小于calculated_soc：</span></span><br><span class="line">        <span class="comment">//1.非充电状态，上报之前的SOC值</span></span><br><span class="line">        <span class="comment">//2.充电状态，不立即报告高值，而是根据充电时间加权平均值将值从prev_soc缓慢地缩放到新的soc</span></span><br><span class="line">		<span class="keyword">if</span> (chip-&gt;last_soc &lt; soc &amp;&amp; !charging)</span><br><span class="line">			soc = chip-&gt;last_soc;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (chip-&gt;last_soc &lt; soc &amp;&amp; soc != <span class="number">100</span>)</span><br><span class="line">			soc = scale_soc_while_chg(chip, charge_time_sec,chip-&gt;catch_up_time_sec,soc, chip-&gt;chg_start_soc);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果电池电压接近cut-off voltage，或者电池温度处于低温，</span></span><br><span class="line">        <span class="comment">//这2中情况允许出现SOC值大的变化，即soc_change值较大</span></span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在resume情况下，如果ocv发生变化，会进行赋值chip-&gt;last_soc_unbound = true</span></span><br><span class="line">        <span class="comment">//这种情况下soc_change可以为较大值，否则只能为1.</span></span><br><span class="line">		<span class="keyword">if</span> (chip-&gt;last_soc_unbound) &#123;</span><br><span class="line">			chip-&gt;last_soc_unbound = <span class="literal">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * if soc have not been unbound by resume,</span></span><br><span class="line"><span class="comment">			 * only change reported SoC by 1.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			soc_change = min(<span class="number">1</span>, soc_change);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据上面的条件计算出soc_change值，在此基础上修改soc值，防止发生不必要的跳变</span></span><br><span class="line">		<span class="keyword">if</span> (soc &lt; chip-&gt;last_soc &amp;&amp; soc != <span class="number">0</span>)</span><br><span class="line">			soc = chip-&gt;last_soc - soc_change;</span><br><span class="line">		<span class="keyword">if</span> (soc &gt; chip-&gt;last_soc &amp;&amp; soc != <span class="number">100</span>)</span><br><span class="line">			soc = chip-&gt;last_soc + soc_change;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	soc = bound_soc(soc);<span class="comment">//防止soc小于0或者大于100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在如下情况检测、更新end of charger</span></span><br><span class="line">    <span class="comment">//1.soc发生变化 2.soc值为100</span></span><br><span class="line">	<span class="keyword">if</span> ((soc != chip-&gt;last_soc) || (soc == <span class="number">100</span>)) &#123;</span><br><span class="line">		chip-&gt;last_soc = soc;</span><br><span class="line">		check_eoc_condition(chip);<span class="comment">//检测停止充电条件</span></span><br><span class="line">		<span class="keyword">if</span> ((chip-&gt;dt.cfg_soc_resume_limit &gt; <span class="number">0</span>) &amp;&amp; !charging)</span><br><span class="line">			check_recharge_condition(chip);<span class="comment">//检测recharge条件</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把ocv和soc的值存储在寄存器中</span></span><br><span class="line">	backup_ocv_soc(chip, chip-&gt;last_ocv_uv, chip-&gt;last_soc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> chip-&gt;last_soc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要作用<br>1.在chip-&gt;calculated_soc的基础上，计算出chip-&gt;last_soc.(防止跳变)<br>2.检测停充和复充条件<br>3.存储chip-&gt;last_soc和chip-&gt;last_ocv_uv到寄存器中</p>
<p>主要流程图如下：<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/report_vm_bms_soc.PNG" alt="report_vm_bms_soc"></p>
<p>4.接下来看下驱动提供的property interface，当monitor_soc_work调用power_supply_changed时，发生uevent事件给用户空间 vm-bms.c(非开源)，用户空间通过get_property获取电池相关参数，计算出last_ocv_uv，然后通过set_property来设置OCV，启动monitor_soc_work工作队列，代码流程如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------kernel/msm-3.18/drivers/power/qpnp-linear-charger.c---------</span></span><br><span class="line">chip-&gt;bms_psy-&gt;get_property(chip-&gt;bms_psy,POWER_SUPPLY_PROP_CAPACITY, &amp;ret);</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------kernel/msm-3.18/drivers/power/qpnp-vm-bms.c---------                </span></span><br><span class="line">----&gt;get_prop_bms_capacity(chip);</span><br><span class="line">    ----&gt;report_state_of_charge(chip);</span><br><span class="line">        ----&gt;report_voltage_based_soc(chip);<span class="comment">//基于voltage计算soc</span></span><br><span class="line">        ----&gt;report_vm_bms_soc(chip);<span class="comment">//基于bms计算soc</span></span><br></pre></td></tr></table></figure>
<p>流程图如下：<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/property_interface.PNG" alt="property_interface"></p>
<p>5.涉及到的表格</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">DTS节点</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">qcom,fcc-temp-lut</td>
<td>不同温度下，FCC(Full-charge capacity)的值.</td>
</tr>
<tr>
<td style="text-align:left">qcom,pc-temp-ocv-lut</td>
<td>不同温度下，通过OVC的值映射到对应的SOC值.</td>
</tr>
<tr>
<td style="text-align:left">qcom,rbatt-sf-lut</td>
<td>不同温度下，通过SOC值映射到对应的内阻值，主要考虑对OCV的修正，new_ocv=ocv+rbatt(内阻)*current（当前电流）.</td>
</tr>
<tr>
<td style="text-align:left">qcom,ibat-acc-lut</td>
<td>不同温度下，通过当前的电流值映射到ACC的值.</td>
</tr>
</tbody>
</table>
</div>
<p><strong>总结：</strong><br>1.vm-bms 运行 monitor_soc_work 工作队列来执行主要的工作：通过last_ocv_uv，查表得到SOC，经过修正得到上报的SOC值.<br>2.当驱动调用power_supply_changed，表示power supply class有property发生变化，发送uevent事件，上层获取事件后，调用getprop来获取相关参数：内阻，电流等，在用户空间 vm-bms.c(非开源)估算出last_ocv_uv，然后调用setprop，传入参数：POWER_SUPPLY_PROP_VOLTAGE_OCV,重新调用monitor_soc_work 工作队列. </p>
<p>注：PM8909/PM8916支持VM-BMS</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h2 id="Battery-Monitor-System"><a href="#Battery-Monitor-System" class="headerlink" title="Battery Monitor System"></a>Battery Monitor System</h2><p>VM-BMS主要基于OCV的值来进行计算出SOC值，BMS在VM-BMS的基础上，主要引入了库仑计，利用经过电池的电流的累计，计算出电荷量，即综合raw OCV 和 Coulomb count (CC) data计算出SOC值。<br>因为与VM-BMS比较类似，并且目前手上没有PM8921/PM8941的代码，所以这里简单介绍下BMS。</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="BMS-硬件框架"><a href="#BMS-硬件框架" class="headerlink" title="BMS 硬件框架"></a>BMS 硬件框架</h3><p><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/BMS_Block_Diagram.PNG" alt="BMS_Block_Diagram"></p>
<ul>
<li>通过Vbatt计算出OCV</li>
<li>通过Vsensor-B和Rsensor计算出电流，CCADC采样电流计算出经过电池的电荷量</li>
</ul>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="BMS状态机"><a href="#BMS状态机" class="headerlink" title="BMS状态机"></a>BMS状态机</h3><p><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/BMS_State_Machine_Details.PNG" alt="BMS_State_Machine_Details"></p>
<ul>
<li>S1 降低测试频率，减少功耗</li>
<li>S2 增大测试频率，提高精度</li>
<li>S3 对Vbatt和Vsensor大量采样，更新 last good OCV，同时对库仑计数(CC)清零</li>
</ul>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h3 id="BMS-算法"><a href="#BMS-算法" class="headerlink" title="BMS 算法"></a>BMS 算法</h3><p>1.库仑计数(CC)跟踪OCV更新之间的电量损失<br>2.当OCV 更新时，库仑计数(CC)复位清零。<br>3.利用OCV值查表获取对应soc值<br>4.最终的SOC值 = (最新的OCV值对应的电量 - 库仑计数(CC)对应的电量 - 不可用电量)/(满电量-不可用电量)</p>
<p>公式如下：</p>
<script type="math/tex; mode=display">
SOC=\frac {Lookup(OCV) * FCC - \frac {CC} {R_sense}UCC} {FCC - UUC}</script><p>其中UUC也是根据Rbatt，Vcut-off 查表获取。<br>可以看出，和 vm-bms 对比，主要增加了利用库仑计数（CC）来优化OCV未更新时SOC的计算</p>
<h3 id="BMS-软件"><a href="#BMS-软件" class="headerlink" title="BMS 软件"></a>BMS 软件</h3><h4 id="BMS-软件框图"><a href="#BMS-软件框图" class="headerlink" title="BMS 软件框图"></a>BMS 软件框图</h4><p><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/PM8921_BMS_Linux_Android_Software_Architecture.PNG" alt="PM8921_BMS_Linux_Android_Software_Architecture"></p>
<p>基本和vm-bms一致。</p>
<h4 id="BMS-代码分析"><a href="#BMS-代码分析" class="headerlink" title="BMS 代码分析"></a>BMS 代码分析</h4><p>主要代码流程如下，流程图省略。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qpnp_bms_probe</span><span class="params">(struct spmi_device *spmi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//和vm-bms流程基本一致,这里只列出其中不一致的核心代码</span></span><br><span class="line"></span><br><span class="line">    INIT_DELAYED_WORK(&amp;chip-&gt;calculate_soc_delayed_work,calculate_soc_work);</span><br><span class="line">	INIT_WORK(&amp;chip-&gt;recalc_work, recalculate_work);</span><br><span class="line"></span><br><span class="line">    calculate_soc_work(&amp;(chip-&gt;calculate_soc_delayed_work.work));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calculate_soc_work</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	recalculate_soc(chip);</span><br><span class="line">	schedule_delayed_work(&amp;chip-&gt;calculate_soc_delayed_work,...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recalculate_work</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	recalculate_soc(chip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从上面的代码可以看出，calculate_soc_delayed_work 工作队列一直循环延时调用 recalculate_soc 函数。<br>而 recalc_work 工作队列调用一次 recalculate_soc 函数，所以重点在 recalculate_soc 函数，我们接下来重点分析 recalculate_soc 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">recalculate_soc</span><span class="params">(struct qpnp_bms_chip *chip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取电池温度</span></span><br><span class="line">	pnp_vadc_read(chip-&gt;vadc_dev, LR_MUX1_BATT_THERM,&amp;result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取电池温度值</span></span><br><span class="line">	batt_temp = (<span class="keyword">int</span>)result.physical;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取库伦计数(CC) 和 last good ocv</span></span><br><span class="line">    read_soc_params_raw(chip, &amp;raw, batt_temp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算出各种参数，利用参数计算出soc值，根据soc值计算出上报的soc值。</span></span><br><span class="line">	soc = calculate_state_of_charge(chip,&amp;raw, batt_temp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> soc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate_state_of_charge</span><span class="params">(struct qpnp_bms_chip *chip,</span></span></span><br><span class="line"><span class="function"><span class="params">					struct raw_soc_params *raw,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">int</span> batt_temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//计算充电时间，FCC，剩余电量，库仑计数(CC),Rbat,Iavg等参数</span></span><br><span class="line">	calculate_soc_params(chip, raw, &amp;params, batt_temp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用上面计算的参数和公式 RC-UUC/FCC-UUC 计算出soc值</span></span><br><span class="line">	soc = calculate_raw_soc(chip, raw, &amp;params, batt_temp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开机第一次计算，利用 shutdown_soc 来修改soc值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* always clamp soc due to BMS hw/sw immaturities */</span></span><br><span class="line">	new_calculated_soc = clamp_soc_based_on_voltage(chip,</span><br><span class="line">					new_calculated_soc);</span><br><span class="line"></span><br><span class="line">	new_calculated_soc = bound_soc(new_calculated_soc);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果与上次计算soc的值的时间相差超过规定时间，表明系统一定进入了长时间休眠状态，Soc状态设置为unbound</span></span><br><span class="line">	chip-&gt;last_soc_unbound = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算出的soc值发生变化，上报给上层</span></span><br><span class="line">	<span class="keyword">if</span> (new_calculated_soc != previous_soc &amp;&amp; chip-&gt;bms_psy_registered) &#123;</span><br><span class="line">		power_supply_changed(&amp;chip-&gt;bms_psy);</span><br><span class="line">		pr_debug(<span class="string">&quot;power supply changed\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Call report state of charge anyways to periodically update</span></span><br><span class="line"><span class="comment">		 * reported SoC. This prevents reported SoC from being stuck</span></span><br><span class="line"><span class="comment">		 * when calculated soc doesn&#x27;t change.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		report_state_of_charge(chip);</span><br><span class="line">		<span class="comment">//根据voltage上报soc值</span></span><br><span class="line">		----&gt;report_voltage_based_soc(chip);</span><br><span class="line">		<span class="keyword">or</span></span><br><span class="line">		<span class="comment">//根据 chip-&gt;calculated_soc 计算出上报的soc值：chip-&gt;last_soc，同时存储SOC和Iavg的值到寄存器</span></span><br><span class="line">		----&gt;report_cc_based_soc(chip);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong><br>1.获取库伦计数(CC)，充电时间，FCC，剩余电量，库仑计数(CC),Rbat,Iavg等参数<br>2.利用上面参数计算soc值，在vm-bms中，用户空间(非开源)利用这些参数计算出OCV，然后利用OCV查表计算出osc值<br>3.根据上面的soc值，计算出上报的soc值</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h2 id="Qualcomm-battery-gauge"><a href="#Qualcomm-battery-gauge" class="headerlink" title="Qualcomm battery gauge"></a>Qualcomm battery gauge</h2><h3 id="QG-硬件框架"><a href="#QG-硬件框架" class="headerlink" title="QG 硬件框架"></a>QG 硬件框架</h3><p>硬件大致框图如下:<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/Qualcomm_Battery_Gauge_Hardware_Block_Diagram.PNG" alt="Qualcomm_Battery_Gauge_Hardware_Block_Diagram"></p>
<p>PMI632 Qualcomm battery gauge 硬件的核心由累加器组成，该累加器会定期采样，累加并将Vbatt和Ibatt值保存到PMIC寄存器中，以读取和处理SoC,并使用相同的硬件对电池内阻（ESR）进行估计。</p>
<h3 id="QG-SOC概念"><a href="#QG-SOC概念" class="headerlink" title="QG SOC概念"></a>QG SOC概念</h3><h4 id="1-RAW-SOC"><a href="#1-RAW-SOC" class="headerlink" title="1.RAW SOC"></a>1.RAW SOC</h4><p>RAW SOC是库仑计估算的SOC(CC_SOC)和Vlotage mode估算的SOC(V_SOC)加权评估出来的结果，大致流程如下：<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/RAW_SOC.PNG" alt="RAW_SOC"></p>
<h4 id="2-BATTERY-SOC"><a href="#2-BATTERY-SOC" class="headerlink" title="2.BATTERY SOC"></a>2.BATTERY SOC</h4><p>BATTERY SOC是根据RAW SOC计算出来，同时根据电池的电压，电流和状态进行校正，大致流程如下：<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/BATTERY_SOC.PNG" alt="BATTERY_SOC"></p>
<h4 id="3-SYSTEM-SOC"><a href="#3-SYSTEM-SOC" class="headerlink" title="3.SYSTEM SOC"></a>3.SYSTEM SOC</h4><ul>
<li>SOC point 0%：上报0%的SOC的点将根据截止电压（qcom,vbatt-cutoff-mv）进行收敛，通过设置截止电压，可以使任何期望的电压对应0%的SOC值。</li>
<li>SOC point 100%:上报100%的SOC的点将根据充电电流来决定，截止电流为2种，一种为系统截止电流，即达到该电流时，上报100% SOC，一种是物理充电截止电流，达到该电流时，设备停止充电。<br>系统截止电流对应的dts：qcom,qg-iterm-ma<br>物理充电截止电流对应的dts：qcom,chg-term-current-ma<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/SYSTEM_SOC.PNG" alt="SYSTEM_SOC"></li>
</ul>
<h4 id="4-Monotonic-SOC"><a href="#4-Monotonic-SOC" class="headerlink" title="4.Monotonic SOC"></a>4.Monotonic SOC</h4><p>在截止电压附近，有2种情况，可能导致SOC不单调变化</p>
<ul>
<li>电池内部电阻发生变化</li>
<li>电池负载发生变化</li>
</ul>
<p>为了确保SOC的单调性变化，QG算法确定如下逻辑：</p>
<ul>
<li>当放电或者supplemental模式时，SOC单调递减</li>
<li>当充电时，SOC单调递增</li>
</ul>
<h4 id="5-PON-SOC"><a href="#5-PON-SOC" class="headerlink" title="5.PON SOC"></a>5.PON SOC</h4><p>Ponwer on SOC的值可以通过Shutdown SOC的值获取，但是需要满足几个条件：温度变化，时间长度，SOC变化都在一定设置范围内。如果其中一项不满足，系统将使用PON OCV估算出来的值。</p>
<ul>
<li>qcom,ignore-shutdown-soc-secs = <360>; /<em> phone-off time to ignore shutdown soc </em>/</360></li>
<li>qcom,shutdown-temp-diff = <60>; /<em> battery temp delta to ignore shutdown soc</em>/</60></li>
<li>qcom,shutdown-soc-threshold = <10>; /<em>soc delta between shutdown and pon soc for ignoring shutdown soc </em>/</10></li>
</ul>
<h4 id="6-SOC-FLOW"><a href="#6-SOC-FLOW" class="headerlink" title="6.SOC FLOW"></a>6.SOC FLOW</h4><p>各个SOC的流程框图如下：<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/SOC_FLOW.PNG" alt="SOC_FLOW"><br>具体涉及到的数据流程：<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/SOC_FLOW2.PNG" alt="SOC_FLOW2"></p>
<p>基于以上4中SOC，QG算法计算出最终的SOC上报给系统。</p>
<h3 id="QG-算法核心"><a href="#QG-算法核心" class="headerlink" title="QG 算法核心"></a>QG 算法核心</h3><p>QG算法的核心思想如下：</p>
<ol>
<li>从GOOD_OCV或者FIFO Vbatt中计算出OCV</li>
</ol>
<ul>
<li>GOOD_OVC可以考虑为如下值，<ul>
<li>PON_OVC（设备冷启动）</li>
<li>Shutdown Soc（设备快速重启）</li>
<li>记录的OVC（睡眠状态）</li>
</ul>
</li>
</ul>
<ol>
<li>根据battery profile，利用OCV查表计算出V_SOC<br> V_SOC = LUT(OVC, temperature)</li>
<li>基于FIFO Ibatt数据，得出CC_Soc</li>
</ol>
<h3 id="QG-软件"><a href="#QG-软件" class="headerlink" title="QG  软件"></a>QG  软件</h3><h4 id="QG-代码路径"><a href="#QG-代码路径" class="headerlink" title="QG 代码路径"></a>QG 代码路径</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>路径</th>
</tr>
</thead>
<tbody>
<tr>
<td>路径A</td>
<td>kernel/msm-4.14/drivers/power/supply/qcom/qpnp-qg.c</td>
</tr>
<tr>
<td>路径B</td>
<td>kernel/msm-4.14/drivers/power/supply/qcom/qp-soc.c</td>
</tr>
</tbody>
</table>
</div>
<h4 id="QG-软件框图"><a href="#QG-软件框图" class="headerlink" title="QG  软件框图"></a>QG  软件框图</h4><p>软件框图如下：<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/Qualcomm_Battery_Gauge_software_architecture.PNG" alt="Qualcomm_Battery_Gauge_software_architecture"></p>
<p>该软件框图涉及到2部分：内核空间和用户空间</p>
<ul>
<li>用户空间<ul>
<li>硬件配置</li>
<li>初始化SOC计算 </li>
<li>保存Shutdown OCV状态</li>
<li>电池在位检测</li>
<li>设置battery profile</li>
<li>中断处理</li>
<li>读取FIFO和累加器中的数据</li>
<li>根据OVC（用户空间计算）和电池温度查表计算出SOC</li>
<li>最终得出Monotonic Soc</li>
</ul>
</li>
<li>用户空间<ul>
<li>利用内核中的硬件数据（FIFO和累加器）计算出OCV</li>
<li>通过算法计算出V_SoC, CC_SoC, R_SoC, Bat_SoC, and Sys_SoC </li>
<li>更新OCV，Sys_SoC到内核空间</li>
<li>用户空间的算法为二进制文件，对客户保密</li>
</ul>
</li>
</ul>
<h4 id="QG-代码分析"><a href="#QG-代码分析" class="headerlink" title="QG 代码分析"></a>QG 代码分析</h4><p>首先分析probe函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qpnp_qg_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在qg驱动中，会注册一个字符设备&quot;qg&quot;，</span></span><br><span class="line"><span class="comment">	 * 当用户空间对qg进行write操作时，</span></span><br><span class="line"><span class="comment">	 * 用户空间的数据会写入到内核的qg_user_data结构体中</span></span><br><span class="line"><span class="comment">	 * 然后调用udata_work队列，更新内核中的数据，计算各个soc的值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	INIT_WORK(&amp;chip-&gt;udata_work, process_udata_work);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 当battery，parallel，usb，dc属性发生power supply chaned时</span></span><br><span class="line"><span class="comment">	 * 会调用回调函数 qg_notifier_cb</span></span><br><span class="line"><span class="comment">	 * 在此回调函数中会调用 qg_status_change_work 队列</span></span><br><span class="line"><span class="comment">	 * 该函数主要更新一些battery的状态属性</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	INIT_WORK(&amp;chip-&gt;qg_status_change_work, qg_status_change_work);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 1.初始化alarm定时器，超时后调用qpnp_msoc_timer函数</span></span><br><span class="line"><span class="comment">     * 2.初始化scale_soc_work工作队列</span></span><br><span class="line"><span class="comment">     * 3.qpnp_msoc_timer会调度scale_soc_work工作队列</span></span><br><span class="line"><span class="comment">     * qg_soc_init函数的目的：定时调用scale_soc_work工作队列来计算soc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	qg_soc_init(chip);</span><br><span class="line">	----&gt;alarm_init(&amp;chip-&gt;alarm_timer, ALARM_BOOTTIME,qpnp_msoc_timer);</span><br><span class="line">	----&gt;WORK(&amp;chip-&gt;scale_soc_work, scale_soc_work);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 主要作用是决定PON SOC：</span></span><br><span class="line"><span class="comment">	 * 温度变化，时间长度，SOC变化都在一定设置范围内，使用Shutdown SOC</span></span><br><span class="line"><span class="comment">	 * 如果其中一项不满足，系统将使用PON OCV估算出来的值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	qg_determine_pon_soc(chip);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*power_supply_changed</span></span><br><span class="line"><span class="comment">	 * 1.注册qg power supply设备</span></span><br><span class="line"><span class="comment">	 * 2.注册power_supply_notifier事件通知链，当调用power_supply_changed时</span></span><br><span class="line"><span class="comment">	 * 会调用回调函数 qg_notifier_cb</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	qg_init_psy(chip);</span><br><span class="line">	----&gt;devm_power_supply_register(chip-&gt;dev,&amp;qg_psy_desc, &amp;qg_psy_cfg);</span><br><span class="line">	----&gt;chip-&gt;nb.notifier_call = qg_notifier_cb;</span><br><span class="line">	----&gt;power_supply_reg_notifier(&amp;chip-&gt;nb);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注：</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">power_supply_desc</span> <span class="title">qg_psy_desc</span> = &#123;</span></span><br><span class="line">	.name = <span class="string">&quot;bms&quot;</span>,</span><br><span class="line">	.type = POWER_SUPPLY_TYPE_BMS,</span><br><span class="line">	.properties = qg_psy_props,</span><br><span class="line">	.num_properties = ARRAY_SIZE(qg_psy_props),</span><br><span class="line">	.get_property = qg_psy_get_property,</span><br><span class="line">	.set_property = qg_psy_set_property,</span><br><span class="line">	.property_is_writeable = qg_property_is_writeable,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>有3种情况，qg子系统计算更新soc值</p>
<ol>
<li>当其他power子系统调用power_supply_changed时</li>
<li>当用户空间的二进制算法操作qg字符设备时</li>
<li>上次设置的 alarm_timer 定时器超时时</li>
</ol>
<p>下面我们来分别说明这3个情况</p>
<p>1.当其他power子系统调用power_supply_changed时,会调用回调函数qg_notifier_cb</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qg_notifier_cb</span><span class="params">(struct notifier_block *nb,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">unsigned</span> <span class="keyword">long</span> event, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((<span class="built_in">strcmp</span>(psy-&gt;desc-&gt;name, <span class="string">&quot;battery&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		|| (<span class="built_in">strcmp</span>(psy-&gt;desc-&gt;name, <span class="string">&quot;parallel&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		|| (<span class="built_in">strcmp</span>(psy-&gt;desc-&gt;name, <span class="string">&quot;usb&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		|| (<span class="built_in">strcmp</span>(psy-&gt;desc-&gt;name, <span class="string">&quot;dc&quot;</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">		schedule_work(&amp;chip-&gt;qg_status_change_work);</span><br><span class="line">		<span class="comment">//检测usb，dc插拔，调用 qg_scale_soc 更新SOC</span></span><br><span class="line">		----&gt;qg_input_status_update(chip)</span><br><span class="line">		<span class="comment">//检测battery是否full状态，并看情况调用 qg_scale_soc 更新SOC</span></span><br><span class="line">		----&gt;qg_charge_full_update(chip)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.当用户空间的二进制算法操作对qg字符设备进行write操作时，会调用udata_work工作队列<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">qg_device_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//把用户空间的算法计算出来的数据写入内核</span></span><br><span class="line">	copy_from_user(&amp;chip-&gt;udata, buf, data_size)</span><br><span class="line">	</span><br><span class="line">	vote(chip-&gt;awake_votable, UDATA_READY_VOTER, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调度udata_work工作队列</span></span><br><span class="line">	schedule_work(&amp;chip-&gt;udata_work);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_udata_work</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">qpnp_qg</span> *<span class="title">chip</span> = <span class="title">container_of</span>(<span class="title">work</span>,</span></span><br><span class="line"><span class="class">			<span class="title">struct</span> <span class="title">qpnp_qg</span>, <span class="title">udata_work</span>);</span></span><br><span class="line">	<span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 判断用户空间写入到内核的数据是否有效，并把soc相关值值赋给qpnp_qg结构体</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (chip-&gt;udata.param[QG_CC_SOC].valid)</span><br><span class="line">		chip-&gt;cc_soc = chip-&gt;udata.param[QG_CC_SOC].data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (chip-&gt;udata.param[QG_BATT_SOC].valid)</span><br><span class="line">		chip-&gt;batt_soc = chip-&gt;udata.param[QG_BATT_SOC].data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (chip-&gt;udata.param[QG_FULL_SOC].valid)</span><br><span class="line">		chip-&gt;full_soc = chip-&gt;udata.param[QG_FULL_SOC].data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (chip-&gt;udata.param[QG_SOC].valid ||</span><br><span class="line">			chip-&gt;udata.param[QG_SYS_SOC].valid) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (chip-&gt;udata.param[QG_SYS_SOC].valid) &#123;</span><br><span class="line">			chip-&gt;sys_soc = chip-&gt;udata.param[QG_SYS_SOC].data;</span><br><span class="line">			chip-&gt;catch_up_soc = qg_adjust_sys_soc(chip);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			chip-&gt;catch_up_soc = chip-&gt;udata.param[QG_SOC].data;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 调用qg_scale_soc强制更新soc</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		qg_scale_soc(chip, chip-&gt;force_soc);</span><br><span class="line">		chip-&gt;force_soc = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * update soc parameters to SDAM</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		chip-&gt;sdam_data[SDAM_SOC] = chip-&gt;msoc;</span><br><span class="line">		chip-&gt;sdam_data[SDAM_OCV_UV] =</span><br><span class="line">				chip-&gt;udata.param[QG_OCV_UV].data;</span><br><span class="line">		chip-&gt;sdam_data[SDAM_RBAT_MOHM] =</span><br><span class="line">				chip-&gt;udata.param[QG_RBAT_MOHM].data;</span><br><span class="line">		chip-&gt;sdam_data[SDAM_VALID] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		rc = qg_store_soc_params(chip);</span><br><span class="line">		<span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line">			pr_err(<span class="string">&quot;Failed to update SDAM params, rc=%d\n&quot;</span>, rc);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 判断用户空间写入到内核的数据是否有效，并把esr相关值值赋给qpnp_qg结构体</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (chip-&gt;udata.param[QG_ESR].valid)</span><br><span class="line">		chip-&gt;esr_last = chip-&gt;udata.param[QG_ESR].data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (chip-&gt;esr_actual != -EINVAL &amp;&amp; chip-&gt;udata.param[QG_ESR].valid)&#123;</span><br><span class="line">		chip-&gt;esr_nominal = chip-&gt;udata.param[QG_ESR].data;</span><br><span class="line">		<span class="keyword">if</span> (chip-&gt;qg_psy)</span><br><span class="line">			power_supply_changed(chip-&gt;qg_psy);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * update ser parameters to SDAM</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!chip-&gt;dt.esr_disable)</span><br><span class="line">		qg_store_esr_params(chip);</span><br><span class="line"></span><br><span class="line">	vote(chip-&gt;awake_votable, UDATA_READY_VOTER, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以上2种情况，最终都是调用 qg_scale_soc 来计算更新，下面具体分析该函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qg_scale_soc</span><span class="params">(struct qpnp_qg *chip, <span class="keyword">bool</span> force_soc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在用户空间写gq字符设备时，调用 qg_scale_soc 来强制更新soc</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (force_soc) &#123;</span><br><span class="line">		chip-&gt;msoc = chip-&gt;catch_up_soc;</span><br><span class="line">		rc = qg_write_monotonic_soc(chip, chip-&gt;msoc);</span><br><span class="line">		<span class="keyword">goto</span> done_psy;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 判断是否需要更新soc，如果否，则取消alarm_timer定时器来并跳过更新soc。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!is_scaling_required(chip)) &#123;</span><br><span class="line">		scale_soc_stop(chip);</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 1.判断并更新chip-&gt;msoc</span></span><br><span class="line"><span class="comment">	 * 2.根据新的MSOC更新SOC寄存器的值</span></span><br><span class="line"><span class="comment">	 * 3.根据新的MSOC更新SDAM的值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	update_msoc(chip);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 判断是否需要更新soc，如果是，获取下次更新时间间隔，并设置定时器</span></span><br><span class="line"><span class="comment">	 * 如果否，取消alarm_timer定时器。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (is_scaling_required(chip)) &#123;</span><br><span class="line">		get_next_update_time(chip);</span><br><span class="line">		alarm_start_relative(&amp;chip-&gt;alarm_timer,</span><br><span class="line">					ms_to_ktime(chip-&gt;next_wakeup_ms));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		scale_soc_stop(chip);</span><br><span class="line">		<span class="keyword">goto</span> done_psy;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">done_psy:</span><br><span class="line">	power_supply_changed(chip-&gt;qg_psy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.alarm_timer 定时器超时<br>在 qg_scale_soc 函数中，如果还需要更新soc，会设置并启动alarm_timer定时器,超时时调用qpnp_msoc_timer函数，在qpnp_msoc_timer函数中，调度scale_soc_work工作队列，scale_soc_work队列函数与qg_scale_soc函数作用于基本一致，只是少了强制更新逻辑。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * alarm_timer定时器超时函数，调度scale_soc_work工作队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">enum</span> alarmtimer_restart</span><br><span class="line">	qpnp_msoc_timer(struct alarm *alarm, <span class="keyword">ktime_t</span> now)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">qpnp_qg</span> *<span class="title">chip</span> = <span class="title">container_of</span>(<span class="title">alarm</span>,</span></span><br><span class="line"><span class="class">				<span class="title">struct</span> <span class="title">qpnp_qg</span>, <span class="title">alarm_timer</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* timer callback runs in atomic context, cannot use voter */</span></span><br><span class="line">	pm_stay_awake(chip-&gt;dev);</span><br><span class="line">	schedule_work(&amp;chip-&gt;scale_soc_work);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ALARMTIMER_NORESTART;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 与qg_scale_soc函数作用于基本一致，只是少了强制更新逻辑</span></span><br><span class="line"><span class="comment"> * （主要用在空户空间对kernel更新qg相关参数时）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scale_soc_work</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">qpnp_qg</span> *<span class="title">chip</span> = <span class="title">container_of</span>(<span class="title">work</span>,</span></span><br><span class="line"><span class="class">			<span class="title">struct</span> <span class="title">qpnp_qg</span>, <span class="title">scale_soc_work</span>);</span></span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;chip-&gt;soc_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!is_scaling_required(chip)) &#123;</span><br><span class="line">		scale_soc_stop(chip);</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	update_msoc(chip);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (is_scaling_required(chip)) &#123;</span><br><span class="line">		alarm_start_relative(&amp;chip-&gt;alarm_timer,</span><br><span class="line">				ms_to_ktime(chip-&gt;next_wakeup_ms));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		scale_soc_stop(chip);</span><br><span class="line">		<span class="keyword">goto</span> done_psy;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">done_psy:</span><br><span class="line">	power_supply_changed(chip-&gt;qg_psy);</span><br><span class="line">done:</span><br><span class="line">	pm_relax(chip-&gt;dev);</span><br><span class="line">	mutex_unlock(&amp;chip-&gt;soc_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>总结：</strong></p>
<ol>
<li><p>当其他power子系统调用 power_supply_changed 时，根据情况会计算soc，简单流程如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">power_supply_changed</span><br><span class="line">---&gt;qg_notifier_cb</span><br><span class="line">	----&gt;schedule_work(&amp;chip-&gt;qg_status_change_work);</span><br><span class="line">		----&gt;qg_input_status_update(chip);</span><br><span class="line">			----&gt;qg_scale_soc(chip, <span class="literal">false</span>);</span><br><span class="line">		----&gt;qg_charge_full_update(chip);</span><br><span class="line">			 ----&gt;qg_scale_soc(chip, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>当用户空间的二进制算法操作qg字符设备时，简单流程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">qg_device_write</span><br><span class="line">	<span class="comment">//把用户空间的数据复制给内核相关结构体，并重新计算soc</span></span><br><span class="line">----&gt;schedule_work(&amp;chip-&gt;udata_work);</span><br><span class="line">	----&gt;qg_scale_soc(chip, chip-&gt;force_soc);</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面2种情况主动调用qg_scale_soc来计算soc时，根据实际情况情况判断是否需要启动定时器alarm_timer来定时更新soc，简单流程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alarm_start_relative(&amp;chip-&gt;alarm_timer,</span><br><span class="line">				ms_to_ktime(chip-&gt;next_wakeup_ms));</span><br><span class="line">----&gt;qpnp_msoc_timer</span><br><span class="line">		<span class="comment">//scale_soc_work函数和qg_scale_soc作用一致，用来更新soc值</span></span><br><span class="line">	----&gt;schedule_work(&amp;chip-&gt;scale_soc_work);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>从上面的流程可以看到，cc_soc,batt_soc,full_soc,sys_soc,catch_up_soc等值都是从用户空间传递给内核的，内核只是根据这些值计算，判断出msoc作为系统上报的soc.</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h2 id="Fuel-Gauge"><a href="#Fuel-Gauge" class="headerlink" title="Fuel Gauge"></a>Fuel Gauge</h2><p>FG模块是一种算法的硬件实现，该算法通过检测电流和电压来评估计算电池的电量。</p>
<h3 id="FG-架构"><a href="#FG-架构" class="headerlink" title="FG 架构"></a>FG 架构</h3><p><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/Fuel Gauge Architecture.PNG" alt="Fuel Gauge Architecture"></p>
<p>FG架构如上图：</p>
<ol>
<li>CS_PLUS和CS_MINUS用来检测FG电流</li>
<li>BATT_PLUS和BATT_MINUS用来检测电池电压</li>
<li>BATT_ID检测battery ID引脚电阻，BATT_THERM检测电池温度， 两者一起检测Battery Missing状态</li>
</ol>
<h3 id="FG-算法"><a href="#FG-算法" class="headerlink" title="FG 算法"></a>FG 算法</h3><p>Fuel Gauge 在原理上与 Battery Gauge 是一样的。<br>只是QG算法在 AP 上运行，更便于调整和优化算法。<br>FG 是固化在 PMIC 里面的 Firmware 不能改动，只能微调部分寄存器设置。</p>
<p>FG算法也涉及到QG算法中的CC_SoC，Battery SoC，System SoC,  Monotonic SoC，大致框图如下:<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/FG_SOC_FLOW.PNG" alt="FG_SOC_FLOW.PNG"></p>
<ol>
<li>CC_SoC ： coulomb-counted value </li>
<li>Battery SoC：Battery SoC是CC_SoC和voltage mode校正算法的结合，大致流程如下图：<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/FG_Battery_SoC.PNG" alt="FG_Battery_SoC"></li>
</ol>
<p>其中涉及到的Battery model：<br><img src="/2020/09/24/Qcom-platform-battery-capacity-algorithm/Battery_Model.PNG" alt="Battery_Model"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* OCV：Open Circuit Voltage (开漏电路电压)，即电路没有电流，并且电池为使用或者长时间闲置（C1完全放电）</span><br><span class="line">* ESR：Equivalent Series Resistance（等效串联电阻），影响电池瞬时功率，它的值与温度和电池状态（充/放电）相关。</span><br><span class="line">* T1 Time Constant：它说明了先前电池使用后电池SoC的变化。它的值通常在几分钟的范围内，R1随温度，电池温度和电池SoC级别而变化，对Rslow-C1建模有助于解决滞后行为并改善电池SoC的估计。</span><br></pre></td></tr></table></figure>
<ol>
<li>System SoC：与QG算法一致。</li>
<li>Monotonic SoC：与QG算法一致。<br>详情可以参考《80-vt310-123_c_pmi8994_fuel_gauge_hw_sw_control.pdf》</li>
</ol>
<h3 id="FG-软件"><a href="#FG-软件" class="headerlink" title="FG 软件"></a>FG 软件</h3><h4 id="FG-代码路径"><a href="#FG-代码路径" class="headerlink" title="FG 代码路径"></a>FG 代码路径</h4><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>路径</th>
</tr>
</thead>
<tbody>
<tr>
<td>Driver source code</td>
<td>kernel/drivers/power/qpnp-fg.c.</td>
</tr>
<tr>
<td>Device tree configuration</td>
<td>kernel/arch/arm/boot/dts/qcom/msm-pmi8994.dtsi</td>
</tr>
<tr>
<td>Document</td>
<td>kernel/Documentation/devicetree/bindings/power/qpnp-fg.txt</td>
</tr>
</tbody>
</table>
</div>
<h4 id="FG-代码分析"><a href="#FG-代码分析" class="headerlink" title="FG 代码分析"></a>FG 代码分析</h4><p>整个流程基本和QG算法一致，只是QG算法中各种SoC的值是从用户空间写入到内核中的，而FG算法大部分值是通过硬件计算后写入到寄存器中的。</p>
<p>所以代码分析省略。</p>
<p><strong>总结：</strong><br>Fuel Gauge 算法获取到最终上报的SoC的步骤分为4步：</p>
<ol>
<li>利用电流测量估算出CC_SoC(coulomb-counted SoC)</li>
<li>利用battery model和profile data，使用CC_SoC和电压模式校正，估算出Battery SoC</li>
<li>利用System Cut-Off Voltage和Charge Floating Voltage对Battery SoC掐头去尾（并未所有能量对系统可用），过滤为System SoC</li>
<li>利用放电SoC减少，充电SoC增加的单调性原则，过滤为Monotonic Soc，这个是上报给用户的最终SoC</li>
</ol>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<p><strong>高通电量计算总结：</strong></p>
<ol>
<li>vm-bms：用户空间获取电池内阻，电流，电压等等参数来计算出OCV，然后把该值传递给内核，内核通过查表得到SOC，经过修正得到上报的SOC值。</li>
<li>bms：VM-BMS主要基于OCV的值来进行计算出SOC值，BMS在VM-BMS的基础上，主要引入了库仑计，利用经过电池的电流的累计，计算出电荷量，即综合raw OCV 和 Coulomb count (CC) data计算出SOC值。</li>
<li>Qcom Battery Gauge：用户空间读取内核数据 chip-&gt;kdata,然后经过用户空间高通内部算法，计算出各个soc值（cc_soc,batt_soc,full_soc,sys_soc,catch_up_soc），最后把这些数据写入到内核数据 chip-&gt;udata，内核只是根据这些值计算，判断出msoc作为系统上报的soc.</li>
<li>Fuel Gauge：原理上与 Battery Gauge 是一样的，只是QG算法在 AP 上运行，更便于调整和优化算法，FG 是固化在 PMIC 里面的 Firmware 不能改动，只能微调部分寄存器设置。</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Charing/" rel="tag"># Charing</a>
              <a href="/tags/Battery/" rel="tag"># Battery</a>
          </div>
          <script type="text/javascript">
            var tagsall=document.getElementsByClassName("post-tags")
            for (var i = tagsall.length - 1; i >= 0; i--){
                var tags=tagsall[i].getElementsByTagName("a");
                for (var j = tags.length - 1; j >= 0; j--) {
                    var r=Math.floor(Math.random()*75+130);
                    var g=Math.floor(Math.random()*75+100);
                    var b=Math.floor(Math.random()*75+80);
                    tags[j].style.background = "rgb("+r+","+g+","+b+")";
                }
            }                        
            </script>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2021/01/05/Thermal_Core_Framework_Architecture/" rel="next" title="Thermal Core 框架">
      Thermal Core 框架 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Voltage-Mode-Battery-Monitor-System"><span class="nav-number">1.</span> <span class="nav-text">Voltage Mode Battery Monitor System</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#VM-BMS-%E7%A1%AC%E4%BB%B6%E6%A1%86%E6%9E%B6"><span class="nav-number">1.1.</span> <span class="nav-text">VM-BMS 硬件框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VM-BMS%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-number">1.2.</span> <span class="nav-text">VM-BMS状态机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VM-BMS-%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">VM-BMS 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VM-BMS-%E8%BD%AF%E4%BB%B6"><span class="nav-number">1.4.</span> <span class="nav-text">VM-BMS 软件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#VM-BMS-%E4%BB%A3%E7%A0%81%E8%B7%AF%E5%BE%84%EF%BC%9A"><span class="nav-number">1.4.1.</span> <span class="nav-text">VM-BMS 代码路径：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VM-BMS-%E8%BD%AF%E4%BB%B6%E6%A1%86%E5%9B%BE%EF%BC%9A"><span class="nav-number">1.4.2.</span> <span class="nav-text">VM-BMS 软件框图：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VM-BMS-%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.4.3.</span> <span class="nav-text">VM-BMS 代码分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Battery-Monitor-System"><span class="nav-number">2.</span> <span class="nav-text">Battery Monitor System</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BMS-%E7%A1%AC%E4%BB%B6%E6%A1%86%E6%9E%B6"><span class="nav-number">2.1.</span> <span class="nav-text">BMS 硬件框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BMS%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-number">2.2.</span> <span class="nav-text">BMS状态机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BMS-%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">BMS 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BMS-%E8%BD%AF%E4%BB%B6"><span class="nav-number">2.4.</span> <span class="nav-text">BMS 软件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BMS-%E8%BD%AF%E4%BB%B6%E6%A1%86%E5%9B%BE"><span class="nav-number">2.4.1.</span> <span class="nav-text">BMS 软件框图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BMS-%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">2.4.2.</span> <span class="nav-text">BMS 代码分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Qualcomm-battery-gauge"><span class="nav-number">3.</span> <span class="nav-text">Qualcomm battery gauge</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#QG-%E7%A1%AC%E4%BB%B6%E6%A1%86%E6%9E%B6"><span class="nav-number">3.1.</span> <span class="nav-text">QG 硬件框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#QG-SOC%E6%A6%82%E5%BF%B5"><span class="nav-number">3.2.</span> <span class="nav-text">QG SOC概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-RAW-SOC"><span class="nav-number">3.2.1.</span> <span class="nav-text">1.RAW SOC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-BATTERY-SOC"><span class="nav-number">3.2.2.</span> <span class="nav-text">2.BATTERY SOC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-SYSTEM-SOC"><span class="nav-number">3.2.3.</span> <span class="nav-text">3.SYSTEM SOC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Monotonic-SOC"><span class="nav-number">3.2.4.</span> <span class="nav-text">4.Monotonic SOC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-PON-SOC"><span class="nav-number">3.2.5.</span> <span class="nav-text">5.PON SOC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-SOC-FLOW"><span class="nav-number">3.2.6.</span> <span class="nav-text">6.SOC FLOW</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#QG-%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83"><span class="nav-number">3.3.</span> <span class="nav-text">QG 算法核心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#QG-%E8%BD%AF%E4%BB%B6"><span class="nav-number">3.4.</span> <span class="nav-text">QG  软件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#QG-%E4%BB%A3%E7%A0%81%E8%B7%AF%E5%BE%84"><span class="nav-number">3.4.1.</span> <span class="nav-text">QG 代码路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#QG-%E8%BD%AF%E4%BB%B6%E6%A1%86%E5%9B%BE"><span class="nav-number">3.4.2.</span> <span class="nav-text">QG  软件框图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#QG-%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">3.4.3.</span> <span class="nav-text">QG 代码分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fuel-Gauge"><span class="nav-number">4.</span> <span class="nav-text">Fuel Gauge</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FG-%E6%9E%B6%E6%9E%84"><span class="nav-number">4.1.</span> <span class="nav-text">FG 架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FG-%E7%AE%97%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text">FG 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FG-%E8%BD%AF%E4%BB%B6"><span class="nav-number">4.3.</span> <span class="nav-text">FG 软件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FG-%E4%BB%A3%E7%A0%81%E8%B7%AF%E5%BE%84"><span class="nav-number">4.3.1.</span> <span class="nav-text">FG 代码路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FG-%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">4.3.2.</span> <span class="nav-text">FG 代码分析</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">LexYoung</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LexYoung</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
